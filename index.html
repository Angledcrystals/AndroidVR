<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AndroidVR - Invisible Mirror</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 5px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-bottom: 15px;
        }

        /* VR-optimized camera layout */
        .camera-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        /* Stereo view - optimized for VR headsets with responsive scaling */
        .stereo-view {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 95vw;
            box-sizing: border-box;
        }

        /* Depth view - positioned below stereo frames */
        .depth-view {
            display: flex;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 600px;
        }

        .camera-feed {
            position: relative;
            overflow: hidden;
        }

        /* Enhanced stereo frame sizing for VR with dynamic scaling */
        .stereo-frame {
            flex: 1;
            max-width: calc(50% - 10px);
            min-width: 300px;
            width: 100%;
        }

        .stereo-frame canvas {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            display: block;
        }

        /* Depth frame sizing with responsive scaling */
        .depth-frame {
            width: 100%;
            max-width: 400px;
        }

        .depth-frame canvas {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            max-height: 40vh;
            object-fit: contain;
            display: block;
        }

        canvas, video {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            box-sizing: border-box;
        }

        .left-eye { border-color: #ff4444 !important; }
        .right-eye { border-color: #4444ff !important; }
        .depth-map { border-color: #ff8800 !important; }
        .raw-video { border-color: #00ff88 !important; }

        .camera-label {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .left-label { color: #ff4444; }
        .right-label { color: #4444ff; }
        .depth-label { color: #ff8800; }
        .raw-label { color: #00ff88; }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #00ff88;
            margin-bottom: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 3px;
            font-size: 10px;
            width: 60px;
        }

        select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            cursor: pointer;
            font-size: 10px;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .camera-control {
            background: rgba(0, 255, 136, 0.2) !important;
            border-color: #00ff88 !important;
        }

        .hadit-control {
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: #ff00ff !important;
        }

        .band-control {
            background: rgba(255, 255, 0, 0.2) !important;
            border-color: #ffff00 !important;
        }

        .stereo-control {
            background: rgba(255, 68, 136, 0.2) !important;
            border-color: #ff4488 !important;
        }

        .depth-control {
            background: rgba(255, 136, 0, 0.2) !important;
            border-color: #ff8800 !important;
        }

        .dual-input {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dual-input input[type="range"] {
            flex: 1;
            margin-bottom: 0;
        }

        .dual-input input[type="number"] {
            flex: 0 0 auto;
        }

        .info-panel {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .hadit-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .analysis-panel {
            background: rgba(136, 255, 0, 0.1);
            border: 1px solid #88ff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .processing {
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5) !important;
            animation: processing 1s ease-in-out infinite;
        }

        @keyframes processing {
            0% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
        }

        .fps-counter {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
        }

        .camera-status {
            text-align: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .status-connecting { color: #ffff00; }
        .status-active { color: #00ff88; }
        .status-error { color: #ff4444; }

        .error-message {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #ff4444;
        }

        /* Debug video (visible) */
        #debugVideo {
            max-width: 200px;
            border: 1px solid #ffff00;
        }

        /* Landscape optimizations for VR - Enhanced for better scaling */
        @media (orientation: landscape) and (min-width: 768px) {
            .stereo-view {
                padding: 25px;
                gap: 20px;
                max-width: 98vw;
            }
            
            .stereo-frame {
                max-width: calc(50% - 15px);
                min-width: 350px;
            }
            
            .stereo-frame canvas {
                max-height: 75vh;
            }
            
            .depth-view {
                max-width: 500px;
            }
            
            .camera-label {
                font-size: 14px;
                margin-bottom: 10px;
            }
        }

        /* Mobile and portrait optimizations */
        @media (max-width: 768px), (orientation: portrait) {
            .stereo-view {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                max-width: 95vw;
            }
            
            .stereo-frame {
                min-width: 280px;
                max-width: 90vw;
                width: 100%;
            }
            
            .stereo-frame canvas {
                max-height: 50vh;
            }
            
            .depth-view {
                max-width: 90vw;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Extra large landscape screens (VR friendly) - Enhanced */
        @media (orientation: landscape) and (min-width: 1200px) {
            .stereo-view {
                max-width: 98vw;
                padding: 30px;
                gap: 25px;
            }
            
            .stereo-frame {
                min-width: 450px;
                max-width: calc(50% - 20px);
            }
            
            .stereo-frame canvas {
                max-height: 80vh;
            }
            
            .camera-label {
                font-size: 16px;
            }
        }

        /* Ultra-wide displays (VR optimized) */
        @media (orientation: landscape) and (min-width: 1600px) {
            .stereo-view {
                max-width: 95vw;
                padding: 35px;
                gap: 30px;
            }
            
            .stereo-frame {
                min-width: 600px;
                max-width: calc(50% - 25px);
            }
            
            .stereo-frame canvas {
                max-height: 85vh;
            }
        }

        /* Small screens - ensure no cutoff */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .stereo-view {
                padding: 10px;
                gap: 10px;
                max-width: 98vw;
            }
            
            .stereo-frame {
                min-width: 250px;
                max-width: 95vw;
            }
            
            .stereo-frame canvas {
                max-height: 40vh;
            }
        }

        /* Force canvas to respect container bounds */
        canvas {
            max-width: 100% !important;
            height: auto !important;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AndroidVR - Invisible Mirror </h1>
        <div class="subtitle">Real-time Mirror angle Control with Band Detection & Depth Contrast: 0.1° Precision | 2025-06-07 08:03:18 UTC | User: Angledcrystals</div>

        <div class="hadit-info">
            <div style="color: #ff00ff; font-weight: bold;">⚡ Complete Live Hadit Processing:</div>
            <div>• Real-time camera feed with advanced Hadit band detection</div>
            <div>• θ (Theta): 0° to 360° in 0.1° increments for live adjustment</div>
            <div>• φ (Phi): 0.1° to 179.9° in 0.1° increments for extreme precision</div>
            <div>• Band detection modes: Auto, Content Analysis, Gradient-Based, Statistical, Manual, Full Image</div>
            <div>• Depth Contrast control for enhanced depth perception</div>
            <div>• Band size multiplier and focus controls for precise depth mapping</div>
            <div>• Parallel stereo view with pixel-perfect offset based on Hadit depth</div>
        </div>

        <div class="camera-status" id="cameraStatus">
            <span class="status-connecting">📹 Camera system ready - click Start Camera</span>
        </div>

        <div id="errorPanel" class="error-message" style="display: none;">
            <div style="font-weight: bold;">❌ Camera Error:</div>
            <div id="errorMessage">Unknown error occurred</div>
            <div style="margin-top: 5px; font-size: 10px;">
                • Make sure you allow camera permissions<br>
                • Try switching between front/back camera<br>
                • Check if another app is using the camera<br>
                • Refresh the page and try again
            </div>
        </div>

        <!-- Debug video element (visible for troubleshooting) -->
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="font-size: 11px; color: #ffff00; margin-bottom: 5px;">🔍 DEBUG: Raw Camera Feed</div>
            <video id="debugVideo" autoplay playsinline muted class="raw-video" style="display: none;"></video>
        </div>

        <div class="camera-container">
            <!-- Stereo frames optimized for VR headsets -->
            <div class="stereo-view">
                <div class="camera-feed stereo-frame">
                    <div class="camera-label left-label">Left Eye (Red)</div>
                    <canvas id="leftCanvas" width="640" height="480" class="left-eye"></canvas>
                    <div class="fps-counter" id="leftFps">0 FPS</div>
                </div>
                <div class="camera-feed stereo-frame">
                    <div class="camera-label right-label">Right Eye (Blue)</div>
                    <canvas id="rightCanvas" width="640" height="480" class="right-eye"></canvas>
                    <div class="fps-counter" id="rightFps">0 FPS</div>
                </div>
            </div>
            
            <!-- Depth map positioned below stereo frames -->
            <div class="depth-view">
                <div class="camera-feed depth-frame">
                    <div class="camera-label depth-label">Hadit Depth</div>
                    <canvas id="depthCanvas" width="320" height="240" class="depth-map"></canvas>
                    <div class="fps-counter" id="depthFps">0 FPS</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>📹 Camera Control</label>
                <button id="startCamera" class="camera-control">▶️ Start Camera</button>
                <button id="switchCamera" class="camera-control" style="display: none;">🔄 Switch Camera</button>
                <button id="stopCamera" class="camera-control" style="display: none;">⏹️ Stop Camera</button>
                <button id="requestPermissions" class="camera-control">🔑 Request Permissions</button>
                <button id="toggleDebugVideo" class="camera-control">👁️ Toggle Debug Video</button>
            </div>
            
            <div class="control-group">
                <label>📐 Camera Settings</label>
                <select id="resolutionSelect" class="camera-control">
                    <option value="320x240">320x240 (Low)</option>
                    <option value="640x480" selected>640x480 (VGA)</option>
                    <option value="1280x720">1280x720 (HD)</option>
                    <option value="1920x1080">1920x1080 (FHD)</option>
                </select>
                <select id="facingMode" class="camera-control">
                    <option value="environment" selected>Back Camera</option>
                    <option value="user">Front Camera</option>
                </select>
            </div>

            <div class="control-group">
                <label>📡 Band Detection Mode</label>
                <select id="bandDetectionMode" class="band-control">
                    <option value="auto_detect" selected>🔍 Auto-Detect Band</option>
                    <option value="content_analysis">📊 Content Analysis</option>
                    <option value="gradient_based">🌊 Gradient-Based</option>
                    <option value="statistical">📈 Statistical Analysis</option>
                    <option value="manual_range">✋ Manual Range</option>
                    <option value="full_image">🌍 Full Image Coverage</option>
                </select>
            </div>

            <div class="control-group">
                <label>🔧 Band Size Multiplier: <span id="bandSizeMultiplierValue">10.0x</span></label>
                <input type="range" id="bandSizeMultiplier" min="0.1" max="10.0" step="0.1" value="10.0" class="band-control">
            </div>

            <div class="control-group">
                <label>🎯 Focus Factor: <span id="focusFactorValue">4.0x</span></label>
                <input type="range" id="focusFactor" min="1.0" max="5.0" step="0.1" value="4.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>⚡ Hadit θ (Theta): <span id="haditThetaValue">0.0°</span></label>
                <div class="dual-input">
                    <input type="range" id="haditTheta" min="0" max="360" value="0" step="0.1" class="hadit-control">
                    <input type="number" id="haditThetaNumber" min="0" max="360" step="0.1" value="0" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>⚡ Hadit φ (Phi): <span id="haditPhiValue">0.1°</span></label>
                <div class="dual-input">
                    <input type="range" id="haditPhi" min="0.1" max="179.9" value="0.1" step="0.1" class="hadit-control">
                    <input type="number" id="haditPhiNumber" min="0.1" max="179.9" step="0.1" value="0.1" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>🌊 Hadit Influence: <span id="haditInfluenceValue">1.0</span></label>
                <input type="range" id="haditInfluence" min="0" max="2" value="1.0" step="0.1" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>👁️ Stereo Separation: <span id="separationValue">8px</span></label>
                <input type="range" id="separation" min="0" max="50" value="8" step="1" class="stereo-control">
            </div>
            
            <div class="control-group">
                <label>🗺️ Depth Intensity: <span id="depthIntensityValue">2.0x</span></label>
                <input type="range" id="depthIntensity" min="0.1" max="5.0" value="2.0" step="0.1" class="depth-control">
            </div>

            <div class="control-group">
                <label>🎨 Depth Contrast: <span id="depthContrastValue">0.2x</span></label>
                <input type="range" id="depthContrast" min="0.1" max="3.0" value="0.2" step="0.1" class="depth-control">
            </div>
            
            <div class="control-group">
                <label>📐 S Bounds: <span id="sBoundsValue">±20.0</span></label>
                <input type="range" id="sBounds" min="1.0" max="20.0" step="0.1" value="20.0" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>💡 Luminosity Weight: <span id="luminosityWeightValue">0.0</span></label>
                <input type="range" id="luminosityWeight" min="0" max="1" step="0.05" value="0.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>🌈 Saturation Weight: <span id="saturationWeightValue">0.0</span></label>
                <input type="range" id="saturationWeight" min="0" max="1" step="0.05" value="0.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>⚙️ Processing Quality</label>
                <select id="qualitySelect" class="depth-control">
                    <option value="1.0">Full Quality</option>
                    <option value="0.75" selected>High Quality</option>
                    <option value="0.5">Medium Quality</option>
                    <option value="0.25">Low Quality</option>
                </select>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <div>Status: Complete Live Hadit camera system ready... Angledcrystals | 2025-06-07 08:03:18 UTC</div>
        </div>

        <div class="analysis-grid">
            <div>
                <div class="control-group">
                    <label>Quick Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHaditPole" class="hadit-control">φ=0.1° (Pole)</button>
                        <button id="setHaditEquator" class="hadit-control">φ=90° (Equator)</button>
                        <button id="setHaditNear180" class="hadit-control">φ=179.9° (Anti-pole)</button>
                        <button id="animateTheta" class="hadit-control">🌀 Animate θ</button>
                        <button id="animatePhi" class="hadit-control">🌊 Animate φ</button>
                        <button id="stopAnimation" class="hadit-control">⏹️ Stop All</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Depth Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHighContrast" class="depth-control">🔆 High Contrast</button>
                        <button id="setLowContrast" class="depth-control">🔅 Low Contrast</button>
                        <button id="setExtremeDepth" class="depth-control">💥 Extreme Depth</button>
                        <button id="setSubtleDepth" class="depth-control">🌫️ Subtle Depth</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Band Actions</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="detectBand" class="band-control">📡 Detect Band</button>
                        <button id="expandBandFull" class="band-control">🌍 Expand Full</button>
                        <button id="resetBand" class="band-control">🔄 Reset Band</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Options & Debug</label>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label><input type="checkbox" id="enableStereo" checked> Enable Stereo</label>
                        <label><input type="checkbox" id="showDepthMap" checked> Show Depth</label>
                        <label><input type="checkbox" id="showBandVisualization"> Show Band Viz</label>
                        <label><input type="checkbox" id="focusOnlyBand"> Focus Only Band</label>
                        <label><input type="checkbox" id="mirrorCamera"> Mirror Camera</label>
                        <label><input type="checkbox" id="showFPS" checked> Show FPS</label>
                        <label><input type="checkbox" id="debugMode" checked> Debug Mode</label>
                        <label><input type="checkbox" id="showRawFeed"> Show Raw Feed</label>
                    </div>
                </div>
            </div>
            
            <div class="analysis-panel" id="analysisPanel">
                <div style="color: #88ff00; font-weight: bold;">⚡ Live Hadit Band Analysis</div>
                <div>Ready for live camera processing with band detection...</div>
                <div>Camera permissions status: checking...</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== HADIT MATHEMATICS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function calculateHaditModulatedSCoordinate(px, py, width, height, lum, sat, config) {
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            const contentModulation = (1 + lum * config.luminosityWeight + sat * config.saturationWeight);
            
            return {
                sCoord: {
                    x: S_hadit.x * contentModulation * config.haditInfluence,
                    y: S_hadit.y * contentModulation * config.haditInfluence
                },
                sMagnitude: Math.sqrt(
                    Math.pow(S_hadit.x * contentModulation * config.haditInfluence, 2) +
                    Math.pow(S_hadit.y * contentModulation * config.haditInfluence, 2)
                ),
                originalG: G_3d,
                reflectedG: G_reflected,
                haditVector: hadit_3d,
                contentModulation: contentModulation,
                luminance: lum,
                saturation: sat
            };
        }

        // ==================== DEPTH CONTRAST PROCESSING ====================
        
        function applyDepthContrast(depth, contrast, bandCenteredness = 1.0) {
            // Apply depth contrast enhancement
            const centerAdjusted = 0.5; // Depth center point
            let contrastAdjustedDepth = centerAdjusted + (depth - centerAdjusted) * contrast;
            
            // Apply band-aware contrast boosting
            if (bandCenteredness > 0.5) {
                const bandBoost = 1.0 + (bandCenteredness - 0.5) * 0.5; // Up to 25% boost for center band pixels
                contrastAdjustedDepth = centerAdjusted + (contrastAdjustedDepth - centerAdjusted) * bandBoost;
            }
            
            // Ensure depth stays in valid range
            return Math.max(0.05, Math.min(1.0, contrastAdjustedDepth));
        }

        // ==================== HADIT INFORMATION BAND DETECTION ====================
        
        let currentSBounds = 20.0;
        let detectedBand = { min: 0, max: 0, center: 0, width: 0, confidence: 0 };

        function detectHaditInformationBand(imageData, config) {
            console.log(`📡 Detecting band with Hadit θ=${config.haditTheta.toFixed(1)}°, φ=${config.haditPhi.toFixed(1)}°`);
            const startTime = performance.now();
            
            const { width, height, data } = imageData;
            const sMagnitudeHistogram = new Array(200).fill(0);
            const contentHistogram = new Array(200).fill(0);
            
            const maxSMagnitude = currentSBounds * 2;
            let totalPixels = 0;
            let totalContent = 0;
            
            const sampleStep = Math.max(1, Math.floor(Math.min(width, height) / 50));
            
            for (let y = 0; y < height; y += sampleStep) {
                for (let x = 0; x < width; x += sampleStep) {
                    const pixelIdx = (y * width + x) * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const result = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                    const sMagnitude = result.sMagnitude;
                    
                    const contentImportance = lum * 0.5 + sat * 0.3 + 
                                            (Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r)) * 0.2;
                    
                    const binIndex = Math.floor((sMagnitude / maxSMagnitude) * (sMagnitudeHistogram.length - 1));
                    if (binIndex >= 0 && binIndex < sMagnitudeHistogram.length) {
                        sMagnitudeHistogram[binIndex]++;
                        contentHistogram[binIndex] += contentImportance;
                        totalContent += contentImportance;
                    }
                    
                    totalPixels++;
                }
            }
            
            let bandDetectionResult;
            
            switch (config.bandDetectionMode) {
                case 'full_image':
                    bandDetectionResult = {
                        min: 0,
                        max: maxSMagnitude * 2,
                        center: maxSMagnitude,
                        width: maxSMagnitude * 2,
                        confidence: 1.0
                    };
                    break;
                    
                case 'auto_detect':
                    bandDetectionResult = autoDetectBand(sMagnitudeHistogram, contentHistogram, maxSMagnitude, 0.1);
                    break;
                    
                case 'content_analysis':
                    bandDetectionResult = contentBasedBandDetection(contentHistogram, maxSMagnitude, 0.1);
                    break;
                    
                case 'gradient_based':
                    bandDetectionResult = gradientBasedBandDetection(sMagnitudeHistogram, maxSMagnitude, 0.1);
                    break;
                    
                case 'statistical':
                    bandDetectionResult = statisticalBandDetection(sMagnitudeHistogram, contentHistogram, maxSMagnitude, 0.1);
                    break;
                    
                case 'manual_range':
                    bandDetectionResult = {
                        min: config.manualBandMin || 0,
                        max: config.manualBandMax || maxSMagnitude,
                        center: ((config.manualBandMin || 0) + (config.manualBandMax || maxSMagnitude)) / 2,
                        width: (config.manualBandMax || maxSMagnitude) - (config.manualBandMin || 0),
                        confidence: 1.0
                    };
                    break;
            }
            
            // Apply band size multiplier
            if (config.bandSizeMultiplier !== 1.0) {
                const originalWidth = bandDetectionResult.width;
                const newWidth = originalWidth * config.bandSizeMultiplier;
                const expansion = (newWidth - originalWidth) / 2;
                
                bandDetectionResult.min = Math.max(0, bandDetectionResult.min - expansion);
                bandDetectionResult.max = bandDetectionResult.max + expansion;
                bandDetectionResult.width = newWidth;
            }
            
            const processingTime = performance.now() - startTime;
            
            console.log(`✅ Band detection completed in ${processingTime.toFixed(2)}ms`);
            console.log(`   Detected band: ${bandDetectionResult.min.toFixed(2)} to ${bandDetectionResult.max.toFixed(2)}`);
            
            return {
                band: bandDetectionResult,
                histograms: {
                    sMagnitude: sMagnitudeHistogram,
                    content: contentHistogram
                },
                stats: {
                    processingTime,
                    totalPixels,
                    totalContent,
                    maxSMagnitude,
                    samplingStep: sampleStep
                }
            };
        }

        function autoDetectBand(sMagnitudeHistogram, contentHistogram, maxSMagnitude, sensitivity) {
            const smoothedContent = smoothHistogram(contentHistogram, 3);
            const peaks = findHistogramPeaks(smoothedContent, sensitivity);
            
            if (peaks.length === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            const primaryPeak = peaks.reduce((max, peak) => peak.strength > max.strength ? peak : max);
            const bandHalfWidth = Math.max(0.5, maxSMagnitude * 0.1);
            const binToSMagnitude = (bin) => (bin / (smoothedContent.length - 1)) * maxSMagnitude;
            
            const bandCenter = binToSMagnitude(primaryPeak.bin);
            const bandMin = Math.max(0, bandCenter - bandHalfWidth);
            const bandMax = Math.min(maxSMagnitude, bandCenter + bandHalfWidth);
            
            return {
                min: bandMin,
                max: bandMax,
                center: bandCenter,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, primaryPeak.strength / (smoothedContent.length * 0.1))
            };
        }

        function contentBasedBandDetection(contentHistogram, maxSMagnitude, sensitivity) {
            let totalContent = contentHistogram.reduce((sum, val) => sum + val, 0);
            if (totalContent === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            let weightedSum = 0;
            for (let i = 0; i < contentHistogram.length; i++) {
                weightedSum += i * contentHistogram[i];
            }
            const centerOfMass = weightedSum / totalContent;
            
            const threshold = totalContent * sensitivity * 0.01;
            let minBin = 0, maxBin = contentHistogram.length - 1;
            
            for (let i = 0; i < contentHistogram.length; i++) {
                if (contentHistogram[i] > threshold) {
                    minBin = i;
                    break;
                }
            }
            
            for (let i = contentHistogram.length - 1; i >= 0; i--) {
                if (contentHistogram[i] > threshold) {
                    maxBin = i;
                    break;
                }
            }
            
            const binToSMagnitude = (bin) => (bin / (contentHistogram.length - 1)) * maxSMagnitude;
            
            return {
                min: binToSMagnitude(minBin),
                max: binToSMagnitude(maxBin),
                center: binToSMagnitude(centerOfMass),
                width: binToSMagnitude(maxBin) - binToSMagnitude(minBin),
                confidence: Math.min(1.0, (maxBin - minBin) / (contentHistogram.length * 0.5))
            };
        }

        function gradientBasedBandDetection(sMagnitudeHistogram, maxSMagnitude, sensitivity) {
            const gradient = [];
            for (let i = 1; i < sMagnitudeHistogram.length - 1; i++) {
                gradient[i] = sMagnitudeHistogram[i + 1] - sMagnitudeHistogram[i - 1];
            }
            
            const threshold = Math.max(...gradient) * sensitivity;
            let risingEdges = [];
            let fallingEdges = [];
            
            for (let i = 0; i < gradient.length; i++) {
                if (gradient[i] > threshold) risingEdges.push(i);
                if (gradient[i] < -threshold) fallingEdges.push(i);
            }
            
            if (risingEdges.length === 0 || fallingEdges.length === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            const binToSMagnitude = (bin) => (bin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const bandMin = binToSMagnitude(risingEdges[0]);
            const bandMax = binToSMagnitude(fallingEdges[fallingEdges.length - 1]);
            
            return {
                min: bandMin,
                max: bandMax,
                center: (bandMin + bandMax) / 2,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, (risingEdges.length + fallingEdges.length) / 10)
            };
        }

        function statisticalBandDetection(sMagnitudeHistogram, contentHistogram, maxSMagnitude, sensitivity) {
            let mean = 0, variance = 0, total = 0;
            
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                const count = sMagnitudeHistogram[i];
                mean += i * count;
                total += count;
            }
            
            if (total === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            mean /= total;
            
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                const count = sMagnitudeHistogram[i];
                variance += Math.pow(i - mean, 2) * count;
            }
            variance /= total;
            
            const stdDev = Math.sqrt(variance);
            const bandHalfWidth = stdDev * (2 - sensitivity);
            
            const binToSMagnitude = (bin) => (bin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const center = binToSMagnitude(mean);
            const bandMin = Math.max(0, center - binToSMagnitude(bandHalfWidth));
            const bandMax = Math.min(maxSMagnitude, center + binToSMagnitude(bandHalfWidth));
            
            return {
                min: bandMin,
                max: bandMax,
                center: center,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, stdDev / (sMagnitudeHistogram.length * 0.2))
            };
        }

        function smoothHistogram(histogram, radius) {
            const smoothed = new Array(histogram.length).fill(0);
            for (let i = 0; i < histogram.length; i++) {
                let sum = 0, count = 0;
                for (let j = Math.max(0, i - radius); j <= Math.min(histogram.length - 1, i + radius); j++) {
                    sum += histogram[j];
                    count++;
                }
                smoothed[i] = sum / count;
            }
            return smoothed;
        }

        function findHistogramPeaks(histogram, sensitivity) {
            const peaks = [];
            const minPeakHeight = Math.max(...histogram) * sensitivity * 0.1;
            
            for (let i = 1; i < histogram.length - 1; i++) {
                if (histogram[i] > histogram[i - 1] && 
                    histogram[i] > histogram[i + 1] && 
                    histogram[i] > minPeakHeight) {
                    peaks.push({
                        bin: i,
                        strength: histogram[i]
                    });
                }
            }
            
            return peaks;
        }

        // ==================== BAND-FOCUSED DEPTH GENERATION WITH CONTRAST ====================
        
        function generateBandFocusedDepth(imageData, config, detectedBand) {
            console.log('📡 Generating precise Hadit depth map with contrast enhancement...');
            const startTime = performance.now();
            
            const { width, height, data } = imageData;
            const depthBuffer = new Array(width * height);
            
            currentSBounds = config.sBounds;
            
            let minDepth = 1, maxDepth = 0, totalDepth = 0;
            let pixelsInBand = 0, pixelsOutsideBand = 0;
            let bandDepthSum = 0, outsideDepthSum = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const result = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                    const { sCoord, sMagnitude } = result;
                    
                    const isInBand = sMagnitude >= detectedBand.min && sMagnitude <= detectedBand.max;
                    const distanceFromBandCenter = Math.abs(sMagnitude - detectedBand.center);
                    const bandPosition = Math.max(0, Math.min(1, (sMagnitude - detectedBand.min) / Math.max(0.001, detectedBand.width)));
                    
                    let depth = 0.1;
                    let bandCenteredness = 0;
                    
                    if (isInBand) {
                        pixelsInBand++;
                        
                        bandCenteredness = detectedBand.width > 0 ? 
                            1.0 - (distanceFromBandCenter / (detectedBand.width * 0.5)) : 1.0;
                        bandCenteredness = Math.max(0, Math.min(1, bandCenteredness));
                        
                        const contentWeight = lum * 0.5 + sat * 0.3;
                        
                        depth = 0.3 + bandPosition * 0.6;
                        depth *= (1 + Math.max(0, bandCenteredness) * config.focusFactor * 0.2);
                        depth *= (1 + contentWeight * 0.3);
                        
                        bandDepthSum += depth;
                        
                    } else {
                        pixelsOutsideBand++;
                        
                        if (config.focusOnlyBand) {
                            depth = 0.05 + (lum * 0.1);
                        } else {
                            const falloffDistance = Math.min(
                                Math.abs(sMagnitude - detectedBand.min),
                                Math.abs(sMagnitude - detectedBand.max)
                            );
                            const falloffFactor = 1.0 / (1.0 + falloffDistance * 0.5);
                            depth = 0.1 + lum * 0.2 * falloffFactor;
                        }
                        
                        outsideDepthSum += depth;
                    }
                    
                    if (isInBand && config.focusFactor > 1.0) {
                        depth = 0.5 + (depth - 0.5) * config.focusFactor;
                    }
                    
                    // 🎨 APPLY DEPTH CONTRAST ENHANCEMENT
                    depth = applyDepthContrast(depth, config.depthContrast, bandCenteredness);
                    
                    depth = Math.max(0.05, Math.min(1.0, depth));
                    
                    minDepth = Math.min(minDepth, depth);
                    maxDepth = Math.max(maxDepth, depth);
                    totalDepth += depth;
                    
                    depthBuffer[idx] = {
                        depth: depth,
                        sCoord: sCoord,
                        sMagnitude: sMagnitude,
                        isInBand: isInBand,
                        bandPosition: bandPosition,
                        distanceFromBandCenter: distanceFromBandCenter,
                        bandCenteredness: bandCenteredness,
                        luminance: lum,
                        saturation: sat,
                        haditResult: result,
                        coverage: true
                    };
                }
            }
            
            const processingTime = performance.now() - startTime;
            const avgDepth = totalDepth / (width * height);
            const avgBandDepth = pixelsInBand > 0 ? bandDepthSum / pixelsInBand : 0;
            const avgOutsideDepth = pixelsOutsideBand > 0 ? outsideDepthSum / pixelsOutsideBand : 0;
            
            console.log(`✅ Precise depth with contrast generated in ${processingTime.toFixed(2)}ms`);
            console.log(`   θ=${config.haditTheta.toFixed(1)}°, φ=${config.haditPhi.toFixed(1)}°, Contrast=${config.depthContrast.toFixed(1)}x`);
            console.log(`   Pixels in band: ${pixelsInBand}/${width * height} (${(pixelsInBand/(width*height)*100).toFixed(1)}%)`);
            
            return {
                depthBuffer,
                stats: {
                    processingTime,
                    minDepth,
                    maxDepth,
                    avgDepth,
                    avgBandDepth,
                    avgOutsideDepth,
                    pixelsInBand,
                    pixelsOutsideBand,
                    bandCoverage: pixelsInBand / (width * height),
                    detectedBand: detectedBand,
                    haditTheta: config.haditTheta,
                    haditPhi: config.haditPhi,
                    focusFactor: config.focusFactor,
                    depthContrast: config.depthContrast,
                    focusOnlyBand: config.focusOnlyBand,
                    bandSizeMultiplier: config.bandSizeMultiplier
                }
            };
        }

        // ==================== ENHANCED CAMERA SYSTEM WITH DEPTH CONTRAST ====================
        
        class LiveHaditCamera {
            constructor() {
                this.video = null;
                this.debugVideo = document.getElementById('debugVideo');
                this.stream = null;
                this.isRunning = false;
                this.animationFrameId = null;
                this.animationId = null;
                this.availableCameras = [];
                this.currentCameraIndex = 0;
                
                this.frameCount = 0;
                this.lastFpsTime = 0;
                this.currentFps = 0;
                
                this.processingCanvas = document.createElement('canvas');
                this.processingCtx = this.processingCanvas.getContext('2d');
                
                // Band detection state
                this.currentBandDetectionResult = null;
                this.currentDepthResult = null;
                
                this.initializeControls();
                this.setupCanvases();
                this.setupDebugVideo();
                this.checkCameraPermissions();
                this.updateInfoPanel(`Complete Live Hadit camera system with Depth Contrast ready! | Angledcrystals | 2025-06-07 08:03:18`);
                
                console.log('✅ Complete Live Hadit Camera System with Depth Contrast initialized!');
                console.log('🎨 Depth Contrast control: 0.1x to 3.0x enhancement');
                console.log('🎯 Full band detection modes available');
                console.log('θ (Theta) range: 0° to 360° in 0.1° increments');
                console.log('φ (Phi) range: 0.1° to 179.9° in 0.1° increments');
            }

            getConfiguration() {
                return {
                    // Hadit parameters
                    haditTheta: parseFloat(document.getElementById('haditTheta')?.value || 45),
                    haditPhi: parseFloat(document.getElementById('haditPhi')?.value || 60),
                    haditInfluence: parseFloat(document.getElementById('haditInfluence')?.value || 1.0),
                    
                    // Band detection parameters
                    bandDetectionMode: document.getElementById('bandDetectionMode')?.value || 'auto_detect',
                    bandSizeMultiplier: parseFloat(document.getElementById('bandSizeMultiplier')?.value || 1.0),
                    focusFactor: parseFloat(document.getElementById('focusFactor')?.value || 2.0),
                    
                    // Processing parameters
                    separation: parseFloat(document.getElementById('separation')?.value || 8),
                    depthIntensity: parseFloat(document.getElementById('depthIntensity')?.value || 1.5),
                    depthContrast: parseFloat(document.getElementById('depthContrast')?.value || 1.0), // 🎨 NEW!
                    sBounds: parseFloat(document.getElementById('sBounds')?.value || 10.0),
                    luminosityWeight: parseFloat(document.getElementById('luminosityWeight')?.value || 0.7),
                    saturationWeight: parseFloat(document.getElementById('saturationWeight')?.value || 0.3),
                    quality: parseFloat(document.getElementById('qualitySelect')?.value || 0.75),
                    
                    // Options
                    enableStereo: document.getElementById('enableStereo')?.checked ?? true,
                    showDepthMap: document.getElementById('showDepthMap')?.checked ?? true,
                    showBandVisualization: document.getElementById('showBandVisualization')?.checked ?? false,
                    focusOnlyBand: document.getElementById('focusOnlyBand')?.checked ?? false,
                    mirrorCamera: document.getElementById('mirrorCamera')?.checked ?? false,
                    showFPS: document.getElementById('showFPS')?.checked ?? true,
                    debugMode: document.getElementById('debugMode')?.checked ?? false,
                    showRawFeed: document.getElementById('showRawFeed')?.checked ?? false
                };
            }

            // Depth preset methods
            setHighContrast() {
                document.getElementById('depthContrast').value = '2.5';
                document.getElementById('depthIntensity').value = '3.0';
                document.getElementById('focusFactor').value = '4.0';
                this.updateControlValues();
                this.updateInfoPanel('High contrast depth preset applied - enhanced depth perception!');
            }

            setLowContrast() {
                document.getElementById('depthContrast').value = '0.3';
                document.getElementById('depthIntensity').value = '0.8';
                document.getElementById('focusFactor').value = '1.2';
                this.updateControlValues();
                this.updateInfoPanel('Low contrast depth preset applied - subtle depth effect.');
            }

            setExtremeDepth() {
                document.getElementById('depthContrast').value = '3.0';
                document.getElementById('depthIntensity').value = '5.0';
                document.getElementById('separation').value = '25';
                document.getElementById('focusFactor').value = '5.0';
                this.updateControlValues();
                this.updateInfoPanel('Extreme depth preset applied - maximum 3D effect!');
            }

            setSubtleDepth() {
                document.getElementById('depthContrast').value = '0.5';
                document.getElementById('depthIntensity').value = '0.5';
                document.getElementById('separation').value = '3';
                document.getElementById('focusFactor').value = '1.0';
                this.updateControlValues();
                this.updateInfoPanel('Subtle depth preset applied - gentle 3D effect.');
            }

            // Continue with all the existing camera methods but I'll include the key updates...
            
            setupDebugVideo() {
                if (this.debugVideo) {
                    this.debugVideo.autoplay = true;
                    this.debugVideo.playsInline = true;
                    this.debugVideo.muted = true;
                } else {
                    console.error("Debug video element not found in HTML!");
                }
            }

            async checkCameraPermissions() {
                try {
                    if (!navigator.permissions || !navigator.permissions.query) {
                        this.updateAnalysisInfo('Camera permission: query API not supported, will try direct access on start.');
                        return;
                    }
                    const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                    this.updateAnalysisInfo(`Camera permission: ${permissionStatus.state}`);
                    
                    if (permissionStatus.state === 'granted') {
                        await this.enumerateCameras();
                    } else if (permissionStatus.state === 'prompt') {
                        this.updateAnalysisInfo('Camera permission: will prompt when starting');
                    } else {
                        this.showError('Camera permission denied. Please enable camera access in browser settings.');
                    }
                    
                    permissionStatus.onchange = () => {
                        this.updateAnalysisInfo(`Camera permission changed: ${permissionStatus.state}`);
                    };
                    
                } catch (error) {
                    console.error('Error checking camera permissions:', error);
                    this.updateAnalysisInfo('Camera permission: error checking status.');
                }
            }

            async enumerateCameras() {
                try {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                        this.updateAnalysisInfo("Camera enumeration not supported.");
                        return;
                    }
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.availableCameras = devices.filter(device => device.kind === 'videoinput');
                    this.updateAnalysisInfo(`Found ${this.availableCameras.length} camera(s)`);
                    this.availableCameras.forEach((camera, index) => {
                        console.log(`Camera ${index}: ${camera.label || `Camera ${index+1}`} (ID: ${camera.deviceId})`);
                    });
                } catch (error) {
                    console.error('Camera enumeration error:', error);
                    this.updateAnalysisInfo('Camera enumeration failed.');
                }
            }

            setupCanvases() {
                this.leftCanvas = document.getElementById('leftCanvas');
                this.rightCanvas = document.getElementById('rightCanvas');
                this.depthCanvas = document.getElementById('depthCanvas');
                
                if (!this.leftCanvas || !this.rightCanvas || !this.depthCanvas) {
                    console.error("One or more display canvases not found!");
                    this.showError("Critical error: Display canvases missing.");
                    return;
                }

                this.leftCtx = this.leftCanvas.getContext('2d');
                this.rightCtx = this.rightCanvas.getContext('2d');
                this.depthCtx = this.depthCanvas.getContext('2d');
            }

            // Include all the camera control methods from the previous version...
            // (requestPermissions, startCamera, stopCamera, switchCamera, toggleDebugVideo)

            async requestPermissions() {
                try {
                    this.updateCameraStatus('📹 Requesting camera permissions...', 'connecting');
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        this.showError('getUserMedia is not supported in this browser.');
                        this.updateCameraStatus('❌ getUserMedia not supported', 'error');
                        return;
                    }
                    const testStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: { ideal: 320 }, height: { ideal: 240 } } 
                    });
                    testStream.getTracks().forEach(track => track.stop());
                    this.updateCameraStatus('✅ Camera permissions granted', 'active');
                    await this.checkCameraPermissions();
                } catch (error) {
                    console.error('Failed to get camera permissions:', error);
                    this.showError(`Failed to get camera permissions: ${error.message} (Name: ${error.name})`);
                    this.updateCameraStatus('❌ Camera permissions denied', 'error');
                }
            }

            async startCamera() {
                try {
                    this.hideError();
                    this.updateCameraStatus('📹 Starting camera...', 'connecting');
                    
                    const resolution = document.getElementById('resolutionSelect').value.split('x');
                    const width = parseInt(resolution[0]);
                    const height = parseInt(resolution[1]);
                    const facingMode = document.getElementById('facingMode').value;
                    
                    const constraints = {
                        video: {
                            width: { ideal: width, min: 320 },
                            height: { ideal: height, min: 240 },
                            frameRate: { ideal: 30, min: 15 }
                        }
                    };

                    if (this.availableCameras.length > 0 && this.availableCameras[this.currentCameraIndex]?.deviceId) {
                        constraints.video.deviceId = { exact: this.availableCameras[this.currentCameraIndex].deviceId };
                        console.log(`Attempting to use camera by ID: ${constraints.video.deviceId.exact}`);
                    } else {
                        constraints.video.facingMode = { ideal: facingMode };
                        console.log(`Attempting to use camera by facingMode: ${constraints.video.facingMode.ideal}`);
                    }

                    if (this.stream) {
                        this.stream.getTracks().forEach(track => track.stop());
                    }

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);

                    if (!this.video) {
                        this.video = document.createElement('video');
                        this.video.autoplay = true;
                        this.video.playsInline = true;
                        this.video.muted = true;
                        this.video.style.display = 'none';
                        document.body.appendChild(this.video);
                    }
                    
                    this.video.srcObject = this.stream;
                    if (this.debugVideo) {
                        this.debugVideo.srcObject = this.stream;
                    }
                    
                    const playPromises = [];
                    if (this.video) {
                        playPromises.push(this.video.play().catch(e => {
                            console.error("Processing video play error:", e);
                        }));
                    }
                    if (this.debugVideo) {
                        playPromises.push(this.debugVideo.play().catch(e => {
                            console.error("Debug video play error:", e);
                        }));
                    }
                    
                    await Promise.all(playPromises);

                    await new Promise((resolve, reject) => {
                        if (!this.video) {
                            reject(new Error("Processing video element not found"));
                            return;
                        }
                        const timeout = setTimeout(() => {                            reject(new Error(`Video load timeout. ReadyState: ${this.video?.readyState}. Stream active: ${this.stream?.active}`));
                        }, 10000);
                        
                        const handleLoad = () => {
                            clearTimeout(timeout);
                            console.log(`📺 Processing video ready: ${this.video.videoWidth}x${this.video.videoHeight}`);
                            resolve();
                        };
                        
                        this.video.addEventListener('loadedmetadata', handleLoad, { once: true });
                        this.video.addEventListener('error', (e) => {
                            clearTimeout(timeout);
                            let errorMsg = 'Processing video load error';
                            if (this.video && this.video.error) {
                                errorMsg += `: Code ${this.video.error.code}, Message: ${this.video.error.message}`;
                            }
                            reject(new Error(errorMsg));
                        }, { once: true });

                        if (this.video.readyState >= HTMLMediaElement.HAVE_METADATA) {
                            handleLoad();
                        }
                    });
                    
                    this.isRunning = true;
                    this.updateCameraStatus('📹 Camera active - Live Hadit Band processing with Depth Contrast', 'active');
                    this.updateInfoPanel(`Camera started: ${this.video?.videoWidth || 'N/A'}x${this.video?.videoHeight || 'N/A'} | Live Hadit band processing with depth contrast active`);
                    
                    this.startProcessingLoop();
                    
                    document.getElementById('startCamera').style.display = 'none';
                    document.getElementById('switchCamera').style.display = 'inline-block';
                    document.getElementById('stopCamera').style.display = 'inline-block';
                    
                } catch (error) {
                    console.error('🚫 Camera start error:', error);
                    this.showError('Camera start failed: ' + (error.message || error.name || error));
                    this.updateCameraStatus('❌ Camera start failed', 'error');
                    
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        this.showError('Camera permission denied. Please allow camera access and try again.');
                    } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                        this.showError('No camera found. Please connect a camera and try again.');
                    } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                        this.showError('Camera is busy or unreadable. Close other apps using the camera and try again.');
                    } else if (error.name === 'OverconstrainedError') {
                        this.showError(`The selected resolution/camera is not supported. Try different settings. Error: ${error.message}`);
                    } else {
                        this.showError(`Camera error: ${error.name} - ${error.message}`);
                    }
                }
            }

            stopCamera() {
                this.isRunning = false;
                console.log("Stopping camera...");
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                if (this.video) {
                    this.video.srcObject = null;
                }
                
                if (this.debugVideo) {
                    this.debugVideo.srcObject = null;
                }
                
                this.updateCameraStatus('📹 Camera stopped', 'connecting');
                this.updateInfoPanel('Camera stopped. Click Start Camera to resume live Hadit band processing with depth contrast.');
                
                document.getElementById('startCamera').style.display = 'inline-block';
                document.getElementById('switchCamera').style.display = 'none';
                document.getElementById('stopCamera').style.display = 'none';
                
                [this.leftCtx, this.rightCtx, this.depthCtx].forEach(ctx => {
                    if (ctx && ctx.canvas) {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    }
                });
                this.updateFpsDisplay(true);
            }

            async switchCamera() {
                this.updateCameraStatus('🔄 Switching camera...', 'connecting');
                if (this.availableCameras.length > 1) {
                    this.currentCameraIndex = (this.currentCameraIndex + 1) % this.availableCameras.length;
                    const selectedCamera = this.availableCameras[this.currentCameraIndex];
                    this.updateInfoPanel(`Switching to camera ${selectedCamera.label || `Camera ${this.currentCameraIndex + 1}`}...`);
                    await this.startCamera();
                } else {
                    const facingModeSelect = document.getElementById('facingMode');
                    facingModeSelect.value = facingModeSelect.value === 'user' ? 'environment' : 'user';
                    this.updateInfoPanel(`Switched facing mode to ${facingModeSelect.value}. Restarting camera...`);
                    await this.startCamera();
                }
            }

            toggleDebugVideo() {
                const showRawFeedCheckbox = document.getElementById('showRawFeed');
                
                if (!this.debugVideo) {
                    console.error("Debug video element not found for toggle.");
                    return;
                }

                if (this.debugVideo.style.display === 'none') {
                    this.debugVideo.style.display = 'block';
                    if (showRawFeedCheckbox) showRawFeedCheckbox.checked = true;
                    this.updateInfoPanel('Debug video enabled - raw camera feed visible.');
                } else {
                    this.debugVideo.style.display = 'none';
                    if (showRawFeedCheckbox) showRawFeedCheckbox.checked = false;
                    this.updateInfoPanel('Debug video hidden.');
                }
            }

            startProcessingLoop() {
                const targetFPS = 30;
                const targetInterval = 1000 / targetFPS;
                let lastTime = performance.now();
                
                console.log(`🔄 Starting complete Hadit band processing loop with depth contrast enhancement`);
                
                const processFrame = (currentTime) => {
                    if (!this.isRunning) {
                        console.log('⏹️ Processing loop stopped');
                        return;
                    }
                    
                    this.animationFrameId = requestAnimationFrame(processFrame);

                    const deltaTime = currentTime - lastTime;
                    if (deltaTime >= targetInterval) {
                        lastTime = currentTime - (deltaTime % targetInterval);
                        
                        this.processVideoFrameWithBandDetection();
                        
                        this.frameCount++;
                    }

                    if (currentTime - this.lastFpsTime >= 1000) {
                        this.currentFps = this.frameCount;
                        this.frameCount = 0;
                        this.lastFpsTime = currentTime;
                        if (this.getConfiguration().showFPS) {
                            this.updateFpsDisplay();
                        }
                    }
                };
                
                this.animationFrameId = requestAnimationFrame(processFrame);
            }

            processVideoFrameWithBandDetection() {
                if (!this.video || this.video.readyState < HTMLMediaElement.HAVE_CURRENT_DATA || this.video.videoWidth === 0 || this.video.videoHeight === 0) {
                    return;
                }
                
                const config = this.getConfiguration();
                const startTime = performance.now();
                
                try {
                    const sourceWidth = this.video.videoWidth;
                    const sourceHeight = this.video.videoHeight;
                    const processWidth = Math.max(1, Math.floor(sourceWidth * config.quality));
                    const processHeight = Math.max(1, Math.floor(sourceHeight * config.quality));
                    
                    if (this.processingCanvas.width !== processWidth) this.processingCanvas.width = processWidth;
                    if (this.processingCanvas.height !== processHeight) this.processingCanvas.height = processHeight;
                    
                    this.processingCtx.save();
                    if (config.mirrorCamera) {
                        this.processingCtx.scale(-1, 1);
                        this.processingCtx.translate(-processWidth, 0);
                    }
                    
                    this.processingCtx.clearRect(0, 0, processWidth, processHeight);
                    this.processingCtx.drawImage(this.video, 0, 0, processWidth, processHeight);
                    this.processingCtx.restore();
                    
                    const imageData = this.processingCtx.getImageData(0, 0, processWidth, processHeight);
                    if (!imageData || imageData.data.length === 0) {
                        console.warn('⚠️ No image data received from processing canvas');
                        return;
                    }
                    
                    // Perform band detection on current frame
                    this.currentBandDetectionResult = detectHaditInformationBand(imageData, config);
                    detectedBand = this.currentBandDetectionResult.band;
                    
                    // Generate band-focused depth with contrast enhancement
                    this.currentDepthResult = generateBandFocusedDepth(imageData, config, this.currentBandDetectionResult.band);
                    
                    // Generate stereo views using band-focused depth with contrast
                    this.generateHaditStereoViewsWithBandAndContrast(imageData, config, this.currentDepthResult);
                    
                    const processingTime = performance.now() - startTime;
                    if (config.debugMode) {
                        this.updateAnalysisPanelWithBandAndContrast(processingTime, config, processWidth, processHeight);
                    }
                    
                } catch (error) {
                    console.error('🚫 Frame processing error:', error);
                }
            }

            generateHaditStereoViewsWithBandAndContrast(imageData, config, depthResult) {
                const { width, height, data } = imageData;
                
                if (width === 0 || height === 0 || !data || data.length === 0) {
                    console.warn('⚠️ Invalid image data for Hadit processing');
                    return;
                }
                
                // Resize output canvases if necessary
                if (this.leftCanvas.width !== width) this.leftCanvas.width = width;
                if (this.leftCanvas.height !== height) this.leftCanvas.height = height;
                if (this.rightCanvas.width !== width) this.rightCanvas.width = width;
                if (this.rightCanvas.height !== height) this.rightCanvas.height = height;
                
                const depthDisplayWidth = config.showDepthMap ? Math.floor(width / 2) : width;
                const depthDisplayHeight = config.showDepthMap ? Math.floor(height / 2) : height;
                if (this.depthCanvas.width !== depthDisplayWidth) this.depthCanvas.width = depthDisplayWidth;
                if (this.depthCanvas.height !== depthDisplayHeight) this.depthCanvas.height = depthDisplayHeight;

                const leftImageData = this.leftCtx.createImageData(width, height);
                const rightImageData = this.rightCtx.createImageData(width, height);
                const depthImageData = config.showDepthMap ? this.depthCtx.createImageData(depthDisplayWidth, depthDisplayHeight) : null;
                
                const leftData = leftImageData.data;
                const rightData = rightImageData.data;
                const depthOutData = depthImageData ? depthImageData.data : null;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const depthIdx = y * width + x;
                        
                        // Get depth from band-focused depth result with contrast enhancement
                        const depthData = depthResult.depthBuffer[depthIdx];
                        const depth = depthData ? depthData.depth : 0.5;
                        const isInBand = depthData ? depthData.isInBand : false;
                        const bandCenteredness = depthData ? depthData.bandCenteredness : 0;
                        
                        // Calculate stereo displacement with enhanced contrast effect
                        const normalizedDepthDisplacement = (depth - 0.5) * 2;
                        const displacement = Math.round(normalizedDepthDisplacement * config.separation * config.depthIntensity);
                        
                        // Apply band visualization if enabled
                        let r = data[idx];
                        let g = data[idx + 1];
                        let b = data[idx + 2];
                        
                        if (config.showBandVisualization && isInBand) {
                            // Enhanced band visualization with contrast awareness
                            const contrastBoost = Math.floor(bandCenteredness * 30);
                            r = Math.min(255, r + contrastBoost);
                            g = Math.min(255, g + contrastBoost);
                            b = Math.max(0, b - Math.floor(contrastBoost * 0.5));
                        }
                        
                        if (config.enableStereo) {
                            // Left eye: sample from right-shifted position
                            const leftSampleX = Math.max(0, Math.min(width - 1, x + displacement));
                            const leftSampleIdx = (y * width + leftSampleX) * 4;
                            leftData[idx] = data[leftSampleIdx];
                            leftData[idx + 1] = data[leftSampleIdx + 1];
                            leftData[idx + 2] = data[leftSampleIdx + 2];
                            leftData[idx + 3] = 255;
                            
                            // Right eye: sample from left-shifted position
                            const rightSampleX = Math.max(0, Math.min(width - 1, x - displacement));
                            const rightSampleIdx = (y * width + rightSampleX) * 4;
                            rightData[idx] = data[rightSampleIdx];
                            rightData[idx + 1] = data[rightSampleIdx + 1];
                            rightData[idx + 2] = data[rightSampleIdx + 2];
                            rightData[idx + 3] = 255;
                        } else {
                            leftData[idx] = rightData[idx] = r;
                            leftData[idx + 1] = rightData[idx + 1] = g;
                            leftData[idx + 2] = rightData[idx + 2] = b;
                            leftData[idx + 3] = rightData[idx + 3] = 255;
                        }

                        if (config.showDepthMap && depthOutData) {
                            const dx = Math.floor(x * depthDisplayWidth / width);
                            const dy = Math.floor(y * depthDisplayHeight / height);
                            if (dx < depthDisplayWidth && dy < depthDisplayHeight) {
                                const depthIdx = (dy * depthDisplayWidth + dx) * 4;
                                let depthColor = Math.floor(depth * 255);
                                
                                // Enhanced depth visualization with contrast and band highlighting
                                if (config.showBandVisualization && isInBand) {
                                    const contrastFactor = 1.0 + (config.depthContrast - 1.0) * bandCenteredness;
                                    depthColor = Math.floor(Math.min(255, depthColor * contrastFactor));
                                    depthOutData[depthIdx] = Math.min(255, depthColor + Math.floor(bandCenteredness * 40));     // R (enhanced for band)
                                    depthOutData[depthIdx + 1] = depthColor;                                                     // G
                                    depthOutData[depthIdx + 2] = Math.max(0, depthColor - Math.floor(bandCenteredness * 20)); // B (reduced for band)
                                } else {
                                    depthOutData[depthIdx] = depthColor;     // R
                                    depthOutData[depthIdx + 1] = depthColor; // G
                                    depthOutData[depthIdx + 2] = depthColor; // B
                                }
                                depthOutData[depthIdx + 3] = 255;        // Alpha
                            }
                        }
                    }
                }
                
                this.leftCtx.putImageData(leftImageData, 0, 0);
                this.rightCtx.putImageData(rightImageData, 0, 0);
                if (config.showDepthMap && depthImageData) {
                    this.depthCtx.putImageData(depthImageData, 0, 0);
                } else if (!config.showDepthMap) {
                    this.depthCtx.fillStyle = '#000';
                    this.depthCtx.fillRect(0, 0, this.depthCanvas.width, this.depthCanvas.height);
                }
            }

            // Band control methods
            detectBand() {
                if (!this.isRunning) {
                    this.updateInfoPanel('Start camera first to detect bands.');
                    return;
                }
                this.updateInfoPanel('Manual band detection triggered - processing current frame...');
            }

            expandBandFull() {
                document.getElementById('bandDetectionMode').value = 'full_image';
                document.getElementById('bandSizeMultiplier').value = '10.0';
                this.updateControlValues();
                this.updateInfoPanel('Band expanded to full image coverage with 10x multiplier.');
            }

            resetBand() {
                document.getElementById('bandDetectionMode').value = 'auto_detect';
                document.getElementById('bandSizeMultiplier').value = '1.0';
                document.getElementById('focusFactor').value = '2.0';
                document.getElementById('depthContrast').value = '1.0';
                this.updateControlValues();
                this.updateInfoPanel('Band detection and depth contrast reset to defaults.');
            }
            
            // UI Update methods
            updateFpsDisplay(reset = false) {
                const fps = reset ? 0 : this.currentFps;
                document.getElementById('leftFps').textContent = `${fps} FPS`;
                document.getElementById('rightFps').textContent = `${fps} FPS`;
                document.getElementById('depthFps').textContent = `${fps} FPS`;
            }

            updateCameraStatus(message, statusClass) {
                const statusEl = document.getElementById('cameraStatus');
                statusEl.innerHTML = `<span class="status-${statusClass}">${message}</span>`;
            }

            showError(message) {
                const errorPanel = document.getElementById('errorPanel');
                const errorMessageDiv = document.getElementById('errorMessage');
                errorMessageDiv.textContent = message;
                errorPanel.style.display = 'block';
                console.error("Error Displayed:", message);
            }

            hideError() {
                document.getElementById('errorPanel').style.display = 'none';
            }
            
            updateInfoPanel(message) {
                const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
                document.getElementById('infoPanel').innerHTML = `<div>Status: ${message} | Angledcrystals | ${timestamp} UTC</div>`;
            }

            updateAnalysisInfo(message) {
                const analysisPanel = document.getElementById('analysisPanel');
                const div = document.createElement('div');
                div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                analysisPanel.appendChild(div);
                analysisPanel.scrollTop = analysisPanel.scrollHeight;
            }
            
            updateAnalysisPanelWithBandAndContrast(processingTime, config, processWidth, processHeight) {
                const panel = document.getElementById('analysisPanel');
                
                let bandInfo = 'No band detected';
                let depthInfo = 'No depth data';
                
                if (this.currentBandDetectionResult) {
                    const band = this.currentBandDetectionResult.band;
                    bandInfo = `Band: ${band.min.toFixed(2)}-${band.max.toFixed(2)} (${band.width.toFixed(2)} wide, ${(band.confidence*100).toFixed(1)}% conf)`;
                }
                
                if (this.currentDepthResult) {
                    const stats = this.currentDepthResult.stats;
                    depthInfo = `Depth: ${stats.minDepth.toFixed(3)}-${stats.maxDepth.toFixed(3)} (${(stats.bandCoverage*100).toFixed(1)}% in band)`;
                }
                
                panel.innerHTML = `
                    <div style="color: #88ff00; font-weight: bold;">⚡ Live Hadit Band Analysis with Depth Contrast</div>
                    <div>Processing Time: ${processingTime.toFixed(2)} ms</div>
                    <div>Resolution: ${processWidth}x${processHeight}</div>
                    <div>Band Mode: ${config.bandDetectionMode}</div>
                    <div>${bandInfo}</div>
                    <div>${depthInfo}</div>
                    <div>Hadit θ: ${config.haditTheta.toFixed(1)}°, φ: ${config.haditPhi.toFixed(1)}°</div>
                    <div>Band Size Multiplier: ${config.bandSizeMultiplier.toFixed(1)}x</div>
                    <div>Focus Factor: ${config.focusFactor.toFixed(1)}x, Depth Contrast: ${config.depthContrast.toFixed(1)}x</div>
                    <div>Focus Only Band: ${config.focusOnlyBand}</div>
                    <div>Influence: ${config.haditInfluence.toFixed(2)}, S Bounds: ±${config.sBounds.toFixed(1)}</div>
                    <div>Separation: ${config.separation}px, Depth Intensity: ${config.depthIntensity.toFixed(1)}x</div>
                    <div>Lum Weight: ${config.luminosityWeight.toFixed(2)}, Sat Weight: ${config.saturationWeight.toFixed(2)}</div>
                    <div>Quality: ${config.quality * 100}%, FPS: ${this.currentFps}</div>
                    <div>Options: Stereo=${config.enableStereo}, Mirror=${config.mirrorCamera}, Band Viz=${config.showBandVisualization}</div>
                `;
            }

            // Control initializations
            initializeControls() {
                // Camera controls
                document.getElementById('startCamera').addEventListener('click', () => this.startCamera());
                document.getElementById('switchCamera').addEventListener('click', () => this.switchCamera());
                document.getElementById('stopCamera').addEventListener('click', () => this.stopCamera());
                document.getElementById('requestPermissions').addEventListener('click', () => this.requestPermissions());
                document.getElementById('toggleDebugVideo').addEventListener('click', () => this.toggleDebugVideo());

                // Band controls
                document.getElementById('detectBand').addEventListener('click', () => this.detectBand());
                document.getElementById('expandBandFull').addEventListener('click', () => this.expandBandFull());
                document.getElementById('resetBand').addEventListener('click', () => this.resetBand());

                // Depth preset controls
                document.getElementById('setHighContrast').addEventListener('click', () => this.setHighContrast());
                document.getElementById('setLowContrast').addEventListener('click', () => this.setLowContrast());
                document.getElementById('setExtremeDepth').addEventListener('click', () => this.setExtremeDepth());
                document.getElementById('setSubtleDepth').addEventListener('click', () => this.setSubtleDepth());

                // Settings with live updates for labels
                const setupSliderWithValue = (sliderId, valueId, suffix = '', multiplier = 1, digits = 1) => {
                    const slider = document.getElementById(sliderId);
                    const valueLabel = document.getElementById(valueId);
                    const update = () => valueLabel.textContent = `${(parseFloat(slider.value) * multiplier).toFixed(digits)}${suffix}`;
                    slider.addEventListener('input', update);
                    update();
                };
                
                const setupDualInput = (rangeId, numberId, valueLabelId, suffix = '', digits = 1) => {
                    const rangeInput = document.getElementById(rangeId);
                    const numberInput = document.getElementById(numberId);
                    const valueLabel = document.getElementById(valueLabelId);

                    const updateFromRange = () => {
                        const val = parseFloat(rangeInput.value);
                        numberInput.value = val.toFixed(digits);
                        if (valueLabel) valueLabel.textContent = `${val.toFixed(digits)}${suffix}`;
                    };
                    const updateFromNumber = () => {
                        let val = parseFloat(numberInput.value);
                        val = Math.max(parseFloat(rangeInput.min), Math.min(parseFloat(rangeInput.max), val));
                        if (isNaN(val)) val = parseFloat(rangeInput.value);
                        rangeInput.value = val;
                        if (valueLabel) valueLabel.textContent = `${val.toFixed(digits)}${suffix}`;
                    };
                    rangeInput.addEventListener('input', updateFromRange);
                    numberInput.addEventListener('change', updateFromNumber);
                    numberInput.addEventListener('input', () => {
                        if (valueLabel) valueLabel.textContent = `${parseFloat(numberInput.value).toFixed(digits)}${suffix}`;
                    });
                    updateFromRange();
                };

                setupDualInput('haditTheta', 'haditThetaNumber', 'haditThetaValue', '°', 1);
                setupDualInput('haditPhi', 'haditPhiNumber', 'haditPhiValue', '°', 1);
                
                setupSliderWithValue('bandSizeMultiplier', 'bandSizeMultiplierValue', 'x', 1, 1);
                setupSliderWithValue('focusFactor', 'focusFactorValue', 'x', 1, 1);
                setupSliderWithValue('haditInfluence', 'haditInfluenceValue', '', 1, 2);
                setupSliderWithValue('separation', 'separationValue', 'px', 1, 0);
                setupSliderWithValue('depthIntensity', 'depthIntensityValue', 'x', 1, 1);
                setupSliderWithValue('depthContrast', 'depthContrastValue', 'x', 1, 1); // 🎨 NEW!
                setupSliderWithValue('sBounds', 'sBoundsValue', '', 1, 1);
                setupSliderWithValue('luminosityWeight', 'luminosityWeightValue', '', 1, 2);
                setupSliderWithValue('saturationWeight', 'saturationWeightValue', '', 1, 2);

                // Show raw feed checkbox
                document.getElementById('showRawFeed').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        if (this.debugVideo && this.debugVideo.style.display === 'none') this.toggleDebugVideo();
                    } else {
                        if (this.debugVideo && this.debugVideo.style.display !== 'none') this.toggleDebugVideo();
                    }
                });
                
                // Preset buttons
                document.getElementById('setHaditPole').addEventListener('click', () => this.setHaditValue('haditPhi', 0.1));
                document.getElementById('setHaditEquator').addEventListener('click', () => this.setHaditValue('haditPhi', 90));
                document.getElementById('setHaditNear180').addEventListener('click', () => this.setHaditValue('haditPhi', 179.9));
                document.getElementById('animateTheta').addEventListener('click', () => this.animateHadit('haditTheta', 360, 2));
                document.getElementById('animatePhi').addEventListener('click', () => this.animateHadit('haditPhi', 179.9, 1, true));
                document.getElementById('stopAnimation').addEventListener('click', () => this.stopHaditAnimation());
            }

            updateControlValues() {
                // Updates all value display labels
                const controls = [
                    { id: 'bandSizeMultiplier', suffix: 'x', precision: 1 },
                    { id: 'focusFactor', suffix: 'x', precision: 1 },
                    { id: 'haditTheta', suffix: '°', precision: 1 },
                    { id: 'haditPhi', suffix: '°', precision: 1 },
                    { id: 'haditInfluence', suffix: '', precision: 2 },
                    { id: 'separation', suffix: 'px' },
                    { id: 'depthIntensity', suffix: 'x', precision: 1 },
                    { id: 'depthContrast', suffix: 'x', precision: 1 }, // 🎨 NEW!
                    { id: 'sBounds', suffix: '', precision: 1 },
                    { id: 'luminosityWeight', suffix: '', precision: 2 },
                    { id: 'saturationWeight', suffix: '', precision: 2 }
                ];

                controls.forEach(({ id, suffix, precision }) => {
                    const element = document.getElementById(id);
                    const valueElement = document.getElementById(id + 'Value');
                    if (element && valueElement) {
                        const value = precision ? parseFloat(element.value).toFixed(precision) : element.value;
                        valueElement.textContent = `${value}${suffix}`;
                    }
                });
            }
            
            setHaditValue(param, value) {
                const rangeInput = document.getElementById(param);
                const numberInput = document.getElementById(param + 'Number');
                const valueLabel = document.getElementById(param + 'Value');
                
                if (rangeInput) rangeInput.value = value;
                if (numberInput) numberInput.value = value.toFixed(1);
                if (valueLabel) valueLabel.textContent = `${value.toFixed(1)}°`;
            }

            animateHadit(param, range, speed, pingPong = false) {
                this.stopHaditAnimation();
                
                const input = document.getElementById(param);
                const numberInput = document.getElementById(param + 'Number');
                const valueLabel = document.getElementById(param + 'Value');
                
                let currentValue = parseFloat(input.value);
                const min = parseFloat(input.min);
                const max = parseFloat(input.max);
                let direction = 1;
                let lastTime = performance.now();

                const step = (currentTime) => {
                    const deltaTime = (currentTime - lastTime) / 1000;
                    lastTime = currentTime;

                    currentValue += direction * speed * deltaTime;

                    if (pingPong) {
                        if (currentValue >= max) { currentValue = max; direction = -1; }
                        if (currentValue <= min) { currentValue = min; direction = 1; }
                    } else {
                        if (currentValue > max) currentValue = min;
                        if (currentValue < min) currentValue = max;
                    }
                    
                    input.value = currentValue.toFixed(1);
                    if (numberInput) numberInput.value = currentValue.toFixed(1);
                    if (valueLabel) valueLabel.textContent = `${currentValue.toFixed(1)}°`;

                    this.animationId = requestAnimationFrame(step);
                };
                this.animationId = requestAnimationFrame(step);
            }

            stopHaditAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }
        }

        // Initialize the complete camera system when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('⚡ Initializing Complete Live Hadit Camera System with Depth Contrast...');
            console.log('Current Date and Time (UTC): 2025-06-07 08:07:29');
            console.log('Current User Login: Angledcrystals');
            console.log('🎨 Depth Contrast control: 0.1x to 3.0x enhancement');
            console.log('🎯 Full band detection and processing system enabled');
            
            window.haditCamera = new LiveHaditCamera();
            
            console.log('✅ Complete Live Hadit Camera system with Depth Contrast ready!');
            console.log('📹 Click "Start Camera" to begin live band processing');
            console.log('🎛️ All band detection modes: Auto, Content, Gradient, Statistical, Manual, Full Image');
            console.log('🎨 Depth presets: High Contrast, Low Contrast, Extreme Depth, Subtle Depth');
        });
    </script>
</body>
</html>
