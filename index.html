<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>AndroidVR - Hadit S-Coordinate Depth Detection</title>
    <style>
        /* All your existing styles unchanged */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }

        /* Canvas container takes all available space */
        .container {
            flex: 1;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            width: 100vw;
            perspective: 1000px;
            overflow: hidden;
            padding-top: 10px; /* Space from top */
            position: relative; /* For absolute positioning in flicker mode */
        }

        /* Canvas will maintain camera aspect ratio */
        canvas {
            border: 2px solid white;
            border-radius: 10px;
            transform-origin: center;
            transition: transform 0.2s ease;
            margin: 0 4px;
            height: auto; /* Auto height based on container */
            position: relative; /* For flicker mode */
            will-change: transform, left, right; /* Hint for GPU acceleration */
        }

        /* Hardware acceleration hints */
        canvas, video {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
            will-change: transform;
        }

        /* Prevent unnecessary repaints */
        body, .container, .control-panel {
            will-change: transform;
        }

        /* Control panel at the bottom */
        .control-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            padding: 5px 5px;
            z-index: 1000;
        }

        /* Control rows */
        .control-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 3px; /* Reduced margin */
        }

        /* Control sections */
        .control-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 5px;
        }

        /* Control section headers */
        .section-header {
            font-size: 0.7rem; /* Smaller font */
            text-transform: uppercase;
            margin-bottom: 1px;
            color: #ccc;
        }

        /* Control elements */
        .control-item {
            display: flex;
            align-items: center;
            margin: 1px 0; /* Reduced margin */
        }

        label {
            font-size: 0.7rem; /* Smaller font */
            margin-right: 5px;
            min-width: 45px;
        }

        input[type="range"] {
            width: 70px;
            height: 12px; /* Thinner sliders */
        }

        select {
            width: 70px;
            font-size: 0.7rem;
            background: #333;
            color: white;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 1px;
        }

        button {
            margin: 2px; /* Reduced margin */
            padding: 5px 8px; /* Smaller padding */
            font-size: 0.75rem; /* Smaller font */
            border: none;
            border-radius: 5px;
            background-color: #444;
            color: white;
            cursor: pointer;
        }

        button:hover {
            background-color: #666;
        }

        .divider {
            width: 1px;
            height: 35px; /* Shorter divider */
            background-color: #444;
            margin: 0 2px;
        }

        /* Top controls container */
        .top-controls {
            position: fixed;
            top: 5px;
            right: 5px;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Toggle button to hide/show controls - REPOSITIONED */
        #toggleControls {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #333;
        }

        #toggleControls:hover {
            opacity: 1;
        }

        /* Quality selector */
        #qualitySelect {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 5px;
        }

        #qualitySelect:hover {
            opacity: 1;
        }

        /* Quality indicator */
        #qualityIndicator {
            position: fixed;
            top: 40px;
            right: 5px;
            font-size: 0.65rem;
            color: #aaa;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Flicker indicator */
        #flickerIndicator {
            position: fixed;
            top: 70px;
            right: 5px;
            font-size: 0.65rem;
            color: #f55;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Hadit indicator */
        #haditIndicator {
            position: fixed;
            top: 100px;
            right: 5px;
            font-size: 0.65rem;
            color: #ff00ff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 1;
            transition: opacity 0.3s;
        }

        /* Debug output */
        #debugOutput {
            position: fixed;
            top: 5px;
            left: 5px;
            font-size: 0.65rem;
            color: #aaa;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            max-width: 50%;
            max-height: 200px;
            overflow: auto;
        }

        /* Value display spans */
        .value-display {
            font-size: 0.6rem;
            color: #aaa;
            margin-left: 5px;
            min-width: 30px;
        }

        /* Hadit controls */
        .hadit-control {
            background-color: #2a0a2a !important;
            border: 1px solid #ff00ff !important;
        }

        /* Depth map display */
        #depthMapDisplay {
            position: fixed;
            top: 150px;
            left: 5px;
            width: 200px;
            height: 133px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            z-index: 1002;
            opacity: 0.9;
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
        }

        #depthMapDisplay canvas {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 3px;
        }

        #depthMapLabel {
            position: absolute;
            top: -20px;
            left: 0;
            font-size: 0.6rem;
            color: #00ff00;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1px 5px;
            border-radius: 3px;
        }

        /* Toggle depth map button */
        #toggleDepthMap {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #003300;
            border: 1px solid #00ff00;
            color: #00ff00;
            border-radius: 5px;
        }

        #toggleDepthMap:hover {
            opacity: 1;
            background-color: #005500;
        }

        #toggleDepthMap.active {
            background-color: #007700;
            opacity: 1;
        }

        /* Portrait mode warning */
        @media (orientation: portrait) {
            body::before {
                content: "Please rotate your device to landscape mode.";
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-size: 1.5rem;
                text-align: center;
                z-index: 1000;
            }

            .container, .control-panel, .top-controls, #qualityIndicator {
                display: none;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            button {
                padding: 3px 6px;
                font-size: 0.65rem;
            }
            
            input[type="range"] {
                width: 60px;
            }
            
            label {
                font-size: 0.65rem;
                min-width: 40px;
            }
        }

        /* Firefox-specific CSS fixes */
        @-moz-document url-prefix() {
            video {
                transform-origin: center center;
                will-change: transform;
            }
            
            canvas {
                transform-origin: center center;
                will-change: transform;
            }
        }
        
        /* Flicker mode specific styles - for position swapping */
        .flicker-active .container {
            position: relative;
        }
        
        .flicker-active canvas {
            position: absolute;
            transition: none; /* Disable transitions for flicker mode */
        }
        
        .canvas-left {
            left: calc(25% - 50px);
        }
        
        .canvas-right {
            left: calc(75% - 50px);
        }
        
        /* Frozen frame styles */
        .frozen-canvas {
            border-color: #ff4040 !important;
            box-shadow: 0 0 10px rgba(255, 64, 64, 0.7);
        }

        /* Recording Controls */
        .recording-controls {
            display: flex;
            align-items: center;
            margin-right: 5px;
        }

        .record-button {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: #333;
            border: none;
            color: white;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .record-button:hover {
            opacity: 1;
            background-color: #444;
        }

        .record-icon {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ff4040;
            display: inline-block;
        }

        .stop-icon {
            width: 10px;
            height: 10px;
            background-color: white;
            display: inline-block;
        }

        .stop-record {
            background-color: #c00;
        }

        .stop-record:hover {
            background-color: #e00;
        }

        .recording-indicator {
            display: flex;
            align-items: center;
            margin-left: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ff4040;
            margin-right: 5px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.8);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(0.8);
                opacity: 0.8;
            }
        }

        #recordingTimer {
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas1"></canvas>
        <canvas id="canvas2"></canvas>
        <!-- Freeze countdown display -->
        <div id="freezeCountdown" style="display: none; position: absolute; background-color: rgba(255, 0, 0, 0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 1.2rem; font-weight: bold; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1003;">
            Freezing in <span id="countdownValue">3</span>
        </div>
    </div>
    
    <!-- Depth Map Display -->
    <div id="depthMapDisplay">
        <div id="depthMapLabel">Hadit Depth Map</div>
        <canvas id="depthMapCanvas"></canvas>
    </div>
    
    <div class="top-controls">
        <div class="recording-controls">
            <button id="recordButton" class="record-button">
                <span class="record-icon"></span> Record
            </button>
            <button id="stopRecordButton" class="record-button stop-record" style="display:none">
                <span class="stop-icon"></span> Stop
            </button>
            <div id="recordingIndicator" class="recording-indicator" style="display:none">
                <span class="pulse-dot"></span>
                <span id="recordingTimer">00:00</span>
            </div>
        </div>
        <button id="toggleDepthMap">Show Depth</button>
        <select id="qualitySelect">
            <option value="1.0">High Quality</option>
            <option value="0.5" selected>Medium Quality</option>
            <option value="0.25">Low Quality</option>
            <option value="0.1">Very Low Quality</option>
        </select>
        <button id="toggleControls">Hide Controls</button>
    </div>
    
    <div id="qualityIndicator">Processing at 50% resolution</div>
    <div id="flickerIndicator">3D Flicker Mode Active</div>
    <div id="haditIndicator">Hadit: φ=0.1° θ=0.0° Focus=4.3x</div>
    <div id="debugOutput" style="display: none;"></div>
    
    <div class="control-panel" id="controlPanel">
        <div class="control-row">
            <div class="control-section">
                <div class="section-header">Camera</div>
                <div class="control-item">
                    <button id="startButton">Start Camera</button>
                    <button id="switchButton">Switch Camera</button>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">View</div>
                <div class="control-item">
                    <label for="tiltSlider">Tilt</label>
                    <input id="tiltSlider" type="range" min="0" max="0.7" step="0.01" value="0">
                </div>
                <div class="control-item">
                    <label for="sizeSlider">Size</label>
                    <input id="sizeSlider" type="range" min="0.2" max="1.8" step="0.05" value="1.0">
                </div>
                <div class="control-item">
                    <button id="toggleFlickerMode">Enable 3D Flicker</button>
                </div>
                <div class="control-item" id="flickerSpeedContainer" style="display: none;">
                    <label for="flickerSpeedSlider">Speed</label>
                    <input id="flickerSpeedSlider" type="range" min="8" max="60" step="1" value="16">
                </div>
                <div class="control-item">
                    <label for="freezeDelayToggle">Freeze Delay</label>
                    <input id="freezeDelayToggle" type="checkbox">
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">⚡ Hadit S-Coordinate Depth</div>
                <div class="control-item">
                    <label for="haditTheta">θ (Theta)</label>
                    <input id="haditTheta" type="range" min="0" max="360" step="0.1" value="0.0" class="hadit-control">
                    <span id="haditThetaValue" class="value-display">0.0°</span>
                </div>
                <div class="control-item">
                    <label for="haditPhi">φ (Phi)</label>
                    <input id="haditPhi" type="range" min="0.1" max="179.9" step="0.1" value="0.1" class="hadit-control">
                    <span id="haditPhiValue" class="value-display">0.1°</span>
                </div>
                <div class="control-item">
                    <label for="haditInfluence">Influence</label>
                    <input id="haditInfluence" type="range" min="0" max="2" step="0.1" value="1.0" class="hadit-control">
                    <span id="haditInfluenceValue" class="value-display">1.0</span>
                </div>
                <div class="control-item">
                    <label for="focusFactor">Focus</label>
                    <input id="focusFactor" type="range" min="1.0" max="10.0" step="0.1" value="4.3" class="hadit-control">
                    <span id="focusFactorValue" class="value-display">4.3x</span>
                </div>
                <div class="control-item">
                    <label for="bandSizeMultiplier">Band Size</label>
                    <input id="bandSizeMultiplier" type="range" min="0.1" max="5.0" step="0.1" value="1.0" class="hadit-control">
                    <span id="bandSizeMultiplierValue" class="value-display">1.0x</span>
                </div>
                <div class="control-item">
                    <label for="bandMode">Band Mode</label>
                    <select id="bandMode" class="hadit-control">
                        <option value="full_image" selected>Full Image</option>
                        <option value="auto_detect">Auto Detect</option>
                        <option value="content_analysis">Content Analysis</option>
                        <option value="manual_range">Manual Range</option>
                    </select>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Enhanced Nuit Depth</div>
                <div class="control-item">
                    <label for="depthMode">Mode</label>
                    <select id="depthMode">
                        <option value="hadit_scoord" selected>Hadit S-Coord</option>
                        <option value="nuit">Nuit Only</option>
                        <option value="radial">Radial Zones</option>
                        <option value="hybrid">Hybrid</option>
                        <option value="sum_xy">Sum XY S-Coords</option>
                        <option value="vectorfield">Vector Field</option>
                    </select>
                </div>
                <div class="control-item">
                    <label for="nuitRadius">Nuit Radius</label>
                    <input id="nuitRadius" type="range" min="0.5" max="15.0" step="0.1" value="7.0">
                    <span id="nuitRadiusValue" class="value-display">7.0</span>
                </div>
                <div class="control-item">
                    <label for="sBounds">S Bounds</label>
                    <input id="sBounds" type="range" min="1.0" max="50.0" step="0.1" value="20.0">
                    <span id="sBoundsValue" class="value-display">±20.0</span>
                </div>
                <div class="control-item">
                    <label for="depthIntensity">Intensity</label>
                    <input id="depthIntensity" type="range" min="0" max="50" step="1" value="15">
                </div>
                <div class="control-item">
                    <label for="baselineSeparation">Eye Sep</label>
                    <input id="baselineSeparation" type="range" min="0.5" max="8.0" step="0.1" value="3.0">
                    <span id="baselineSeparationValue" class="value-display">3.0%</span>
                </div>
                <div class="control-item">
                    <label for="blurRadius">Blur</label>
                    <input id="blurRadius" type="range" min="0" max="10" step="1" value="1">
                </div>
                <div class="control-item">
                    <label for="nuitFalloffFactor">Falloff</label>
                    <input id="nuitFalloffFactor" type="range" min="1" max="20" step="0.5" value="5.0">
                </div>
                <div class="control-item">
                    <label for="depthQuantize">Quantize</label>
                    <input id="depthQuantizeToggle" type="checkbox">
                </div>
                <div class="control-item">
                    <label for="depthLevels">Levels</label>
                    <input id="depthLevels" type="range" min="2" max="16" step="1" value="8">
                </div>
            </div>
        </div>
        
        <div class="control-row">
            <div class="control-section">
                <div class="section-header">S-Coordinate Mapping</div>
                <div class="control-item">
                    <label for="luminosityWeight">Luminosity</label>
                    <input id="luminosityWeight" type="range" min="0" max="1" step="0.05" value="0.0">
                    <span id="luminosityWeightValue" class="value-display">0.0</span>
                </div>
                <div class="control-item">
                    <label for="saturationWeight">Saturation</label>
                    <input id="saturationWeight" type="range" min="0" max="1" step="0.05" value="0.0">
                    <span id="saturationWeightValue" class="value-display">0.0</span>
                </div>
                <div class="control-item">
                    <label for="depthContrast">Contrast</label>
                    <input id="depthContrast" type="range" min="0.1" max="3.0" step="0.1" value="0.1">
                    <span id="depthContrastValue" class="value-display">0.1x</span>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Left Color</div>
                <div class="control-item">
                    <label for="redSlider1">Red</label>
                    <input id="redSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="greenSlider1">Green</label>
                    <input id="greenSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="blueSlider1">Blue</label>
                    <input id="blueSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Right Color</div>
                <div class="control-item">
                    <label for="redSlider2">Red</label>
                    <input id="redSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="greenSlider2">Green</label>
                    <input id="greenSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="blueSlider2">Blue</label>
                    <input id="blueSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Current Date and Time (UTC - YYYY-MM-DD HH:MM:SS formatted): 2025-06-07 02:25:16
        // Current User's Login: Angledcrystals

        // ==================== HADIT MATHEMATICS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            // Handle edge cases for phi
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function calculateHaditSCoordinate(px, py, width, height, lum, sat, haditTheta, haditPhi, haditInfluence, lumMapWeight, satMapWeight) {
            // Convert pixel to spherical coordinates
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            // Apply Hadit transformation
            const hadit_3d = sphericalToCartesian(haditTheta, haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            // Apply content modulation (if enabled)
            const contentModulation = (1 + lum * lumMapWeight + sat * satMapWeight);
            
            const S_modulated = {
                x: S_hadit.x * contentModulation * haditInfluence,
                y: S_hadit.y * contentModulation * haditInfluence
            };
            
            const sMagnitude = Math.sqrt(S_modulated.x * S_modulated.x + S_modulated.y * S_modulated.y);
            
            return {
                sCoord: S_modulated,
                sMagnitude: sMagnitude,
                originalG: G_3d,
                reflectedG: G_reflected,
                haditVector: hadit_3d,
                contentModulation: contentModulation,
                luminance: lum,
                saturation: sat
            };
        }

        function detectHaditInformationBand(imageData, config) {
            const { width, height, data } = imageData;
            const bandMode = config.bandMode || 'full_image';
            const bandSizeMultiplier = config.bandSizeMultiplier || 1.0;
            
            if (bandMode === 'full_image') {
                const bandWidth = config.sBounds * 10 * bandSizeMultiplier;
                return {
                    min: 0,
                    max: bandWidth,
                    center: bandWidth / 2,
                    width: bandWidth,
                    confidence: 1.0
                };
            }
            
            // For other modes, implement detection with band size multiplier
            const sMagnitudeHistogram = new Array(100).fill(0);
            const maxSMagnitude = config.sBounds * 2;
            
            // Sample pixels for band detection
            const sampleStep = Math.max(1, Math.floor(Math.min(width, height) / 50));
            
            for (let y = 0; y < height; y += sampleStep) {
                for (let x = 0; x < width; x += sampleStep) {
                    const pixelIdx = (y * width + x) * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const result = calculateHaditSCoordinate(x, y, width, height, lum, sat, 
                        config.haditTheta, config.haditPhi, config.haditInfluence, 
                        config.luminosityWeight, config.saturationWeight);
                    
                    const binIndex = Math.floor((result.sMagnitude / maxSMagnitude) * (sMagnitudeHistogram.length - 1));
                    if (binIndex >= 0 && binIndex < sMagnitudeHistogram.length) {
                        sMagnitudeHistogram[binIndex]++;
                    }
                }
            }
            
            // Find peak in histogram for auto detection
            let maxBin = 0;
            let maxCount = 0;
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                if (sMagnitudeHistogram[i] > maxCount) {
                    maxCount = sMagnitudeHistogram[i];
                    maxBin = i;
                }
            }
            
            const centerS = (maxBin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const baseBandWidth = maxSMagnitude * 0.3; // Base 30% of range
            const bandWidth = baseBandWidth * bandSizeMultiplier; // Apply multiplier
            
            return {
                min: Math.max(0, centerS - bandWidth / 2),
                max: centerS + bandWidth / 2,
                center: centerS,
                width: bandWidth,
                confidence: maxCount / (width * height / (sampleStep * sampleStep))
            };
        }

        function calculateHaditDepth(sResult, detectedBand, focusFactor, depthContrast) {
            const { sMagnitude } = sResult;
            
            // Check if pixel is in detected band
            const isInBand = sMagnitude >= detectedBand.min && sMagnitude <= detectedBand.max;
            
            let depth;
            
            if (detectedBand.width > 0) {
                // Band-relative depth calculation
                const bandPosition = Math.max(0, Math.min(1, (sMagnitude - detectedBand.min) / detectedBand.width));
                depth = 0.2 + bandPosition * 0.8; // Range: 0.2 to 1.0
            } else {
                // Fallback: magnitude-based depth
                const maxS = currentSBounds * 2;
                depth = 0.2 + Math.min(1.0, sMagnitude / maxS) * 0.8;
            }
            
            // Apply focus factor for in-band pixels
            if (isInBand && focusFactor > 1.0) {
                depth = 0.5 + (depth - 0.5) * focusFactor;
            }
            
            // Apply depth contrast
            depth = Math.pow(Math.max(0.01, depth), 1.0 / depthContrast);
            
            return {
                depth: Math.min(1.0, Math.max(0.01, depth)),
                isInBand: isInBand,
                sMagnitude: sMagnitude,
                sCoord: sResult.sCoord
            };
        }

        // Utility function for debugging
        function debugLog(message) {
            console.log(message);
            const debugOutput = document.getElementById('debugOutput');
            if (debugOutput && debugOutput.style.display !== 'none') {
                debugOutput.innerHTML += message + '<br>';
                debugOutput.scrollTop = debugOutput.scrollHeight;
            }
        }

        // Browser detection
        const isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isMobile = isAndroid || isIOS;
        
        // Log useful browser information
        debugLog("Hadit AndroidVR - Current Date and Time (UTC): 2025-06-07 02:25:16");
        debugLog("Current User Login: Angledcrystals");
        debugLog("Browser Detection:");
        debugLog("- Firefox: " + isFirefox);
        debugLog("- Android: " + isAndroid);
        debugLog("- iOS: " + isIOS);
        debugLog("- Mobile: " + isMobile);
        debugLog("- User Agent: " + navigator.userAgent);
        
        // Add a GPU acceleration hint specific for Android WebView
        if (isAndroid) {
            const meta = document.createElement('meta');
            meta.name = 'viewport';
            meta.content = 'width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, viewport-fit=cover, minimal-ui';
            document.getElementsByTagName('head')[0].appendChild(meta);
        }

        // App state variables
        let currentStream = null;
        let video = null;
        let useFrontCamera = false;
        let controlsHidden = false;
        let qualityFactor = 0.5; // Default medium quality
        let lastFrameTime = 0;
        const targetFPS = 30;
        const frameInterval = 1000 / targetFPS;
        
        // Depth map display state
        let depthMapVisible = false;
        let latestDepthMap = null;
        
        // Hadit configuration with your specified values
        let haditConfig = {
            haditTheta: 0.0,
            haditPhi: 0.1,
            haditInfluence: 1.0,
            focusFactor: 4.3,
            bandMode: 'full_image',
            bandSizeMultiplier: 1.0, // NEW: Band size multiplier
            luminosityWeight: 0.0,
            saturationWeight: 0.0,
            depthContrast: 0.1,
            sBounds: 20.0
        };
        
        // Dynamic Nuit Distance Method Parameters
        let currentNuitRadius = 7.0;
        let currentSBounds = 20.0; // Updated to match your settings
        
        // Vector Field globals
        let vectorFieldTime = 0;
        let lastUpdateTime = 0;
        
        // Improved camera tracking
        let detectedCameras = {
            front: null,
            back: null,
            current: null,
            all: []
        };
        
        // Window size variables
        let canvasSizeFactor = 1.0; // Default canvas size factor
        
        // Variables for flicker mode
        let flickerMode = false;
        let flickerFrame = 0; // 0 = normal, 1 = swapped
        let flickerInterval = null;
        let flickerSpeed = 16; // milliseconds (about 60fps)
        let originalCanvasPositions = {
            canvas1: { left: 0, margin: 0, transform: '' },
            canvas2: { left: 0, margin: 0, transform: '' }
        };
        
        // Method indicator - we'll determine the right method based on device capabilities
        let renderMethod = 'canvas2d'; // Start with standard canvas, will try to upgrade to WebGL
        
        // Canvas setup
        let processingCanvas = document.createElement('canvas');
        let processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });
        let depthMapCanvas = document.createElement('canvas');
        let depthMapCtx = depthMapCanvas.getContext('2d', { willReadFrequently: true });
        
        // Try to use OffscreenCanvas for better performance if available
        if (typeof OffscreenCanvas !== 'undefined') {
            try {
                processingCanvas = new OffscreenCanvas(1, 1);
                processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });
                depthMapCanvas = new OffscreenCanvas(1, 1);
                depthMapCtx = depthMapCanvas.getContext('2d', { willReadFrequently: true });
                debugLog("Using OffscreenCanvas for better performance");
            } catch (e) {
                debugLog("OffscreenCanvas failed: " + e.message);
                // Fall back to regular canvas (already defined)
            }
        }
        
        // Freeze functionality
        let freezeCountdownActive = false;
        let freezeCountdownTimer = null;
        let frozenFrameData = null;
        let isFrozen = false;

        // S-coordinate mapping functions from Python script (with dynamic parameters)
        function pixelToSCoordinate(px, py, width, height, lum, sat, lumMapWeight, satMapWeight) {
            // Normalize pixel coordinates to -1 to 1 range, centered
            const normX = (px / (width - 1)) * 2 - 1;
            const normY = (py / (height - 1)) * 2 - 1;
            
            // Base S-coordinate range using current S_BOUNDS
            const sMinX = -currentSBounds;
            const sMaxX = currentSBounds;
            const sMinY = -currentSBounds;
            const sMaxY = currentSBounds;
            
            // Apply color mediation to influence the S-coordinate mapping
            const effectiveSMaxX = sMaxX * (1 + lum * lumMapWeight + sat * satMapWeight);
            const effectiveSMinX = sMinX * (1 + lum * lumMapWeight + sat * satMapWeight);
            const effectiveSMaxY = sMaxY * (1 + lum * lumMapWeight + sat * satMapWeight);
            const effectiveSMinY = sMinY * (1 + lum * lumMapWeight + sat * satMapWeight);
            
            const sX = (normX + 1) / 2 * (effectiveSMaxX - effectiveSMinX) + effectiveSMinX;
            const sY = (normY + 1) / 2 * (effectiveSMaxY - effectiveSMinY) + effectiveSMinY;
            
            // Clip to reasonable bounds
            const clipVal = currentSBounds * 5;
            return {
                x: Math.max(-clipVal, Math.min(clipVal, sX)),
                y: Math.max(-clipVal, Math.min(clipVal, sY))
            };
        }
        
        // Enhanced Nuit distance depth calculation with multiple modes and better depth distribution
        function calculateNuitDistanceDepth(sCoord, nuitRadius, falloffFactor) {
            const distanceFromOrigin = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
            const distanceFromNuit = Math.abs(distanceFromOrigin - nuitRadius);
            
            // Get depth mode from selector
            const depthMode = document.getElementById('depthMode').value;
            
            let finalDepth;
            
            switch (depthMode) {
                case 'hadit_scoord':
                    // NEW: Hadit S-coordinate depth calculation
                    return calculateHaditSCoordinateDepth(sCoord);
                    
                case 'nuit':
                    // Original Nuit distance method - max depth at boundary
                    const baseDepth = 1.0 / (1.0 + distanceFromNuit * falloffFactor);
                    const contrastedDepth = Math.pow(baseDepth, 0.7);
                    const minDepth = 0.1;
                    finalDepth = minDepth + (contrastedDepth * (1.0 - minDepth));
                    break;
                    
                case 'radial':
                    // Radial depth - center is closest, edges are farthest
                    const maxDistance = Math.max(currentSBounds * 2, 10);
                    const normalizedDistance = Math.min(distanceFromOrigin / maxDistance, 1.0);
                    // Invert so center (distance 0) = max depth (1.0), edges = min depth
                    finalDepth = 1.0 - (normalizedDistance * 1.0); // Range: 1.0 to 0.2
                    break;
                    
                case 'hybrid':
                    // Combination: radial base + Nuit boundary enhancement
                    const maxDist = Math.max(currentSBounds * 2, 10);
                    const normDist = Math.min(distanceFromOrigin / maxDist, 1.0);
                    const radialDepth = 1.0 - (normDist * 0.7); // Base radial depth
                    
                    // Add Nuit boundary enhancement
                    const nuitDepth = 1.0 / (1.0 + distanceFromNuit * falloffFactor * 0.5);
                    const nuitBoost = (nuitDepth - 0.5) * 0.3; // Boost around boundary
                    
                    finalDepth = radialDepth + nuitBoost;
                    break;
                    
                case 'sum_xy':
                    // Sum XY S-coordinates method - depth based on sum of absolute S-coordinate values
                    const sumXY = Math.abs(sCoord.x) + Math.abs(sCoord.y);
                    const maxSum = currentSBounds * 2; // Maximum possible sum
                    const normalizedSum = Math.min(sumXY / maxSum, 1.0);
                    
                    // Invert so that higher sums (edges/corners) = closer, lower sums (center) = farther
                    finalDepth = 0.2 + (normalizedSum * 0.8); // Range: 0.2 to 1.0
                    break;
                
                case 'vectorfield':
                    // Vector field depth calculation
                    finalDepth = calculateVectorFieldDepth(sCoord);
                    break;
                    
                default:
                    finalDepth = 0.5;
            }
            
            // Apply contrast enhancement
            const contrastedDepth = Math.pow(Math.max(0, finalDepth), 0.7);
            
            // Ensure reasonable bounds
            return Math.min(1.0, Math.max(0.05, contrastedDepth));
        }

        // NEW: Hadit S-coordinate depth calculation function
        function calculateHaditSCoordinateDepth(sCoord) {
            // This function uses the live camera frame to calculate Hadit-based depth
            if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
                return 0.5; // Default depth if no video
            }
            
            // Get current frame from video
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = Math.floor(video.videoWidth * qualityFactor);
            tempCanvas.height = Math.floor(video.videoHeight * qualityFactor);
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
            
            try {
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                
                // Map S-coordinate back to pixel position (approximate)
                const centerX = tempCanvas.width / 2;
                const centerY = tempCanvas.height / 2;
                const px = Math.floor(centerX + (sCoord.x / currentSBounds) * centerX);
                const py = Math.floor(centerY + (sCoord.y / currentSBounds) * centerY);
                
                // Clamp to image bounds
                const clampedPx = Math.max(0, Math.min(tempCanvas.width - 1, px));
                const clampedPy = Math.max(0, Math.min(tempCanvas.height - 1, py));
                
                const pixelIdx = (clampedPy * tempCanvas.width + clampedPx) * 4;
                
                const r = imageData.data[pixelIdx] / 255;
                const g = imageData.data[pixelIdx + 1] / 255;
                const b = imageData.data[pixelIdx + 2] / 255;
                
                const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                const maxCol = Math.max(r, g, b);
                const minCol = Math.min(r, g, b);
                const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                
                // Calculate Hadit S-coordinate for this pixel
                const haditResult = calculateHaditSCoordinate(
                    clampedPx, clampedPy, tempCanvas.width, tempCanvas.height,
                    lum, sat,
                    haditConfig.haditTheta, haditConfig.haditPhi, haditConfig.haditInfluence,
                    haditConfig.luminosityWeight, haditConfig.saturationWeight
                );
                
                // Detect band for this frame
                const detectedBand = detectHaditInformationBand(imageData, haditConfig);
                
                // Calculate depth based on Hadit result
                const depthResult = calculateHaditDepth(haditResult, detectedBand, 
                    haditConfig.focusFactor, haditConfig.depthContrast);
                
                return depthResult.depth;
                
            } catch (e) {
                debugLog("Hadit depth calculation error: " + e.message);
                return 0.5; // Fallback depth
            }
        }
        
        /**
         * Calculate depth based on vector field in S-coordinate space
         */
        function calculateVectorFieldDepth(sCoord) {
            // The pattern type - can be hardcoded or added as a UI option later
            const patternType = 'waves';  // Options: 'waves', 'spiral', 'vortex', 'checkerboard'
            
            // Get vector field from pattern
            const vector = getVectorFieldPattern(sCoord, patternType, vectorFieldTime);
            
            // Calculate magnitude of the vector field
            const fieldMagnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
            
            // Normalize to 0-1 range
            let depthValue = fieldMagnitude % 1.0;
            if (depthValue < 0) depthValue += 1.0;
            
            // Ensure minimum depth for better stereo effect
            return 0.1 + (depthValue * 0.9);
        }

        // Creates different vector field patterns
        function getVectorFieldPattern(sCoord, patternType, time) {
            switch (patternType) {
                case 'waves':
                    return {
                        x: Math.sin(sCoord.x * 0.5 + time) * Math.cos(sCoord.y * 0.3),
                        y: Math.cos(sCoord.x * 0.4) * Math.sin(sCoord.y * 0.6 + time)
                    };
                    
                case 'spiral':
                    const angle = Math.atan2(sCoord.y, sCoord.x) + time;
                    const radius = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                    return {
                        x: Math.cos(angle + radius * 0.5),
                        y: Math.sin(angle + radius * 0.5)
                    };
                    
                case 'vortex':
                    const dx = sCoord.x;
                    const dy = sCoord.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) + 0.0001;
                    return {
                        x: -dy / dist + Math.sin(time),
                        y: dx / dist + Math.cos(time)
                    };
                    
                case 'checkerboard':
                    const gridSize = 0.5;
                    const xGrid = Math.floor((sCoord.x + time) / gridSize) % 2;
                    const yGrid = Math.floor(sCoord.y / gridSize) % 2;
                    return {
                        x: xGrid === 0 ? 0.5 : 1.5,
                        y: yGrid === 0 ? 0.5 : 1.5
                    };
                    
                default:
                    return {
                        x: Math.sin(sCoord.x * 0.5 + time),
                        y: Math.cos(sCoord.y * 0.6 + time)
                    };
            }
        }
        
        // Test function to create a simple test depth map
        function createTestDepthMap(width, height) {
            const testDepthData = new Uint8ClampedArray(width * height * 4);
            
            // Create a simple gradient: left side = far (dark), right side = close (bright)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Simple left-to-right gradient
                    const depth = Math.floor((x / width) * 255);
                    
                    testDepthData[idx] = depth;     // R
                    testDepthData[idx + 1] = depth; // G
                    testDepthData[idx + 2] = depth; // B
                    testDepthData[idx + 3] = 255;   // A
                }
            }
            
            return testDepthData;
        }
        
        // NEW: Enhanced depth map display function
        function updateDepthMapDisplay(depthMap, width, height) {
            if (!depthMapVisible || !depthMap) return;
            
            const depthMapCanvas = document.getElementById('depthMapCanvas');
            const depthMapCtx = depthMapCanvas.getContext('2d');
            
            // Set canvas size
            depthMapCanvas.width = width;
            depthMapCanvas.height = height;
            
            // Create visualization
            const visualData = createDepthVisualization(depthMap, width, height);
            depthMapCtx.putImageData(visualData, 0, 0);
            
            // Store latest depth map
            latestDepthMap = { depthMap, width, height };
            
            // Log depth statistics
            let minDepth = 1.0, maxDepth = 0.0, avgDepth = 0.0;
            for (let i = 0; i < depthMap.length; i++) {
                const depth = depthMap[i];
                minDepth = Math.min(minDepth, depth);
                maxDepth = Math.max(maxDepth, depth);
                avgDepth += depth;
            }
            avgDepth /= depthMap.length;
            
            debugLog(`Hadit depth stats: min=${minDepth.toFixed(3)}, max=${maxDepth.toFixed(3)}, avg=${avgDepth.toFixed(3)}, φ=${haditConfig.haditPhi}°, θ=${haditConfig.haditTheta}°, band=${haditConfig.bandSizeMultiplier}x`);
        }
        
        // NEW: Toggle depth map display
        function toggleDepthMapDisplay() {
            const depthMapDisplay = document.getElementById('depthMapDisplay');
            const toggleButton = document.getElementById('toggleDepthMap');
            
            depthMapVisible = !depthMapVisible;
            
            if (depthMapVisible) {
                depthMapDisplay.style.display = 'block';
                toggleButton.textContent = 'Hide Depth';
                toggleButton.classList.add('active');
                debugLog('Depth map display enabled');
                
                // If we have a cached depth map, display it
                if (latestDepthMap) {
                    updateDepthMapDisplay(latestDepthMap.depthMap, latestDepthMap.width, latestDepthMap.height);
                }
            } else {
                depthMapDisplay.style.display = 'none';
                toggleButton.textContent = 'Show Depth';
                toggleButton.classList.remove('active');
                debugLog('Depth map display disabled');
            }
        }
        
        // Add depth map visualization for debugging
        function showDepthMapDebug(depthImgData) {
            // This function is now replaced by updateDepthMapDisplay
            updateDepthMapDisplay(depthImgData.data, depthImgData.width, depthImgData.height);
        }
        
        // Try to set up WebGL for GPU acceleration
        function setupWebGL() {
            try {
                // Create a test WebGL context
                const testCanvas = document.createElement('canvas');
                const gl = testCanvas.getContext('webgl', {
                    powerPreference: 'high-performance',
                    antialias: false,
                    alpha: false
                }) || testCanvas.getContext('experimental-webgl');
                
                if (!gl) {
                    debugLog("WebGL not supported on this device");
                    return false;
                }
                
                // Check for required capabilities
                const extensions = gl.getSupportedExtensions();
                if (!extensions.includes('OES_texture_float') && !extensions.includes('OES_texture_half_float')) {
                    debugLog("Required WebGL extensions not supported");
                    return false;
                }
                
                // Test if we can create basic textures and framebuffers
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                
                const framebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                
                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    debugLog("WebGL framebuffer creation failed");
                    return false;
                }
                
                // Clean up
                gl.deleteTexture(texture);
                gl.deleteFramebuffer(framebuffer);
                
                debugLog("WebGL acceleration available and working");
                return true;
            } catch (e) {
                debugLog("WebGL setup error: " + e.message);
                return false;
            }
        }
        
        // Improved camera enumeration
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                debugLog(`Found ${videoDevices.length} camera(s)`);
                
                detectedCameras.all = videoDevices;
                
                // Reset camera assignments for fresh detection
                detectedCameras.front = null;
                detectedCameras.back = null;
                
                // Try to identify front/back cameras by label
                videoDevices.forEach((device, index) => {
                    const label = (device.label || '').toLowerCase();
                    debugLog(`Camera ${index+1}: ${label || 'Unnamed'} (${device.deviceId.substring(0, 8)}...)`);
                    
                    // Look for keywords that typically indicate front/back cameras
                    if (/back|rear|environment|main/i.test(label)) {
                        detectedCameras.back = device.deviceId;
                        debugLog(`Identified back camera by label: ${label}`);
                    }
                    if (/front|user|face|selfie/i.test(label)) {
                        detectedCameras.front = device.deviceId;
                        debugLog(`Identified front camera by label: ${label}`);
                    }
                });
                
                // If we couldn't identify by keywords but have multiple cameras
                if (videoDevices.length > 1) {
                    // Different assumptions based on platform
                    if (isAndroid) {
                        // On Android, camera 0 is often back camera, camera 1 is front
                        if (!detectedCameras.back) {
                            detectedCameras.back = videoDevices[0]?.deviceId;
                            debugLog("Using Android assumption: first camera is back camera");
                        }
                        if (!detectedCameras.front) {
                            detectedCameras.front = videoDevices[1]?.deviceId;
                            debugLog("Using Android assumption: second camera is front camera");
                        }
                    } else {
                        // On iOS/others, camera 0 is often front, camera 1 is back
                        if (!detectedCameras.front) {
                            detectedCameras.front = videoDevices[0]?.deviceId;
                            debugLog("Using iOS/default assumption: first camera is front camera");
                        }
                        if (!detectedCameras.back) {
                            detectedCameras.back = videoDevices[1]?.deviceId;
                            debugLog("Using iOS/default assumption: second camera is back camera");
                        }
                    }
                } else if (videoDevices.length === 1) {
                    // If only one camera, use it for both
                    detectedCameras.front = detectedCameras.back = videoDevices[0].deviceId;
                    debugLog("Only one camera found, using it for both front and back");
                }
                
                debugLog(`Camera detection results - Front: ${detectedCameras.front ? 'Found' : 'Not found'}, Back: ${detectedCameras.back ? 'Found' : 'Not found'}`);
                
                return videoDevices.length > 0;
            } catch (error) {
                debugLog('Error enumerating cameras: ' + error.message);
                return false;
            }
        }

        // Function to update Hadit configuration from UI controls
        function updateHaditConfig() {
            haditConfig.haditTheta = parseFloat(document.getElementById('haditTheta').value);
            haditConfig.haditPhi = parseFloat(document.getElementById('haditPhi').value);
            haditConfig.haditInfluence = parseFloat(document.getElementById('haditInfluence').value);
            haditConfig.focusFactor = parseFloat(document.getElementById('focusFactor').value);
            haditConfig.bandMode = document.getElementById('bandMode').value;
            haditConfig.bandSizeMultiplier = parseFloat(document.getElementById('bandSizeMultiplier').value); // NEW
            haditConfig.luminosityWeight = parseFloat(document.getElementById('luminosityWeight').value);
            haditConfig.saturationWeight = parseFloat(document.getElementById('saturationWeight').value);
            haditConfig.depthContrast = parseFloat(document.getElementById('depthContrast').value);
            haditConfig.sBounds = parseFloat(document.getElementById('sBounds').value);
            
            // Update S bounds for legacy functions
            currentSBounds = haditConfig.sBounds;
            
            // Update indicator
            const haditIndicator = document.getElementById('haditIndicator');
            if (haditIndicator) {
                haditIndicator.textContent = `Hadit: φ=${haditConfig.haditPhi.toFixed(1)}° θ=${haditConfig.haditTheta.toFixed(1)}° Focus=${haditConfig.focusFactor.toFixed(1)}x Band=${haditConfig.bandSizeMultiplier.toFixed(1)}x`;
            }
        }

        // Function to update value displays
        function updateValueDisplays() {
            const controls = [
                { id: 'haditTheta', suffix: '°' },
                { id: 'haditPhi', suffix: '°' },
                { id: 'haditInfluence', suffix: '' },
                { id: 'focusFactor', suffix: 'x' },
                { id: 'bandSizeMultiplier', suffix: 'x' }, // NEW
                { id: 'luminosityWeight', suffix: '' },
                { id: 'saturationWeight', suffix: '' },
                { id: 'depthContrast', suffix: 'x' },
                { id: 'nuitRadius', suffix: '' },
                { id: 'sBounds', suffix: '', prefix: '±' },
                { id: 'baselineSeparation', suffix: '%' }
            ];

            controls.forEach(({ id, suffix, prefix }) => {
                const element = document.getElementById(id);
                const valueElement = document.getElementById(id + 'Value');
                if (element && valueElement) {
                    const prefixText = prefix || '';
                    valueElement.textContent = prefixText + element.value + suffix;
                }
            });
            
            updateHaditConfig();
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            debugLog("Hadit AndroidVR initializing...");
            debugLog("Current Date and Time (UTC): 2025-06-07 02:30:11");
            debugLog("Current User Login: Angledcrystals");
            
            // Set up event listeners for Hadit controls
            const haditControls = ['haditTheta', 'haditPhi', 'haditInfluence', 'focusFactor', 'bandMode', 
                                 'bandSizeMultiplier', 'luminosityWeight', 'saturationWeight', 'depthContrast', 'sBounds'];
            
            haditControls.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', updateValueDisplays);
                    element.addEventListener('change', updateValueDisplays);
                }
            });
            
            // Set up other control listeners
            const otherControls = ['nuitRadius', 'baselineSeparation'];
            otherControls.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', updateValueDisplays);
                }
            });
            
            // Set up depth map toggle
            document.getElementById('toggleDepthMap').addEventListener('click', toggleDepthMapDisplay);
            
            // Initialize value displays
            updateValueDisplays();
            
            // Set up camera controls
            setupCameraControls();
            setupViewControls();
            setupRecordingControls();
            
            // Initialize WebGL if possible
            if (setupWebGL()) {
                renderMethod = 'webgl';
                debugLog("Using WebGL rendering method");
            } else {
                debugLog("Using Canvas 2D rendering method");
            }
            
            // Start camera enumeration
            enumerateCameras().then(hasCamera => {
                if (hasCamera) {
                    debugLog("Cameras detected, ready to start");
                } else {
                    debugLog("No cameras detected");
                }
            });
            
            debugLog("Hadit AndroidVR initialization complete");
            debugLog("✅ NEW: Band Size Multiplier control added (0.1x - 5.0x range)");
            debugLog("✅ NEW: Real-time depth map display toggle added");
        });

        function setupCameraControls() {
            const startButton = document.getElementById('startButton');
            const switchButton = document.getElementById('switchButton');
            
            startButton.addEventListener('click', async function() {
                if (currentStream) {
                    await stopCamera();
                    startButton.textContent = 'Start Camera';
                } else {
                    await startCamera();
                    startButton.textContent = 'Stop Camera';
                }
            });
            
            switchButton.addEventListener('click', async function() {
                if (currentStream) {
                    useFrontCamera = !useFrontCamera;
                    await startCamera();
                    debugLog(`Switched to ${useFrontCamera ? 'front' : 'back'} camera`);
                }
            });
        }
        
        function setupViewControls() {
            const tiltSlider = document.getElementById('tiltSlider');
            const sizeSlider = document.getElementById('sizeSlider');
            const toggleFlickerButton = document.getElementById('toggleFlickerMode');
            const flickerSpeedSlider = document.getElementById('flickerSpeedSlider');
            const freezeDelayToggle = document.getElementById('freezeDelayToggle');
            
            tiltSlider.addEventListener('input', updateCanvasTransforms);
            sizeSlider.addEventListener('input', updateCanvasTransforms);
            
            toggleFlickerButton.addEventListener('click', function() {
                toggleFlickerMode();
            });
            
            flickerSpeedSlider.addEventListener('input', function() {
                flickerSpeed = parseInt(this.value);
                if (flickerInterval) {
                    clearInterval(flickerInterval);
                    flickerInterval = setInterval(swapCanvasPositions, flickerSpeed);
                }
            });

            // Freeze delay functionality
            freezeDelayToggle.addEventListener('change', function() {
                if (this.checked && !freezeCountdownActive) {
                    startFreezeCountdown();
                } else if (!this.checked && freezeCountdownActive) {
                    stopFreezeCountdown();
                } else if (!this.checked && isFrozen) {
                    unfreeze();
                }
            });
        }
        
        function setupRecordingControls() {
            const recordButton = document.getElementById('recordButton');
            const stopRecordButton = document.getElementById('stopRecordButton');
            
            recordButton.addEventListener('click', startRecording);
            stopRecordButton.addEventListener('click', stopRecording);
        }
        
        async function startCamera() {
            try {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                
                const targetDeviceId = useFrontCamera ? detectedCameras.front : detectedCameras.back;
                
                const constraints = {
                    video: {
                        facingMode: useFrontCamera ? 'user' : 'environment',
                        width: { ideal: 1280, min: 640 },
                        height: { ideal: 720, min: 480 },
                        frameRate: { ideal: 30, min: 15 }
                    }
                };
                
                if (targetDeviceId) {
                    constraints.video.deviceId = { exact: targetDeviceId };
                }
                
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                detectedCameras.current = targetDeviceId;
                
                if (!video) {
                    video = document.createElement('video');
                    video.playsInline = true;
                    video.muted = true;
                }
                
                video.srcObject = currentStream;
                await video.play();
                
                debugLog(`Camera started: ${video.videoWidth}x${video.videoHeight}`);
                startProcessing();
                
            } catch (error) {
                debugLog('Camera start error: ' + error.message);
                
                // Fallback: try without device constraints
                try {
                    const fallbackConstraints = {
                        video: {
                            facingMode: useFrontCamera ? 'user' : 'environment'
                        }
                    };
                    
                    currentStream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
                    
                    if (!video) {
                        video = document.createElement('video');
                        video.playsInline = true;
                        video.muted = true;
                    }
                    
                    video.srcObject = currentStream;
                    await video.play();
                    
                    debugLog(`Fallback camera started: ${video.videoWidth}x${video.videoHeight}`);
                    startProcessing();
                    
                } catch (fallbackError) {
                    debugLog('Fallback camera error: ' + fallbackError.message);
                }
            }
        }
        
        async function stopCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            
            if (video) {
                video.srcObject = null;
            }
            
            stopProcessing();
            debugLog('Camera stopped');
        }
        
        function startProcessing() {
            if (!video || video.videoWidth === 0) {
                setTimeout(startProcessing, 100);
                return;
            }
            
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            // Set canvas dimensions based on video
            const aspectRatio = video.videoWidth / video.videoHeight;
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight * 0.8; // 80vh
            
            let canvasWidth, canvasHeight;
            
            if (containerWidth / aspectRatio <= containerHeight) {
                canvasWidth = containerWidth * 0.4; // 40% of container width per canvas
                canvasHeight = canvasWidth / aspectRatio;
            } else {
                canvasHeight = containerHeight * 0.8;
                canvasWidth = canvasHeight * aspectRatio;
            }
            
            canvas1.width = canvas2.width = canvasWidth;
            canvas1.height = canvas2.height = canvasHeight;
            
            updateCanvasTransforms();
            
            debugLog(`Canvas dimensions: ${canvasWidth}x${canvasHeight}, aspect ratio: ${aspectRatio.toFixed(2)}`);
            
            // Start the main processing loop
            processFrame();
        }
        
        function stopProcessing() {
            // Processing will stop automatically when video is null
        }
        
        function processFrame() {
            if (!video || video.videoWidth === 0 || video.readyState < 2) {
                if (video) {
                    requestAnimationFrame(processFrame);
                }
                return;
            }
            
            const now = performance.now();
            
            // Frame rate limiting
            if (now - lastFrameTime < frameInterval) {
                requestAnimationFrame(processFrame);
                return;
            }
            
            lastFrameTime = now;
            
            try {
                updateHaditConfig(); // Ensure config is current
                
                if (isFrozen && frozenFrameData) {
                    // Use frozen frame data
                    generateHaditStereoViewsFromImageData(frozenFrameData);
                } else {
                    // Process live frame
                    generateHaditStereoViews();
                }
                
                updateCanvasTransforms();
                
                // Update vector field time for animated effects
                vectorFieldTime = now * 0.001; // Convert to seconds
                
            } catch (error) {
                debugLog('Frame processing error: ' + error.message);
            }
            
            requestAnimationFrame(processFrame);
        }
        
        function generateHaditStereoViews() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            const ctx1 = canvas1.getContext('2d');
            const ctx2 = canvas2.getContext('2d');
            
            if (!video || video.videoWidth === 0) return;
            
            // Calculate processing dimensions
            const procWidth = Math.floor(video.videoWidth * qualityFactor);
            const procHeight = Math.floor(video.videoHeight * qualityFactor);
            
            // Set up processing canvas
            processingCanvas.width = procWidth;
            processingCanvas.height = procHeight;
            processingCtx.drawImage(video, 0, 0, procWidth, procHeight);
            
            const imageData = processingCtx.getImageData(0, 0, procWidth, procHeight);
            
            generateHaditStereoViewsFromImageData(imageData);
        }

        function generateHaditStereoViewsFromImageData(imageData) {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            const ctx1 = canvas1.getContext('2d');
            const ctx2 = canvas2.getContext('2d');
            
            // Detect Hadit information band for this frame
            const detectedBand = detectHaditInformationBand(imageData, haditConfig);
            
            // Generate depth map using Hadit S-coordinate transformation
            const depthMap = generateHaditDepthMap(imageData, detectedBand);
            
            // Update depth map display if visible
            if (depthMapVisible) {
                updateDepthMapDisplay(depthMap, imageData.width, imageData.height);
            }
            
            // Create stereo views
            const leftImageData = ctx1.createImageData(canvas1.width, canvas1.height);
            const rightImageData = ctx2.createImageData(canvas2.width, canvas2.height);
            
            generateStereoFromDepth(imageData, depthMap, leftImageData, rightImageData, imageData.width, imageData.height);
            
            // Apply the stereo views to canvases
            ctx1.putImageData(leftImageData, 0, 0);
            ctx2.putImageData(rightImageData, 0, 0);
        }
        
        function generateHaditDepthMap(imageData, detectedBand) {
            const { width, height, data } = imageData;
            const depthMap = new Float32Array(width * height);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    // Calculate Hadit S-coordinate for this pixel
                    const haditResult = calculateHaditSCoordinate(
                        x, y, width, height, lum, sat,
                        haditConfig.haditTheta, haditConfig.haditPhi, haditConfig.haditInfluence,
                        haditConfig.luminosityWeight, haditConfig.saturationWeight
                    );
                    
                    // Calculate depth based on Hadit transformation
                    const depthResult = calculateHaditDepth(haditResult, detectedBand, 
                        haditConfig.focusFactor, haditConfig.depthContrast);
                    
                    depthMap[idx] = depthResult.depth;
                }
            }
            
            return depthMap;
        }
        
        function generateStereoFromDepth(originalImageData, depthMap, leftImageData, rightImageData, srcWidth, srcHeight) {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            const dstWidth = canvas1.width;
            const dstHeight = canvas1.height;
            
            const baselineSeparation = parseFloat(document.getElementById('baselineSeparation').value) / 100;
            const maxDisplacement = dstWidth * baselineSeparation;
            
            // Fill with original image first
            for (let y = 0; y < dstHeight; y++) {
                for (let x = 0; x < dstWidth; x++) {
                    const dstIdx = (y * dstWidth + x) * 4;
                    
                    // Map destination pixel to source pixel
                    const srcX = Math.floor((x / dstWidth) * srcWidth);
                    const srcY = Math.floor((y / dstHeight) * srcHeight);
                    const srcIdx = (srcY * srcWidth + srcX) * 4;
                    
                    if (srcIdx < originalImageData.data.length) {
                        leftImageData.data[dstIdx] = originalImageData.data[srcIdx];
                        leftImageData.data[dstIdx + 1] = originalImageData.data[srcIdx + 1];
                        leftImageData.data[dstIdx + 2] = originalImageData.data[srcIdx + 2];
                        leftImageData.data[dstIdx + 3] = 255;
                        
                        rightImageData.data[dstIdx] = originalImageData.data[srcIdx];
                        rightImageData.data[dstIdx + 1] = originalImageData.data[srcIdx + 1];
                        rightImageData.data[dstIdx + 2] = originalImageData.data[srcIdx + 2];
                        rightImageData.data[dstIdx + 3] = 255;
                    }
                }
            }
            
            // Apply depth-based displacement
            for (let y = 0; y < dstHeight; y++) {
                for (let x = 0; x < dstWidth; x++) {
                    const dstIdx = (y * dstWidth + x) * 4;
                    
                    // Map to source coordinates for depth lookup
                    const srcX = Math.floor((x / dstWidth) * srcWidth);
                    const srcY = Math.floor((y / dstHeight) * srcHeight);
                    const depthIdx = srcY * srcWidth + srcX;
                    
                    if (depthIdx < depthMap.length) {
                        const depth = depthMap[depthIdx];
                        const normalizedDepth = (depth - 0.5) * 2; // -1 to 1 range
                        const displacement = Math.round(normalizedDepth * maxDisplacement);
                        
                        // Left eye: sample from displaced position
                        const leftSampleX = Math.max(0, Math.min(dstWidth - 1, x + displacement));
                        const leftSampleIdx = (y * dstWidth + leftSampleX) * 4;
                        
                        // Right eye: sample from opposite displaced position  
                        const rightSampleX = Math.max(0, Math.min(dstWidth - 1, x - displacement));
                        const rightSampleIdx = (y * dstWidth + rightSampleX) * 4;
                        
                        // Copy pixel data with displacement
                        if (leftSampleIdx < leftImageData.data.length) {
                            const srcSampleX = Math.floor((leftSampleX / dstWidth) * srcWidth);
                            const srcSampleY = Math.floor((y / dstHeight) * srcHeight);
                            const srcSampleIdx = (srcSampleY * srcWidth + srcSampleX) * 4;
                            
                            if (srcSampleIdx < originalImageData.data.length) {
                                leftImageData.data[dstIdx] = originalImageData.data[srcSampleIdx];
                                leftImageData.data[dstIdx + 1] = originalImageData.data[srcSampleIdx + 1];
                                leftImageData.data[dstIdx + 2] = originalImageData.data[srcSampleIdx + 2];
                            }
                        }
                        
                        if (rightSampleIdx < rightImageData.data.length) {
                            const srcSampleX = Math.floor((rightSampleX / dstWidth) * srcWidth);
                            const srcSampleY = Math.floor((y / dstHeight) * srcHeight);
                            const srcSampleIdx = (srcSampleY * srcWidth + srcSampleX) * 4;
                            
                            if (srcSampleIdx < originalImageData.data.length) {
                                rightImageData.data[dstIdx] = originalImageData.data[srcSampleIdx];
                                rightImageData.data[dstIdx + 1] = originalImageData.data[srcSampleIdx + 1];
                                rightImageData.data[dstIdx + 2] = originalImageData.data[srcSampleIdx + 2];
                            }
                        }
                    }
                }
            }
            
            // Apply color filters
            applyColorFilters(leftImageData, rightImageData);
        }
        
        function applyColorFilters(leftImageData, rightImageData) {
            const redLeft = parseInt(document.getElementById('redSlider1').value);
            const greenLeft = parseInt(document.getElementById('greenSlider1').value);
            const blueLeft = parseInt(document.getElementById('blueSlider1').value);
            
            const redRight = parseInt(document.getElementById('redSlider2').value);
            const greenRight = parseInt(document.getElementById('greenSlider2').value);
            const blueRight = parseInt(document.getElementById('blueSlider2').value);
            
            for (let i = 0; i < leftImageData.data.length; i += 4) {
                leftImageData.data[i] = (leftImageData.data[i] * redLeft) / 255;
                leftImageData.data[i + 1] = (leftImageData.data[i + 1] * greenLeft) / 255;
                leftImageData.data[i + 2] = (leftImageData.data[i + 2] * blueLeft) / 255;
                
                rightImageData.data[i] = (rightImageData.data[i] * redRight) / 255;
                rightImageData.data[i + 1] = (rightImageData.data[i + 1] * greenRight) / 255;
                rightImageData.data[i + 2] = (rightImageData.data[i + 2] * blueRight) / 255;
            }
        }
        
        function createDepthVisualization(depthMap, width, height) {
            const visualData = new ImageData(width, height);
            
            for (let i = 0; i < depthMap.length; i++) {
                const depth = depthMap[i];
                const gray = Math.round(depth * 255);
                const pixelIdx = i * 4;
                
                visualData.data[pixelIdx] = gray;
                visualData.data[pixelIdx + 1] = gray;
                visualData.data[pixelIdx + 2] = gray;
                visualData.data[pixelIdx + 3] = 255;
            }
            
            return visualData;
        }
        
        function updateCanvasTransforms() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            const tilt = parseFloat(document.getElementById('tiltSlider').value);
            const size = parseFloat(document.getElementById('sizeSlider').value);
            
            const transform = `scale(${size}) rotateY(${tilt}rad)`;
            
            canvas1.style.transform = transform;
            canvas2.style.transform = transform;
        }

        // Freeze functionality
        function startFreezeCountdown() {
            if (freezeCountdownActive) return;
            
            freezeCountdownActive = true;
            const countdown = document.getElementById('freezeCountdown');
            const countdownValue = document.getElementById('countdownValue');
            
            countdown.style.display = 'block';
            
            let count = 3;
            countdownValue.textContent = count;
            
            freezeCountdownTimer = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownValue.textContent = count;
                } else {
                    clearInterval(freezeCountdownTimer);
                    countdown.style.display = 'none';
                    freezeCountdownActive = false;
                    
                    // Capture current frame
                    captureFrameForFreeze();
                }
            }, 1000);
        }
        
        function stopFreezeCountdown() {
            if (freezeCountdownTimer) {
                clearInterval(freezeCountdownTimer);
                freezeCountdownTimer = null;
            }
            
            freezeCountdownActive = false;
            document.getElementById('freezeCountdown').style.display = 'none';
        }
        
        function captureFrameForFreeze() {
            if (!video || video.videoWidth === 0) return;
            
            // Capture current video frame
            const procWidth = Math.floor(video.videoWidth * qualityFactor);
            const procHeight = Math.floor(video.videoHeight * qualityFactor);
            
            processingCanvas.width = procWidth;
            processingCanvas.height = procHeight;
            processingCtx.drawImage(video, 0, 0, procWidth, procHeight);
            
            frozenFrameData = processingCtx.getImageData(0, 0, procWidth, procHeight);
            isFrozen = true;
            
            // Add visual indication of frozen state
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            canvas1.classList.add('frozen-canvas');
            canvas2.classList.add('frozen-canvas');
            
            debugLog('Frame frozen for analysis - Band Size: ' + haditConfig.bandSizeMultiplier + 'x');
        }
        
        function unfreeze() {
            isFrozen = false;
            frozenFrameData = null;
            
            // Remove visual indication
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            canvas1.classList.remove('frozen-canvas');
            canvas2.classList.remove('frozen-canvas');
            
            debugLog('Frame unfrozen, resuming live processing');
        }
        
        function toggleFlickerMode() {
            const button = document.getElementById('toggleFlickerMode');
            const speedContainer = document.getElementById('flickerSpeedContainer');
            const indicator = document.getElementById('flickerIndicator');
            
            flickerMode = !flickerMode;
            
            if (flickerMode) {
                button.textContent = 'Disable 3D Flicker';
                speedContainer.style.display = 'flex';
                indicator.style.opacity = '1';
                document.body.classList.add('flicker-active');
                
                // Store original positions
                const canvas1 = document.getElementById('canvas1');
                const canvas2 = document.getElementById('canvas2');
                originalCanvasPositions.canvas1.transform = canvas1.style.transform;
                originalCanvasPositions.canvas2.transform = canvas2.style.transform;
                
                // Start flicker interval
                flickerInterval = setInterval(swapCanvasPositions, flickerSpeed);
                
                debugLog('3D flicker mode enabled');
            } else {
                button.textContent = 'Enable 3D Flicker';
                speedContainer.style.display = 'none';
                indicator.style.opacity = '0';
                document.body.classList.remove('flicker-active');
                
                // Stop flicker interval
                if (flickerInterval) {
                    clearInterval(flickerInterval);
                    flickerInterval = null;
                }
                
                // Restore original positions
                const canvas1 = document.getElementById('canvas1');
                const canvas2 = document.getElementById('canvas2');
                canvas1.classList.remove('canvas-left', 'canvas-right');
                canvas2.classList.remove('canvas-left', 'canvas-right');
                
                debugLog('3D flicker mode disabled');
            }
        }
        
        function swapCanvasPositions() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            if (flickerFrame === 0) {
                canvas1.classList.add('canvas-left');
                canvas1.classList.remove('canvas-right');
                canvas2.classList.add('canvas-right');
                canvas2.classList.remove('canvas-left');
                flickerFrame = 1;
            } else {
                canvas1.classList.add('canvas-right');
                canvas1.classList.remove('canvas-left');
                canvas2.classList.add('canvas-left');
                canvas2.classList.remove('canvas-right');
                flickerFrame = 0;
            }
        }
        
        // Recording functionality
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = 0;
        let recordingTimer = null;
        
        function startRecording() {
            try {
                const canvas1 = document.getElementById('canvas1');
                const canvas2 = document.getElementById('canvas2');
                
                // Create a combined canvas for recording
                const recordCanvas = document.createElement('canvas');
                recordCanvas.width = canvas1.width * 2;
                recordCanvas.height = canvas1.height;
                const recordCtx = recordCanvas.getContext('2d');
                
                // Capture stream from combined canvas
                const stream = recordCanvas.captureStream(30);
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9'
                });
                
                recordedChunks = [];
                
                mediaRecorder.addEventListener('dataavailable', event => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                });
                
                mediaRecorder.addEventListener('stop', () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hadit-androidvr-${new Date().toISOString().replace(/[:.]/g, '-')}.webm`;
                    a.click();
                    
                    URL.revokeObjectURL(url);
                });
                
                // Start recording
                mediaRecorder.start();
                recordingStartTime = Date.now();
                
                // Update UI
                document.getElementById('recordButton').style.display = 'none';
                document.getElementById('stopRecordButton').style.display = 'inline-flex';
                document.getElementById('recordingIndicator').style.display = 'flex';
                
                // Start recording timer
                recordingTimer = setInterval(updateRecordingTimer, 1000);
                
                // Start rendering to record canvas
                function renderRecordFrame() {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        recordCtx.clearRect(0, 0, recordCanvas.width, recordCanvas.height);
                        recordCtx.drawImage(canvas1, 0, 0);
                        recordCtx.drawImage(canvas2, canvas1.width, 0);
                        requestAnimationFrame(renderRecordFrame);
                    }
                }
                renderRecordFrame();
                
                debugLog('Recording started - Band Size: ' + haditConfig.bandSizeMultiplier + 'x');
                
            } catch (error) {
                debugLog('Recording start error: ' + error.message);
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                
                // Update UI
                document.getElementById('recordButton').style.display = 'inline-flex';
                document.getElementById('stopRecordButton').style.display = 'none';
                document.getElementById('recordingIndicator').style.display = 'none';
                
                // Stop recording timer
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                
                debugLog('Recording stopped');
            }
        }
        
        function updateRecordingTimer() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            document.getElementById('recordingTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Quality control
        document.getElementById('qualitySelect').addEventListener('change', function() {
            qualityFactor = parseFloat(this.value);
            
            const indicator = document.getElementById('qualityIndicator');
            const percentage = Math.round(qualityFactor * 100);
            indicator.textContent = `Processing at ${percentage}% resolution`;
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
            
            debugLog(`Quality changed to ${percentage}%`);
        });
        
        // Controls toggle
        document.getElementById('toggleControls').addEventListener('click', function() {
            const controlPanel = document.getElementById('controlPanel');
            controlsHidden = !controlsHidden;
            
            if (controlsHidden) {
                controlPanel.style.display = 'none';
                this.textContent = 'Show Controls';
            } else {
                controlPanel.style.display = 'flex';
                this.textContent = 'Hide Controls';
            }
        });
        
        // Window resize handler
        window.addEventListener('resize', function() {
            if (video && video.videoWidth > 0) {
                // Recalculate canvas sizes
                const canvas1 = document.getElementById('canvas1');
                const canvas2 = document.getElementById('canvas2');
                
                const aspectRatio = video.videoWidth / video.videoHeight;
                const containerWidth = window.innerWidth;
                const containerHeight = window.innerHeight * 0.8;
                
                let canvasWidth, canvasHeight;
                
                if (containerWidth / aspectRatio <= containerHeight) {
                    canvasWidth = containerWidth * 0.4;
                    canvasHeight = canvasWidth / aspectRatio;
                } else {
                    canvasHeight = containerHeight * 0.8;
                    canvasWidth = canvasHeight * aspectRatio;
                }
                
                canvas1.width = canvas2.width = canvasWidth;
                canvas1.height = canvas2.height = canvasHeight;
                
                debugLog(`Window resized, canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            }
        });
        
    </script>
</body>
</html>
