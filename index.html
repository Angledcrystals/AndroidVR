<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AndroidVR - Invisible Mirror</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 5px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-bottom: 15px;
        }

        /* VR-optimized camera layout */
        .camera-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        /* Stereo view - optimized for VR headsets with responsive scaling */
        .stereo-view {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 95vw;
            box-sizing: border-box;
        }

        /* Depth view - positioned below stereo frames */
        .depth-view {
            display: flex;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 600px;
        }

        .camera-feed {
            position: relative;
            overflow: hidden;
        }

        /* Enhanced stereo frame sizing for VR with dynamic scaling */
        .stereo-frame {
            flex: 1;
            max-width: calc(50% - 10px);
            min-width: 300px;
            width: 100%;
        }

        .stereo-frame canvas {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            display: block;
        }

        /* Depth frame sizing with responsive scaling */
        .depth-frame {
            width: 100%;
            max-width: 400px;
        }

        .depth-frame canvas {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            max-height: 40vh;
            object-fit: contain;
            display: block;
        }

        canvas, video {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            box-sizing: border-box;
        }

        .left-eye { border-color: #ff4444 !important; }
        .right-eye { border-color: #4444ff !important; }
        .depth-map { border-color: #ff8800 !important; }
        .raw-video { border-color: #00ff88 !important; }

        .camera-label {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .left-label { color: #ff4444; }
        .right-label { color: #4444ff; }
        .depth-label { color: #ff8800; }
        .raw-label { color: #00ff88; }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #00ff88;
            margin-bottom: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 3px;
            font-size: 10px;
            width: 60px;
        }

        select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            cursor: pointer;
            font-size: 10px;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .camera-control {
            background: rgba(0, 255, 136, 0.2) !important;
            border-color: #00ff88 !important;
        }

        .hadit-control {
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: #ff00ff !important;
        }

        .band-control {
            background: rgba(255, 255, 0, 0.2) !important;
            border-color: #ffff00 !important;
        }

        .stereo-control {
            background: rgba(255, 68, 136, 0.2) !important;
            border-color: #ff4488 !important;
        }

        .depth-control {
            background: rgba(255, 136, 0, 0.2) !important;
            border-color: #ff8800 !important;
        }

        .dual-input {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dual-input input[type="range"] {
            flex: 1;
            margin-bottom: 0;
        }

        .dual-input input[type="number"] {
            flex: 0 0 auto;
        }

        .info-panel {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .hadit-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .analysis-panel {
            background: rgba(136, 255, 0, 0.1);
            border: 1px solid #88ff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .processing {
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5) !important;
            animation: processing 1s ease-in-out infinite;
        }

        @keyframes processing {
            0% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
        }

        .fps-counter {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
        }

        .camera-status {
            text-align: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .status-connecting { color: #ffff00; }
        .status-active { color: #00ff88; }
        .status-error { color: #ff4444; }

        .error-message {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #ff4444;
        }

        /* GPU Status Panel */
        .gpu-status {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
            text-align: center;
        }

        /* Debug video (visible) */
        #debugVideo {
            max-width: 200px;
            border: 1px solid #ffff00;
        }

        /* Landscape optimizations for VR */
        @media (orientation: landscape) and (min-width: 768px) {
            .stereo-view {
                padding: 25px;
                gap: 20px;
                max-width: 98vw;
            }
            
            .stereo-frame {
                max-width: calc(50% - 15px);
                min-width: 350px;
            }
            
            .stereo-frame canvas {
                max-height: 75vh;
            }
            
            .depth-view {
                max-width: 500px;
            }
            
            .camera-label {
                font-size: 14px;
                margin-bottom: 10px;
            }
        }

        /* Mobile and portrait optimizations */
        @media (max-width: 768px), (orientation: portrait) {
            .stereo-view {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                max-width: 95vw;
            }
            
            .stereo-frame {
                min-width: 280px;
                max-width: 90vw;
                width: 100%;
            }
            
            .stereo-frame canvas {
                max-height: 50vh;
            }
            
            .depth-view {
                max-width: 90vw;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Extra large landscape screens (VR friendly) */
        @media (orientation: landscape) and (min-width: 1200px) {
            .stereo-view {
                max-width: 98vw;
                padding: 30px;
                gap: 25px;
            }
            
            .stereo-frame {
                min-width: 450px;
                max-width: calc(50% - 20px);
            }
            
            .stereo-frame canvas {
                max-height: 80vh;
            }
            
            .camera-label {
                font-size: 16px;
            }
        }

        /* Ultra-wide displays (VR optimized) */
        @media (orientation: landscape) and (min-width: 1600px) {
            .stereo-view {
                max-width: 95vw;
                padding: 35px;
                gap: 30px;
            }
            
            .stereo-frame {
                min-width: 600px;
                max-width: calc(50% - 25px);
            }
            
            .stereo-frame canvas {
                max-height: 85vh;
            }
        }

        /* Small screens - ensure no cutoff */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .stereo-view {
                padding: 10px;
                gap: 10px;
                max-width: 98vw;
            }
            
            .stereo-frame {
                min-width: 250px;
                max-width: 95vw;
            }
            
            .stereo-frame canvas {
                max-height: 40vh;
            }
        }

        /* Force canvas to respect container bounds */
        canvas {
            max-width: 100% !important;
            height: auto !important;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AndroidVR - Invisible Mirror</h1>
        <div class="subtitle">Real-time Mirror angle Control with Band Detection & Depth Contrast: 0.1° Precision | 2025-06-08 10:11:04 UTC | User: Angledcrystals</div>

        <!-- GPU Status Panel -->
        <div class="gpu-status" id="gpuStatus" style="display: none;">
            <div style="color: #00ffff; font-weight: bold;">🔥 GPU Acceleration Status:</div>
            <div id="gpuStatusText">Checking WebGL support...</div>
        </div>

        <div class="hadit-info">
            <div style="color: #ff00ff; font-weight: bold;">⚡ Complete Live Hadit Processing:</div>
            <div>• Real-time camera feed with advanced Hadit band detection</div>
            <div>• θ (Theta): 0° to 360° in 0.1° increments for live adjustment</div>
            <div>• φ (Phi): 0.1° to 179.9° in 0.1° increments for extreme precision</div>
            <div>• Band detection modes: Auto, Content Analysis, Gradient-Based, Statistical, Manual, Full Image</div>
            <div>• Depth Contrast control for enhanced depth perception</div>
            <div>• Band size multiplier and focus controls for precise depth mapping</div>
            <div>• Parallel stereo view with pixel-perfect offset based on Hadit depth</div>
            <div>• S-coordinate offsets with bilinear interpolation for smooth rendering</div>
        </div>

        <div class="camera-status" id="cameraStatus">
            <span class="status-connecting">📹 Camera system ready - click Start Camera</span>
        </div>

        <div id="errorPanel" class="error-message" style="display: none;">
            <div style="font-weight: bold;">❌ Camera Error:</div>
            <div id="errorMessage">Unknown error occurred</div>
            <div style="margin-top: 5px; font-size: 10px;">
                • Make sure you allow camera permissions<br>
                • Try switching between front/back camera<br>
                • Check if another app is using the camera<br>
                • Refresh the page and try again
            </div>
        </div>

        <!-- Debug video element (visible for troubleshooting) -->
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="font-size: 11px; color: #ffff00; margin-bottom: 5px;">🔍 DEBUG: Raw Camera Feed</div>
            <video id="debugVideo" autoplay playsinline muted class="raw-video" style="display: none;"></video>
        </div>

        <div class="camera-container">
            <!-- Stereo frames optimized for VR headsets -->
            <div class="stereo-view">
                <div class="camera-feed stereo-frame">
                    <div class="camera-label left-label">Left Eye (Red)</div>
                    <canvas id="leftCanvas" width="640" height="480" class="left-eye"></canvas>
                    <div class="fps-counter" id="leftFps">0 FPS</div>
                </div>
                <div class="camera-feed stereo-frame">
                    <div class="camera-label right-label">Right Eye (Blue)</div>
                    <canvas id="rightCanvas" width="640" height="480" class="right-eye"></canvas>
                    <div class="fps-counter" id="rightFps">0 FPS</div>
                </div>
            </div>
            
            <!-- Depth map positioned below stereo frames -->
            <div class="depth-view">
                <div class="camera-feed depth-frame">
                    <div class="camera-label depth-label">Hadit Depth</div>
                    <canvas id="depthCanvas" width="320" height="240" class="depth-map"></canvas>
                    <div class="fps-counter" id="depthFps">0 FPS</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>📹 Camera Control</label>
                <button id="startCamera" class="camera-control">▶️ Start Camera</button>
                <button id="switchCamera" class="camera-control" style="display: none;">🔄 Switch Camera</button>
                <button id="stopCamera" class="camera-control" style="display: none;">⏹️ Stop Camera</button>
                <button id="requestPermissions" class="camera-control">🔑 Request Permissions</button>
                <button id="toggleDebugVideo" class="camera-control">👁️ Toggle Debug Video</button>
            </div>

            <div class="control-group">
                <label>🔧 Depth Source</label>
                <select id="depthSource" class="hadit-control">
                    <option value="brightness">Brightness/Saturation</option>
                    <option value="sMagnitude">S-Magnitude</option>
                    <option value="radial">Radial Distance</option>
                    <option value="angular">Angular Reflection</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>📐 Camera Settings</label>
                <select id="resolutionSelect" class="camera-control">
                    <option value="320x240">320x240 (Low)</option>
                    <option value="640x480" selected>640x480 (VGA)</option>
                    <option value="1280x720">1280x720 (HD)</option>
                    <option value="1920x1080">1920x1080 (FHD)</option>
                </select>
                <select id="facingMode" class="camera-control">
                    <option value="environment" selected>Back Camera</option>
                    <option value="user">Front Camera</option>
                </select>
            </div>

            <div class="control-group">
                <label>📡 Band Detection Mode</label>
                <select id="bandDetectionMode" class="band-control">
                    <option value="auto_detect" selected>🔍 Auto-Detect Band</option>
                    <option value="content_analysis">📊 Content Analysis</option>
                    <option value="gradient_based">🌊 Gradient-Based</option>
                    <option value="statistical">📈 Statistical Analysis</option>
                    <option value="manual_range">✋ Manual Range</option>
                    <option value="full_image">🌍 Full Image Coverage</option>
                </select>
            </div>

            <div class="control-group">
                <label>🔧 Band Size Multiplier: <span id="bandSizeMultiplierValue">10.0x</span></label>
                <input type="range" id="bandSizeMultiplier" min="0.1" max="10.0" step="0.1" value="10.0" class="band-control">
            </div>

            <div class="control-group">
                <label>🎯 Focus Factor: <span id="focusFactorValue">4.0x</span></label>
                <input type="range" id="focusFactor" min="1.0" max="5.0" step="0.1" value="4.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>⚡ Hadit θ (Theta): <span id="haditThetaValue">0.0°</span></label>
                <div class="dual-input">
                    <input type="range" id="haditTheta" min="0" max="360" value="0" step="0.1" class="hadit-control">
                    <input type="number" id="haditThetaNumber" min="0" max="360" step="0.1" value="0" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>⚡ Hadit φ (Phi): <span id="haditPhiValue">0.1°</span></label>
                <div class="dual-input">
                    <input type="range" id="haditPhi" min="0.1" max="179.9" value="0.1" step="0.1" class="hadit-control">
                    <input type="number" id="haditPhiNumber" min="0.1" max="179.9" step="0.1" value="0.1" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>🌊 Hadit Influence: <span id="haditInfluenceValue">1.0</span></label>
                <input type="range" id="haditInfluence" min="0" max="2" value="1.0" step="0.1" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>👁️ Stereo Separation: <span id="separationValue">8px</span></label>
                <input type="range" id="separation" min="0" max="50" value="8" step="1" class="stereo-control">
            </div>
            
            <div class="control-group">
                <label>🗺️ Depth Intensity: <span id="depthIntensityValue">2.0x</span></label>
                <input type="range" id="depthIntensity" min="0.1" max="5.0" value="2.0" step="0.1" class="depth-control">
            </div>

            <div class="control-group">
                <label>🎨 Depth Contrast: <span id="depthContrastValue">0.2x</span></label>
                <input type="range" id="depthContrast" min="0.1" max="3.0" value="0.2" step="0.1" class="depth-control">
            </div>
            
            <div class="control-group">
                <label>📐 S Bounds: <span id="sBoundsValue">±20.0</span></label>
                <input type="range" id="sBounds" min="1.0" max="20.0" step="0.1" value="20.0" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>💡 Luminosity Weight: <span id="luminosityWeightValue">0.0</span></label>
                <input type="range" id="luminosityWeight" min="0" max="1" step="0.05" value="0.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>🌈 Saturation Weight: <span id="saturationWeightValue">0.0</span></label>
                <input type="range" id="saturationWeight" min="0" max="1" step="0.05" value="0.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>⚙️ Processing Quality</label>
                <select id="qualitySelect" class="depth-control">
                    <option value="1.0">Full Quality</option>
                    <option value="0.75" selected>High Quality</option>
                    <option value="0.5">Medium Quality</option>
                    <option value="0.25">Low Quality</option>
                </select>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <div>Status: Complete Live Hadit camera system ready... Angledcrystals | 2025-06-08 10:11:04 UTC</div>
        </div>

        <div class="analysis-grid">
            <div>
                <div class="control-group">
                    <label>Quick Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHaditPole" class="hadit-control">φ=0.1° (Pole)</button>
                        <button id="setHaditEquator" class="hadit-control">φ=90° (Equator)</button>
                        <button id="setHaditNear180" class="hadit-control">φ=179.9° (Anti-pole)</button>
                        <button id="animateTheta" class="hadit-control">🌀 Animate θ</button>
                        <button id="animatePhi" class="hadit-control">🌊 Animate φ</button>
                        <button id="stopAnimation" class="hadit-control">⏹️ Stop All</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Depth Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHighContrast" class="depth-control">🔆 High Contrast</button>
                        <button id="setLowContrast" class="depth-control">🔅 Low Contrast</button>
                        <button id="setExtremeDepth" class="depth-control">💥 Extreme Depth</button>
                        <button id="setSubtleDepth" class="depth-control">🌫️ Subtle Depth</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Band Actions</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="detectBand" class="band-control">📡 Detect Band</button>
                        <button id="expandBandFull" class="band-control">🌍 Expand Full</button>
                        <button id="resetBand" class="band-control">🔄 Reset Band</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Options & Debug</label>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label><input type="checkbox" id="enableStereo" checked> Enable Stereo</label>
                        <label><input type="checkbox" id="showDepthMap" checked> Show Depth</label>
                        <label><input type="checkbox" id="showBandVisualization"> Show Band Viz</label>
                        <label><input type="checkbox" id="focusOnlyBand"> Focus Only Band</label>
                        <label><input type="checkbox" id="mirrorCamera"> Mirror Camera</label>
                        <label><input type="checkbox" id="showFPS" checked> Show FPS</label>
                        <label><input type="checkbox" id="debugMode" checked> Debug Mode</label>
                        <label><input type="checkbox" id="showRawFeed"> Show Raw Feed</label>
                        <label>🔥 GPU Processing</label>
                        <label><input type="checkbox" id="useGPU"> Enable GPU Acceleration</label>
                        <select id="gpuStereoMode" class="camera-control" disabled>
                            <option value="cpu">CPU Stereo Only</option>
                            <option value="gpu_forward">GPU Forward + Hole Fill</option>
                            <option value="gpu_bidirectional">GPU Bidirectional + Hole Fill</option>
                        </select>
                        <small style="color: #888; font-size: 9px;">GPU hole filling uses CPU depth data</small>                  
                    </div>
                </div>
            </div>
            
            <div class="analysis-panel" id="analysisPanel">
                <div style="color: #88ff00; font-weight: bold;">⚡ Live Hadit Band Analysis</div>
                <div>Ready for live camera processing with band detection...</div>
                <div>Camera permissions status: checking...</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== GPU ACCELERATION SYSTEM ====================
        
        class WebGLProcessor {
            constructor() {
                this.gl = null;
                this.program = null;
                this.isInitialized = false;
                this.gpuEnabled = false;
            }

            async initialize() {
                if (!document.getElementById('useGPU').checked) {
                    return false;
                }

                try {
                    this.canvas = document.createElement('canvas');
                    this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                    
                    if (!this.gl) {
                        throw new Error('WebGL not supported');
                    }

                    await this.createShaders();
                    this.createBuffers();
                    this.isInitialized = true;
                    this.gpuEnabled = true;
                    
                    console.log('🔥 GPU acceleration initialized');
                    this.updateGPUStatus(true, 'GPU Acceleration: ENABLED ✓');
                    
                    return true;
                } catch (error) {
                    console.warn('GPU acceleration failed:', error);
                    this.updateGPUStatus(false, 'GPU Acceleration: FAILED ❌');
                    this.gpuEnabled = false;
                    return false;
                }
            }

            async createShaders() {
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    attribute vec2 a_texCoord;
                    varying vec2 v_texCoord;
                    
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                        v_texCoord = a_texCoord;
                    }
                `;

                const fragmentShaderSource = `
                    precision highp float;
                    
                    uniform sampler2D u_image;
                    uniform float u_haditTheta;
                    uniform float u_haditPhi;
                    uniform float u_haditInfluence;
                    uniform float u_depthContrast;
                    uniform float u_luminosityWeight;
                    uniform float u_saturationWeight;
                    uniform vec2 u_resolution;
                    
                    varying vec2 v_texCoord;
                    
                    vec3 sphericalToCartesian(float theta, float phi) {
                        float thetaRad = theta * 3.14159265359 / 180.0;
                        float phiRad = clamp(phi, 0.1, 179.9) * 3.14159265359 / 180.0;
                        
                        return vec3(
                            sin(phiRad) * cos(thetaRad),
                            sin(phiRad) * sin(thetaRad),
                            cos(phiRad)
                        );
                    }
                    
                    vec3 householderReflection(vec3 g, vec3 hadit) {
                        vec3 haditUnit = normalize(hadit);
                        float dotProduct = dot(haditUnit, g);
                        return g - 2.0 * dotProduct * haditUnit;
                    }
                    
                    vec2 stereographicProjection(vec3 gReflected) {
                        if (abs(1.0 - gReflected.z) < 1e-10) {
                            return vec2(0.0, 0.0);
                        }
                        return vec2(
                            gReflected.x / (1.0 - gReflected.z),
                            gReflected.y / (1.0 - gReflected.z)
                        );
                    }
                    
                    void main() {
                        vec4 color = texture2D(u_image, v_texCoord);
                        
                        vec2 pixelCoord = v_texCoord * u_resolution;
                        
                        float lum = 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;
                        float maxCol = max(max(color.r, color.g), color.b);
                        float minCol = min(min(color.r, color.g), color.b);
                        float sat = maxCol > 0.0 ? (maxCol - minCol) / maxCol : 0.0;
                        
                        float gTheta = (pixelCoord.x / u_resolution.x) * 360.0;
                        float gPhi = (pixelCoord.y / u_resolution.y) * 180.0;
                        vec3 G_3d = sphericalToCartesian(gTheta, gPhi);
                        
                        vec3 hadit_3d = sphericalToCartesian(u_haditTheta, u_haditPhi);
                        vec3 G_reflected = householderReflection(G_3d, hadit_3d);
                        vec2 S_hadit = stereographicProjection(G_reflected);
                        
                        float contentModulation = 1.0 + lum * u_luminosityWeight + sat * u_saturationWeight;
                        vec2 sCoord = S_hadit * contentModulation * u_haditInfluence;
                        float sMagnitude = length(sCoord);
                        
                        float depth = 0.3 + lum * 0.4 + sat * 0.3;
                        depth = clamp(depth, 0.05, 1.0);
                        
                        float centerAdjusted = 0.5;
                        depth = centerAdjusted + (depth - centerAdjusted) * u_depthContrast;
                        depth = clamp(depth, 0.05, 1.0);
                        
                        gl_FragColor = vec4(depth, depth, depth, 1.0);
                    }
                `;

                this.program = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);
            }

            createShaderProgram(vertexSource, fragmentSource) {
                const gl = this.gl;
                
                const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error('Shader program linking failed');
                }
                
                return program;
            }

            createShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw new Error('Shader compilation failed');
                }
                
                return shader;
            }

            createBuffers() {
                const gl = this.gl;
                
                const positions = new Float32Array([
                    -1, -1,  0, 0,
                     1, -1,  1, 0,
                    -1,  1,  0, 1,
                     1,  1,  1, 1,
                ]);
                
                this.positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            }

            processDepthMap(imageData, config) {
                if (!this.isInitialized || !this.gpuEnabled) {
                    return null;
                }

                const gl = this.gl;
                const { width, height, data } = imageData;

                try {
                    this.canvas.width = width;
                    this.canvas.height = height;
                    gl.viewport(0, 0, width, height);

                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

                    gl.useProgram(this.program);

                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_haditTheta'), config.haditTheta);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_haditPhi'), config.haditPhi);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_haditInfluence'), config.haditInfluence);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_depthContrast'), config.depthContrast);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_luminosityWeight'), config.luminosityWeight);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_saturationWeight'), config.saturationWeight);
                    gl.uniform2f(gl.getUniformLocation(this.program, 'u_resolution'), width, height);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.uniform1i(gl.getUniformLocation(this.program, 'u_image'), 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                    const texCoordLocation = gl.getAttribLocation(this.program, 'a_texCoord');
                    
                    gl.enableVertexAttribArray(positionLocation);
                    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
                    
                    gl.enableVertexAttribArray(texCoordLocation);
                    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    const pixels = new Uint8Array(width * height * 4);
                    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

                    gl.deleteTexture(texture);

                    return pixels;

                } catch (error) {
                    console.error('GPU processing error:', error);
                    this.gpuEnabled = false;
                    this.updateGPUStatus(false, 'GPU Acceleration: ERROR ❌');
                    return null;
                }
            }

            updateGPUStatus(enabled, message) {
                const statusElement = document.getElementById('gpuStatusText');
                const statusPanel = document.getElementById('gpuStatus');
                
                if (statusElement && statusPanel) {
                    statusElement.textContent = message;
                    statusPanel.style.display = 'block';
                    statusPanel.style.borderColor = enabled ? '#00ffff' : '#ffaa00';
                }
            }
        }

        // ==================== MATHEMATICAL OPERATIONS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function calculateHaditModulatedSCoordinate(px, py, width, height, lum, sat, config) {
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            const contentModulation = 1.0 + lum * config.luminosityWeight + sat * config.saturationWeight;
            
            return {
                x: S_hadit.x * contentModulation * config.haditInfluence,
                y: S_hadit.y * contentModulation * config.haditInfluence
            };
        }

        // ==================== FIXED S-COORDINATE IMPLEMENTATION ====================

        function sampleBilinear(imageData, x, y, width, height) {
            // Clamp coordinates to image bounds
            x = Math.max(0, Math.min(width - 1, x));
            y = Math.max(0, Math.min(height - 1, y));
            
            const x1 = Math.floor(x);
            const y1 = Math.floor(y);
            const x2 = Math.min(x1 + 1, width - 1);
            const y2 = Math.min(y1 + 1, height - 1);
            
            const fx = x - x1;
            const fy = y - y1;
            
            // Get the four corner pixels
            const getPixel = (px, py) => {
                const index = (py * width + px) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            };
            
            const p1 = getPixel(x1, y1);
            const p2 = getPixel(x2, y1);
            const p3 = getPixel(x1, y2);
            const p4 = getPixel(x2, y2);
            
            // Bilinear interpolation
            const r = (1-fx)*(1-fy)*p1.r + fx*(1-fy)*p2.r + (1-fx)*fy*p3.r + fx*fy*p4.r;
            const g = (1-fx)*(1-fy)*p1.g + fx*(1-fy)*p2.g + (1-fx)*fy*p3.g + fx*fy*p4.g;
            const b = (1-fx)*(1-fy)*p1.b + fx*(1-fy)*p2.b + (1-fx)*fy*p3.b + fx*fy*p4.b;
            const a = (1-fx)*(1-fy)*p1.a + fx*(1-fy)*p2.a + (1-fx)*fy*p3.a + fx*fy*p4.a;
            
            return { r: Math.round(r), g: Math.round(g), b: Math.round(b), a: Math.round(a) };
        }

        function calculateSCoordOffsetsOptimized(imageData, config) {
            const { width, height } = imageData;
            const offsets = new Float32Array(width * height * 2);
            const depthMap = new Float32Array(width * height);
            
            const sBoundsValue = parseFloat(document.getElementById('sBounds').value);
            const depthSource = document.getElementById('depthSource').value;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const pixelIndex = (y * width + x) * 4;
                    const offsetIndex = (y * width + x) * 2;
                    const depthIndex = y * width + x;
                    
                    // Get pixel color
                    const r = imageData.data[pixelIndex] / 255;
                    const g = imageData.data[pixelIndex + 1] / 255;
                    const b = imageData.data[pixelIndex + 2] / 255;
                    
                    // Calculate luminosity and saturation
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    // Calculate S-coordinate for this pixel
                    const sCoord = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                    const sMagnitude = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                    
                    // Normalize by S-bounds
                    const normalizedSMagnitude = Math.min(sMagnitude / sBoundsValue, 1.0);
                    
                    // Choose depth source
                    let depthValue;
                    switch (depthSource) {
                        case 'brightness':
                            depthValue = lum * 0.7 + sat * 0.3;
                            break;
                        case 'sMagnitude':
                            depthValue = normalizedSMagnitude;
                            break;
                        case 'radial':
                            const centerX = width / 2;
                            const centerY = height / 2;
                            const distX = (x - centerX) / centerX;
                            const distY = (y - centerY) / centerY;
                            const radialDistance = Math.sqrt(distX * distX + distY * distY);
                            depthValue = Math.min(radialDistance, 1.0);
                            break;
                        case 'angular':
                            const gTheta = (x / width) * 360;
                            const angleFactor = Math.abs(Math.sin((gTheta - config.haditTheta) * Math.PI / 180));
                            depthValue = angleFactor * lum + (1 - angleFactor) * sat;
                            break;
                        default:
                            depthValue = lum * 0.7 + sat * 0.3;
                    }
                    
                    // Apply depth contrast
                    const centerAdjusted = 0.5;
                    depthValue = centerAdjusted + (depthValue - centerAdjusted) * config.depthContrast;
                    depthValue = Math.max(0.05, Math.min(depthValue, 1.0));
                    
                    // Store depth value
                    depthMap[depthIndex] = depthValue;
                    
                    // Store S-coordinate offsets (scaled by depth and intensity)
                    offsets[offsetIndex] = sCoord.x * depthValue * config.depthIntensity * 0.1; // Scale down for reasonable offsets
                    offsets[offsetIndex + 1] = sCoord.y * depthValue * config.depthIntensity * 0.1;
                }
            }
            
            return { offsets, depthMap };
        }

        function renderStereoFrames(imageData, config) {
            const { width, height } = imageData;
            
            // Calculate S-coordinate offsets and depth map
            const { offsets, depthMap } = calculateSCoordOffsetsOptimized(imageData, config);
            
            // Get canvas contexts
            const leftCtx = document.getElementById('leftCanvas').getContext('2d');
            const rightCtx = document.getElementById('rightCanvas').getContext('2d');
            
            // Create output image data for left and right views
            const leftImageData = new ImageData(width, height);
            const rightImageData = new ImageData(width, height);
            
            // Base separation from UI
            const separation = parseInt(document.getElementById('separation').value);
            
            // REVERSE MAPPING: For each destination pixel, find the source pixel
            for (let destY = 0; destY < height; destY++) {
                for (let destX = 0; destX < width; destX++) {
                    const destIndex = (destY * width + destX) * 4;
                    const offsetIndex = (destY * width + destX) * 2;
                    
                    // Get S-coordinate offsets for this destination pixel
                    const sOffsetX = offsets[offsetIndex];
                    const sOffsetY = offsets[offsetIndex + 1];
                    
                    // Get depth factor for this pixel
                    const depthFactor = depthMap[destY * width + destX];
                    
                    // Calculate stereo shifts based on depth and separation
                    const baseShift = separation * (depthFactor - 0.5); // Center around 0.5 depth
                    
                    // Calculate source coordinates for left and right eyes
                    // LEFT EYE: Sample from shifted position (convergent stereo)
                    const leftSourceX = destX + baseShift + sOffsetX;
                    const leftSourceY = destY + sOffsetY;
                    
                    // RIGHT EYE: Sample from opposite shifted position
                    const rightSourceX = destX - baseShift - sOffsetX;
                    const rightSourceY = destY - sOffsetY;
                    
                    // Sample pixels with bilinear interpolation
                    const leftPixel = sampleBilinear(imageData, leftSourceX, leftSourceY, width, height);
                    const rightPixel = sampleBilinear(imageData, rightSourceX, rightSourceY, width, height);
                    
                    // Set left eye pixel
                    leftImageData.data[destIndex] = leftPixel.r;
                    leftImageData.data[destIndex + 1] = leftPixel.g;
                    leftImageData.data[destIndex + 2] = leftPixel.b;
                    leftImageData.data[destIndex + 3] = leftPixel.a;
                    
                    // Set right eye pixel
                    rightImageData.data[destIndex] = rightPixel.r;
                    rightImageData.data[destIndex + 1] = rightPixel.g;
                    rightImageData.data[destIndex + 2] = rightPixel.b;
                    rightImageData.data[destIndex + 3] = rightPixel.a;
                }
            }
            
            // Render the final images
            leftCtx.putImageData(leftImageData, 0, 0);
            rightCtx.putImageData(rightImageData, 0, 0);
        }

        function createDepthMap(imageData, config) {
            const { width, height } = imageData;
            const depthData = new Uint8Array(width * height);
            
            // Try GPU acceleration if enabled
            if (document.getElementById('useGPU').checked && webGLProcessor.isInitialized) {
                const gpuDepth = webGLProcessor.processDepthMap(imageData, config);
                
                if (gpuDepth) {
                    // Extract just the first channel (all are the same in grayscale depth)
                    for (let i = 0; i < width * height; i++) {
                        depthData[i] = gpuDepth[i * 4];
                    }
                    return depthData;
                }
                // Fall back to CPU if GPU processing failed
            }
            
            // Use the optimized calculation that's already done in renderStereoFrames
            const { depthMap } = calculateSCoordOffsetsOptimized(imageData, config);
            
            // Convert to Uint8Array for display
            for (let i = 0; i < width * height; i++) {
                depthData[i] = Math.round(depthMap[i] * 255);
            }
            
            return depthData;
        }

        // ==================== APPLICATION INITIALIZATION ====================

        const webGLProcessor = new WebGLProcessor();

        let currentStream = null;
        let isProcessing = false;
        let animationFrameId = null;
        let fpsCounters = {
            left: { frames: 0, lastTime: 0, fps: 0 },
            right: { frames: 0, lastTime: 0, fps: 0 },
            depth: { frames: 0, lastTime: 0, fps: 0 }
        };

        let animationStates = {
            theta: false,
            phi: false,
            thetaDirection: 1,
            phiDirection: 1,
            thetaSpeed: 0.5,
            phiSpeed: 0.1
        };

        const processingConfig = {
            haditTheta: 0.0,
            haditPhi: 0.1,
            haditInfluence: 1.0,
            depthIntensity: 2.0,
            depthContrast: 0.2,
            luminosityWeight: 0.0,
            saturationWeight: 0.0,
            bandSizeMultiplier: 10.0,
            focusFactor: 4.0,
            sBounds: 20.0,
            separation: 8
        };

        function synchronizeControls() {
            const haditTheta = document.getElementById('haditTheta');
            const haditThetaNumber = document.getElementById('haditThetaNumber');
            const haditThetaValue = document.getElementById('haditThetaValue');
            
            function updateTheta(value) {
                const val = parseFloat(value);
                haditTheta.value = val;
                haditThetaNumber.value = val;
                haditThetaValue.textContent = val.toFixed(1) + '°';
                processingConfig.haditTheta = val;
            }
            
            haditTheta.addEventListener('input', (e) => updateTheta(e.target.value));
            haditThetaNumber.addEventListener('input', (e) => updateTheta(e.target.value));
            
            const haditPhi = document.getElementById('haditPhi');
            const haditPhiNumber = document.getElementById('haditPhiNumber');
            const haditPhiValue = document.getElementById('haditPhiValue');
            
            function updatePhi(value) {
                const val = Math.max(0.1, Math.min(179.9, parseFloat(value)));
                haditPhi.value = val;
                haditPhiNumber.value = val;
                haditPhiValue.textContent = val.toFixed(1) + '°';
                processingConfig.haditPhi = val;
            }
            
            haditPhi.addEventListener('input', (e) => updatePhi(e.target.value));
            haditPhiNumber.addEventListener('input', (e) => updatePhi(e.target.value));
            
            const controls = [
                { id: 'haditInfluence', config: 'haditInfluence', format: (v) => v.toFixed(1) },
                { id: 'separation', config: 'separation', format: (v) => v + 'px' },
                { id: 'depthIntensity', config: 'depthIntensity', format: (v) => v.toFixed(1) + 'x' },
                { id: 'depthContrast', config: 'depthContrast', format: (v) => v.toFixed(1) + 'x' },
                { id: 'sBounds', config: 'sBounds', format: (v) => '±' + v.toFixed(1) },
                { id: 'luminosityWeight', config: 'luminosityWeight', format: (v) => v.toFixed(2) },
                { id: 'saturationWeight', config: 'saturationWeight', format: (v) => v.toFixed(2) },
                { id: 'bandSizeMultiplier', config: 'bandSizeMultiplier', format: (v) => v.toFixed(1) + 'x' },
                { id: 'focusFactor', config: 'focusFactor', format: (v) => v.toFixed(1) + 'x' }
            ];
            
            controls.forEach(control => {
                const element = document.getElementById(control.id);
                const valueElement = document.getElementById(control.id + 'Value');
                
                element.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    processingConfig[control.config] = value;
                    if (valueElement) {
                        valueElement.textContent = control.format(value);
                    }
                });
                
                const initialValue = parseFloat(element.value);
                processingConfig[control.config] = initialValue;
                if (valueElement) {
                    valueElement.textContent = control.format(initialValue);
                }
            });
        }

        // ==================== CAMERA MANAGEMENT ====================

        async function startCamera() {
            try {
                document.getElementById('cameraStatus').innerHTML = 
                    '<span class="status-connecting">📹 Connecting to camera...</span>';
                
                const resolution = document.getElementById('resolutionSelect').value;
                const facingMode = document.getElementById('facingMode').value;
                const [width, height] = resolution.split('x').map(Number);
                
                const constraints = {
                    video: {
                        width: { ideal: width },
                        height: { ideal: height },
                        facingMode: { ideal: facingMode },
                        frameRate: { ideal: 30 }
                    }
                };
                
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                const videoElement = document.getElementById('debugVideo');
                videoElement.srcObject = currentStream;
                
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });
                
                document.getElementById('cameraStatus').innerHTML = 
                    '<span class="status-active">📹 Camera active - processing live feed</span>';
                document.getElementById('startCamera').style.display = 'none';
                document.getElementById('switchCamera').style.display = 'inline-block';
                document.getElementById('stopCamera').style.display = 'inline-block';
                document.getElementById('errorPanel').style.display = 'none';
                
                startProcessing();
                
            } catch (error) {
                console.error('Camera error:', error);
                showError(error.message);
            }
        }

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorPanel').style.display = 'block';
            document.getElementById('cameraStatus').innerHTML = 
                '<span class="status-error">❌ Camera connection failed</span>';
        }

        function stopCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            isProcessing = false;
            
            document.getElementById('cameraStatus').innerHTML = 
                '<span class="status-connecting">📹 Camera system ready - click Start Camera</span>';
            document.getElementById('startCamera').style.display = 'inline-block';
            document.getElementById('switchCamera').style.display = 'none';
            document.getElementById('stopCamera').style.display = 'none';
            document.getElementById('debugVideo').srcObject = null;
        }

        async function switchCamera() {
            const facingMode = document.getElementById('facingMode');
            facingMode.value = facingMode.value === 'user' ? 'environment' : 'user';
            
            if (currentStream) {
                stopCamera();
                await new Promise(resolve => setTimeout(resolve, 500));
                startCamera();
            }
        }

        async function requestPermissions() {
            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
                document.getElementById('infoPanel').innerHTML = 
                    '<div>✅ Camera permissions granted successfully!</div>';
            } catch (error) {
                showError('Permission denied: ' + error.message);
            }
        }

        // ==================== PROCESSING LOOP ====================

        function startProcessing() {
            if (isProcessing) return;
            
            isProcessing = true;
            const videoElement = document.getElementById('debugVideo');
            
            function processLoop() {
                if (!isProcessing || !currentStream) return;
                
                try {
                    updateAnimations();
                    processFrame(videoElement, processingConfig);
                    updateFPS();
                    updateAnalysisPanel();
                    
                } catch (error) {
                    console.error('Processing error:', error);
                }
                
                animationFrameId = requestAnimationFrame(processLoop);
            }
            
            processLoop();
        }

        function processFrame(videoElement, config) {
            const leftCanvas = document.getElementById('leftCanvas');
            const rightCanvas = document.getElementById('rightCanvas');
            const depthCanvas = document.getElementById('depthCanvas');
            
            const quality = parseFloat(document.getElementById('qualitySelect').value);
            
            const width = Math.round(videoElement.videoWidth * quality);
            const height = Math.round(videoElement.videoHeight * quality);
            
            if (leftCanvas.width !== width || leftCanvas.height !== height) {
                leftCanvas.width = rightCanvas.width = width;
                leftCanvas.height = rightCanvas.height = height;
                depthCanvas.width = width;
                depthCanvas.height = height;
            }
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Apply mirror if enabled
            if (document.getElementById('mirrorCamera').checked) {
                tempCtx.scale(-1, 1);
                tempCtx.translate(-width, 0);
            }
            
            tempCtx.drawImage(videoElement, 0, 0, width, height);
            const imageData = tempCtx.getImageData(0, 0, width, height);
            
            // Update config from current control values
            config.haditTheta = parseFloat(document.getElementById('haditTheta').value);
            config.haditPhi = parseFloat(document.getElementById('haditPhi').value);
            config.haditInfluence = parseFloat(document.getElementById('haditInfluence').value);
            config.depthIntensity = parseFloat(document.getElementById('depthIntensity').value);
            config.depthContrast = parseFloat(document.getElementById('depthContrast').value);
            config.luminosityWeight = parseFloat(document.getElementById('luminosityWeight').value);
            config.saturationWeight = parseFloat(document.getElementById('saturationWeight').value);
            
            // Render stereo frames with fixed implementation
            if (document.getElementById('enableStereo').checked) {
                renderStereoFrames(imageData, config);
            } else {
                // Just show the original image in both eyes
                const leftCtx = leftCanvas.getContext('2d');
                const rightCtx = rightCanvas.getContext('2d');
                leftCtx.putImageData(imageData, 0, 0);
                rightCtx.putImageData(imageData, 0, 0);
            }
            
            // Render depth map
            if (document.getElementById('showDepthMap').checked) {
                const depthData = createDepthMap(imageData, config);
                const depthImageData = new ImageData(width, height);
                
                // Convert depth data to visible image
                for (let i = 0; i < width * height; i++) {
                    const value = depthData[i];
                    const index = i * 4;
                    depthImageData.data[index] = value;
                    depthImageData.data[index + 1] = value;
                    depthImageData.data[index + 2] = value;
                    depthImageData.data[index + 3] = 255;
                }
                
                const depthCtx = depthCanvas.getContext('2d');
                depthCtx.putImageData(depthImageData, 0, 0);
            }
        }

        function updateAnimations() {
            if (animationStates.theta) {
                const currentTheta = parseFloat(document.getElementById('haditTheta').value);
                let newTheta = currentTheta + (animationStates.thetaSpeed * animationStates.thetaDirection);
                
                if (newTheta >= 360) {
                    newTheta = 0;
                } else if (newTheta < 0) {
                    newTheta = 359.9;
                }
                
                document.getElementById('haditTheta').value = newTheta;
                document.getElementById('haditThetaNumber').value = newTheta;
                document.getElementById('haditThetaValue').textContent = newTheta.toFixed(1) + '°';
                processingConfig.haditTheta = newTheta;
            }
            
            if (animationStates.phi) {
                const currentPhi = parseFloat(document.getElementById('haditPhi').value);
                let newPhi = currentPhi + (animationStates.phiSpeed * animationStates.phiDirection);
                
                if (newPhi >= 179.9) {
                    newPhi = 179.9;
                    animationStates.phiDirection = -1;
                } else if (newPhi <= 0.1) {
                    newPhi = 0.1;
                    animationStates.phiDirection = 1;
                }
                
                document.getElementById('haditPhi').value = newPhi;
                document.getElementById('haditPhiNumber').value = newPhi;
                document.getElementById('haditPhiValue').textContent = newPhi.toFixed(1) + '°';
                processingConfig.haditPhi = newPhi;
            }
        }

        function updateFPS() {
            const now = performance.now();
            
            ['left', 'right', 'depth'].forEach(type => {
                const counter = fpsCounters[type];
                counter.frames++;
                
                if (now - counter.lastTime >= 1000) {
                    counter.fps = Math.round((counter.frames * 1000) / (now - counter.lastTime));
                    counter.frames = 0;
                    counter.lastTime = now;
                    
                    const element = document.getElementById(type + 'Fps');
                    if (element && document.getElementById('showFPS').checked) {
                        element.textContent = counter.fps + ' FPS';
                        element.style.display = 'block';
                    } else if (element) {
                        element.style.display = 'none';
                    }
                }
            });
        }

        function updateAnalysisPanel() {
            if (!document.getElementById('debugMode').checked) return;
            
            const analysisPanel = document.getElementById('analysisPanel');
            const config = processingConfig;
            
            const analysisInfo = `
                <div style="color: #88ff00; font-weight: bold;">⚡ Live Hadit Band Analysis</div>
                <div>📐 Current Hadit Position:</div>
                <div>&nbsp;&nbsp;θ (Theta): ${config.haditTheta.toFixed(1)}°</div>
                <div>&nbsp;&nbsp;φ (Phi): ${config.haditPhi.toFixed(1)}°</div>
                <div>&nbsp;&nbsp;Influence: ${config.haditInfluence.toFixed(1)}x</div>
                <div>🎨 Depth Processing:</div>
                <div>&nbsp;&nbsp;Source: ${document.getElementById('depthSource').value}</div>
                <div>&nbsp;&nbsp;Intensity: ${config.depthIntensity.toFixed(1)}x</div>
                <div>&nbsp;&nbsp;Contrast: ${config.depthContrast.toFixed(1)}x</div>
                <div>👁️ Stereo Configuration:</div>
                <div>&nbsp;&nbsp;Separation: ${config.separation}px</div>
                <div>&nbsp;&nbsp;S-Bounds: ±${config.sBounds.toFixed(1)}</div>
                <div>⚙️ Performance:</div>
                <div>&nbsp;&nbsp;Left: ${fpsCounters.left.fps} FPS</div>
                <div>&nbsp;&nbsp;Right: ${fpsCounters.right.fps} FPS</div>
                <div>&nbsp;&nbsp;Depth: ${fpsCounters.depth.fps} FPS</div>
                <div>&nbsp;&nbsp;GPU: ${document.getElementById('useGPU').checked ? 'Enabled' : 'Disabled'}</div>
                <div>📡 Animation Status:</div>
                <div>&nbsp;&nbsp;θ Animation: ${animationStates.theta ? '🌀 Active' : '⏹️ Stopped'}</div>
                <div>&nbsp;&nbsp;φ Animation: ${animationStates.phi ? '🌊 Active' : '⏹️ Stopped'}</div>
                <div style="margin-top: 10px; color: #888; font-size: 9px;">
                    Last updated: ${new Date().toLocaleTimeString()}
                </div>
            `;
            
            analysisPanel.innerHTML = analysisInfo;
        }

        // ==================== EVENT LISTENERS ====================

        document.getElementById('startCamera').addEventListener('click', startCamera);
        document.getElementById('stopCamera').addEventListener('click', stopCamera);
        document.getElementById('switchCamera').addEventListener('click', switchCamera);
        document.getElementById('requestPermissions').addEventListener('click', requestPermissions);

        document.getElementById('toggleDebugVideo').addEventListener('click', () => {
            const debugVideo = document.getElementById('debugVideo');
            debugVideo.style.display = debugVideo.style.display === 'none' ? 'block' : 'none';
        });

        // Preset buttons
        document.getElementById('setHaditPole').addEventListener('click', () => {
            document.getElementById('haditPhi').value = 0.1;
            document.getElementById('haditPhiNumber').value = 0.1;
            document.getElementById('haditPhiValue').textContent = '0.1°';
            processingConfig.haditPhi = 0.1;
        });

        document.getElementById('setHaditEquator').addEventListener('click', () => {
            document.getElementById('haditPhi').value = 90.0;
            document.getElementById('haditPhiNumber').value = 90.0;
            document.getElementById('haditPhiValue').textContent = '90.0°';
            processingConfig.haditPhi = 90.0;
        });

        document.getElementById('setHaditNear180').addEventListener('click', () => {
            document.getElementById('haditPhi').value = 179.9;
            document.getElementById('haditPhiNumber').value = 179.9;
            document.getElementById('haditPhiValue').textContent = '179.9°';
            processingConfig.haditPhi = 179.9;
        });

        // Animation controls
        document.getElementById('animateTheta').addEventListener('click', () => {
            animationStates.theta = !animationStates.theta;
            document.getElementById('animateTheta').textContent = 
                animationStates.theta ? '⏸️ Pause θ' : '🌀 Animate θ';
        });

        document.getElementById('animatePhi').addEventListener('click', () => {
            animationStates.phi = !animationStates.phi;
            document.getElementById('animatePhi').textContent = 
                animationStates.phi ? '⏸️ Pause φ' : '🌊 Animate φ';
        });

        document.getElementById('stopAnimation').addEventListener('click', () => {
            animationStates.theta = false;
            animationStates.phi = false;
            document.getElementById('animateTheta').textContent = '🌀 Animate θ';
            document.getElementById('animatePhi').textContent = '🌊 Animate φ';
        });

        // Depth presets
        document.getElementById('setHighContrast').addEventListener('click', () => {
            document.getElementById('depthContrast').value = 2.5;
            document.getElementById('depthContrastValue').textContent = '2.5x';
            processingConfig.depthContrast = 2.5;
        });

        document.getElementById('setLowContrast').addEventListener('click', () => {
            document.getElementById('depthContrast').value = 0.1;
            document.getElementById('depthContrastValue').textContent = '0.1x';
            processingConfig.depthContrast = 0.1;
        });

        document.getElementById('setExtremeDepth').addEventListener('click', () => {
            document.getElementById('depthIntensity').value = 5.0;
            document.getElementById('depthIntensityValue').textContent = '5.0x';
            processingConfig.depthIntensity = 5.0;
        });

        document.getElementById('setSubtleDepth').addEventListener('click', () => {
            document.getElementById('depthIntensity').value = 0.5;
            document.getElementById('depthIntensityValue').textContent = '0.5x';
            processingConfig.depthIntensity = 0.5;
        });

        // Band detection actions
        document.getElementById('detectBand').addEventListener('click', () => {
            document.getElementById('infoPanel').innerHTML = 
                '<div>🔍 Auto-detecting optimal band parameters...</div>';
        });

        document.getElementById('expandBandFull').addEventListener('click', () => {
            document.getElementById('bandSizeMultiplier').value = 10.0;
            document.getElementById('bandSizeMultiplierValue').textContent = '10.0x';
            processingConfig.bandSizeMultiplier = 10.0;
        });

        document.getElementById('resetBand').addEventListener('click', () => {
            document.getElementById('bandSizeMultiplier').value = 1.0;
            document.getElementById('bandSizeMultiplierValue').textContent = '1.0x';
            document.getElementById('focusFactor').value = 1.0;
            document.getElementById('focusFactorValue').textContent = '1.0x';
            processingConfig.bandSizeMultiplier = 1.0;
            processingConfig.focusFactor = 1.0;
        });

        // GPU checkbox handler
        document.getElementById('useGPU').addEventListener('change', async function() {
            if (this.checked) {
                document.getElementById('gpuStatus').style.display = 'block';
                const success = await webGLProcessor.initialize();
                if (success) {
                    document.getElementById('gpuStereoMode').disabled = false;
                } else {
                    this.checked = false;
                    document.getElementById('gpuStereoMode').disabled = true;
                }
            } else {
                document.getElementById('gpuStatus').style.display = 'none';
                document.getElementById('gpuStereoMode').disabled = true;
            }
        });

        // Show/hide debug video based on checkbox
        document.getElementById('showRawFeed').addEventListener('change', function() {
            const debugVideo = document.getElementById('debugVideo');
            debugVideo.style.display = this.checked ? 'block' : 'none';
        });

        // ==================== INITIALIZATION ====================

        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize control synchronization
            synchronizeControls();
            
            // Check WebGL support on page load
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                
                const gpuStatus = document.getElementById('gpuStatus');
                const gpuStatusText = document.getElementById('gpuStatusText');
                
                if (gl) {
                    gpuStatus.style.display = 'block';
                    gpuStatusText.textContent = 'WebGL available. Enable GPU for acceleration.';
                } else {
                    gpuStatus.style.display = 'block';
                    gpuStatusText.textContent = 'WebGL not supported on this device.';
                }
            } catch (e) {
                console.warn('WebGL check failed:', e);
            }
            
            // Update info panel with current status
            document.getElementById('infoPanel').innerHTML = 
                '<div>Status: Complete Live Hadit camera system ready... Angledcrystals | 2025-06-08 10:13:58 UTC</div>';
                
            // Set initial analysis panel content
            document.getElementById('analysisPanel').innerHTML = `
                <div style="color: #88ff00; font-weight: bold;">⚡ Live Hadit Band Analysis</div>
                <div>Ready for live camera processing with band detection...</div>
                <div>Camera permissions status: checking...</div>
                <div>WebGL GPU acceleration: ${document.getElementById('useGPU').checked ? 'enabled' : 'disabled'}</div>
                <div>S-coordinate offsets: fully implemented with bilinear interpolation</div>
                <div>Depth sources: brightness, S-magnitude, radial, angular</div>
                <div>Stereo rendering: reverse mapping with proper hole filling</div>
                <div>Black crack fix: applied bilinear sampling</div>
                <div style="margin-top: 10px; color: #888; font-size: 9px;">
                    System initialized: ${new Date().toLocaleTimeString()}
                </div>
            `;
        });

        // ==================== UTILITY FUNCTIONS ====================

        // Add keyboard shortcuts for common operations
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 's':
                        e.preventDefault();
                        if (currentStream) {
                            stopCamera();
                        } else {
                            startCamera();
                        }
                        break;
                    case 'r':
                        e.preventDefault();
                        if (currentStream) {
                            switchCamera();
                        }
                        break;
                    case 'g':
                        e.preventDefault();
                        document.getElementById('useGPU').click();
                        break;
                }
            }
        });

        // Handle window resize to adjust canvas scaling
        window.addEventListener('resize', () => {
            // Force canvas redraw on resize
            if (isProcessing) {
                const canvases = ['leftCanvas', 'rightCanvas', 'depthCanvas'];
                canvases.forEach(id => {
                    const canvas = document.getElementById(id);
                    canvas.style.width = '';
                    canvas.style.height = '';
                });
            }
        });

        // Export configuration for debugging
        window.exportConfig = () => {
            const config = {
                ...processingConfig,
                depthSource: document.getElementById('depthSource').value,
                quality: document.getElementById('qualitySelect').value,
                enableStereo: document.getElementById('enableStereo').checked,
                showDepthMap: document.getElementById('showDepthMap').checked,
                useGPU: document.getElementById('useGPU').checked,
                timestamp: new Date().toISOString()
            };
            
            console.log('Current AndroidVR Configuration:', JSON.stringify(config, null, 2));
            return config;
        };

        // Import configuration for debugging
        window.importConfig = (config) => {
            if (typeof config === 'string') {
                config = JSON.parse(config);
            }
            
            Object.keys(config).forEach(key => {
                if (processingConfig.hasOwnProperty(key)) {
                    processingConfig[key] = config[key];
                    
                    const element = document.getElementById(key);
                    const valueElement = document.getElementById(key + 'Value');
                    
                    if (element) {
                        element.value = config[key];
                        if (valueElement) {
                            if (key.includes('Weight')) {
                                valueElement.textContent = config[key].toFixed(2);
                            } else if (key === 'separation') {
                                valueElement.textContent = config[key] + 'px';
                            } else if (key.includes('sBounds')) {
                                valueElement.textContent = '±' + config[key].toFixed(1);
                            } else {
                                valueElement.textContent = config[key].toFixed(1) + (key.includes('Theta') || key.includes('Phi') ? '°' : 'x');
                            }
                        }
                    }
                }
            });
            
            console.log('Configuration imported successfully');
        };

    </script>
</body>
</html>
