<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>AndroidVR - Hadit S-Coordinate Depth Detection</title>
    <style>
        /* All existing styles unchanged */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }

        /* Canvas container takes all available space */
        .container {
            flex: 1;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            width: 100vw;
            perspective: 1000px;
            overflow: hidden;
            padding-top: 10px; /* Space from top */
            position: relative; /* For absolute positioning in flicker mode */
        }

        /* Canvas will maintain camera aspect ratio */
        canvas {
            border: 2px solid white;
            border-radius: 10px;
            transform-origin: center;
            transition: transform 0.2s ease;
            margin: 0 4px;
            height: auto; /* Auto height based on container */
            position: relative; /* For flicker mode */
            will-change: transform, left, right; /* Hint for GPU acceleration */
        }

        /* Hardware acceleration hints */
        canvas, video {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
            will-change: transform;
        }

        /* Prevent unnecessary repaints */
        body, .container, .control-panel {
            will-change: transform;
        }

        /* Control panel at the bottom */
        .control-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            padding: 5px 5px;
            z-index: 1000;
        }

        /* Control rows */
        .control-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 3px; /* Reduced margin */
        }

        /* Control sections */
        .control-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 5px;
        }

        /* Control section headers */
        .section-header {
            font-size: 0.7rem; /* Smaller font */
            text-transform: uppercase;
            margin-bottom: 1px;
            color: #ccc;
        }

        /* Control elements */
        .control-item {
            display: flex;
            align-items: center;
            margin: 1px 0; /* Reduced margin */
        }

        label {
            font-size: 0.7rem; /* Smaller font */
            margin-right: 5px;
            min-width: 45px;
        }

        input[type="range"] {
            width: 70px;
            height: 12px; /* Thinner sliders */
        }

        select {
            width: 70px;
            font-size: 0.7rem;
            background: #333;
            color: white;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 1px;
        }

        button {
            margin: 2px; /* Reduced margin */
            padding: 5px 8px; /* Smaller padding */
            font-size: 0.75rem; /* Smaller font */
            border: none;
            border-radius: 5px;
            background-color: #444;
            color: white;
            cursor: pointer;
        }

        button:hover {
            background-color: #666;
        }

        .divider {
            width: 1px;
            height: 35px; /* Shorter divider */
            background-color: #444;
            margin: 0 2px;
        }

        /* Top controls container */
        .top-controls {
            position: fixed;
            top: 5px;
            right: 5px;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Toggle button to hide/show controls - REPOSITIONED */
        #toggleControls {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #333;
        }

        #toggleControls:hover {
            opacity: 1;
        }

        /* Quality selector */
        #qualitySelect {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 5px;
        }

        #qualitySelect:hover {
            opacity: 1;
        }

        /* Quality indicator */
        #qualityIndicator {
            position: fixed;
            top: 40px;
            right: 5px;
            font-size: 0.65rem;
            color: #aaa;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Flicker indicator */
        #flickerIndicator {
            position: fixed;
            top: 70px;
            right: 5px;
            font-size: 0.65rem;
            color: #f55;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Hadit indicator */
        #haditIndicator {
            position: fixed;
            top: 100px;
            right: 5px;
            font-size: 0.65rem;
            color: #ff00ff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 1;
            transition: opacity 0.3s;
        }

        /* Debug output */
        #debugOutput {
            position: fixed;
            top: 5px;
            left: 5px;
            font-size: 0.65rem;
            color: #aaa;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            max-width: 50%;
            max-height: 200px;
            overflow: auto;
        }

        /* Value display spans */
        .value-display {
            font-size: 0.6rem;
            color: #aaa;
            margin-left: 5px;
            min-width: 30px;
        }

        /* Hadit controls */
        .hadit-control {
            background-color: #2a0a2a !important;
            border: 1px solid #ff00ff !important;
        }

        /* Depth map display */
        #depthMapDisplay {
            position: fixed;
            top: 150px;
            left: 5px;
            width: 200px;
            height: 133px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            z-index: 1002;
            opacity: 0.9;
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
        }

        #depthMapDisplay canvas {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 3px;
        }

        #depthMapLabel {
            position: absolute;
            top: -20px;
            left: 0;
            font-size: 0.6rem;
            color: #00ff00;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1px 5px;
            border-radius: 3px;
        }

        /* Toggle depth map button */
        #toggleDepthMap {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #003300;
            border: 1px solid #00ff00;
            color: #00ff00;
            border-radius: 5px;
        }

        #toggleDepthMap:hover {
            opacity: 1;
            background-color: #005500;
        }

        #toggleDepthMap.active {
            background-color: #007700;
            opacity: 1;
        }

        /* Flicker mode specific styles - for position swapping */
        .flicker-active .container {
            position: relative;
        }
        
        .flicker-active canvas {
            position: absolute;
            transition: none; /* Disable transitions for flicker mode */
        }
        
        .canvas-left {
            left: calc(50% - 50% - 60px) !important;
            right: auto !important;
        }
        
        .canvas-right {
            left: calc(50% + 60px) !important;
            right: auto !important;
        }
        
        /* Frozen frame styles */
        .frozen-canvas {
            border-color: #ff4040 !important;
            box-shadow: 0 0 10px rgba(255, 64, 64, 0.7);
        }

        /* Additional styles to ensure everything else works correctly */
        /* Portrait mode warning */
        @media (orientation: portrait) {
            body::before {
                content: "Please rotate your device to landscape mode.";
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-size: 1.5rem;
                text-align: center;
                z-index: 1000;
            }

            .container, .control-panel, .top-controls, #qualityIndicator {
                display: none;
            }
        }

        /* Recording Controls */
        .recording-controls {
            display: flex;
            align-items: center;
            margin-right: 5px;
        }

        .record-button {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: #333;
            border: none;
            color: white;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .record-icon {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ff4040;
            display: inline-block;
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ff4040;
            margin-right: 5px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.8);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(0.8);
                opacity: 0.8;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas1"></canvas>
        <canvas id="canvas2"></canvas>
        <!-- Freeze countdown display -->
        <div id="freezeCountdown" style="display: none; position: absolute; background-color: rgba(255, 0, 0, 0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 1.2rem; font-weight: bold; z-index: 1000;">
            Freezing in <span id="countdownValue">3</span>
        </div>
    </div>
    
    <!-- Depth Map Display -->
    <div id="depthMapDisplay">
        <div id="depthMapLabel">Hadit Depth Map</div>
        <canvas id="depthMapCanvas"></canvas>
    </div>
    
    <div class="top-controls">
        <div class="recording-controls">
            <button id="recordButton" class="record-button">
                <span class="record-icon"></span> Record
            </button>
            <button id="stopRecordButton" class="record-button stop-record" style="display:none">
                <span class="stop-icon"></span> Stop
            </button>
            <div id="recordingIndicator" class="recording-indicator" style="display:none">
                <span class="pulse-dot"></span>
                <span id="recordingTimer">00:00</span>
            </div>
        </div>
        <button id="toggleDepthMap">Show Depth</button>
        <select id="qualitySelect">
            <option value="1.0">High Quality</option>
            <option value="0.5" selected>Medium Quality</option>
            <option value="0.25">Low Quality</option>
            <option value="0.1">Very Low Quality</option>
        </select>
        <button id="toggleControls">Hide Controls</button>
    </div>
    
    <div id="qualityIndicator">Processing at 50% resolution</div>
    <div id="flickerIndicator">3D Flicker Mode Active</div>
    <div id="haditIndicator">Hadit: φ=0.1° θ=0.0° Focus=4.3x</div>
    <div id="debugOutput" style="display: none;"></div>
    
    <div class="control-panel" id="controlPanel">
        <div class="control-row">
            <div class="control-section">
                <div class="section-header">Camera</div>
                <div class="control-item">
                    <button id="startButton">Start Camera</button>
                    <button id="switchButton">Switch Camera</button>
                </div>
                <div class="control-item">
                    <button id="freezeButton">Freeze Frame</button>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">View</div>
                <div class="control-item">
                    <label for="tiltSlider">Tilt</label>
                    <input id="tiltSlider" type="range" min="0" max="0.7" step="0.01" value="0">
                </div>
                <div class="control-item">
                    <label for="sizeSlider">Size</label>
                    <input id="sizeSlider" type="range" min="0.2" max="1.8" step="0.05" value="1.0">
                </div>
                <div class="control-item">
                    <button id="toggleFlickerMode">Enable 3D Flicker</button>
                </div>
                <div class="control-item" id="flickerSpeedContainer" style="display: none;">
                    <label for="flickerSpeedSlider">Speed</label>
                    <input id="flickerSpeedSlider" type="range" min="8" max="60" step="1" value="16">
                </div>
                <div class="control-item">
                    <label for="freezeDelayToggle">Freeze Delay</label>
                    <input id="freezeDelayToggle" type="checkbox">
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">⚡ Hadit S-Coordinate Depth</div>
                <div class="control-item">
                    <label for="haditTheta">θ (Theta)</label>
                    <input id="haditTheta" type="range" min="0" max="360" step="0.1" value="0.0" class="hadit-control">
                    <span id="haditThetaValue" class="value-display">0.0°</span>
                </div>
                <div class="control-item">
                    <label for="haditPhi">φ (Phi)</label>
                    <input id="haditPhi" type="range" min="0.1" max="179.9" step="0.1" value="0.1" class="hadit-control">
                    <span id="haditPhiValue" class="value-display">0.1°</span>
                </div>
                <div class="control-item">
                    <label for="haditInfluence">Influence</label>
                    <input id="haditInfluence" type="range" min="0" max="2" step="0.1" value="1.0" class="hadit-control">
                    <span id="haditInfluenceValue" class="value-display">1.0</span>
                </div>
                <div class="control-item">
                    <label for="focusFactor">Focus</label>
                    <input id="focusFactor" type="range" min="1.0" max="10.0" step="0.1" value="4.3" class="hadit-control">
                    <span id="focusFactorValue" class="value-display">4.3x</span>
                </div>
                <div class="control-item">
                    <label for="bandSizeMultiplier">Band Size</label>
                    <input id="bandSizeMultiplier" type="range" min="0.1" max="10.0" step="0.1" value="10.0" class="hadit-control">
                    <span id="bandSizeMultiplierValue" class="value-display">10.0x</span>
                </div>
                <div class="control-item">
                    <label for="bandMode">Band Mode</label>
                    <select id="bandMode" class="hadit-control">
                        <option value="full_image" selected>Full Image</option>
                        <option value="auto_detect">Auto Detect</option>
                        <option value="content_analysis">Content Analysis</option>
                        <option value="manual_range">Manual Range</option>
                    </select>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Enhanced Nuit Depth</div>
                <div class="control-item">
                    <label for="depthMode">Mode</label>
                    <select id="depthMode">
                        <option value="hadit_scoord" selected>Hadit S-Coord</option>
                        <option value="nuit">Nuit Only</option>
                        <option value="radial">Radial Zones</option>
                        <option value="hybrid">Hybrid</option>
                        <option value="sum_xy">Sum XY S-Coords</option>
                        <option value="vectorfield">Vector Field</option>
                    </select>
                </div>
                <div class="control-item">
                    <label for="nuitRadius">Nuit Radius</label>
                    <input id="nuitRadius" type="range" min="0.5" max="15.0" step="0.1" value="7.0">
                    <span id="nuitRadiusValue" class="value-display">7.0</span>
                </div>
                <div class="control-item">
                    <label for="sBounds">S Bounds</label>
                    <input id="sBounds" type="range" min="1.0" max="50.0" step="0.1" value="20.0">
                    <span id="sBoundsValue" class="value-display">±20.0</span>
                </div>
                <div class="control-item">
                    <label for="depthIntensity">Intensity</label>
                    <input id="depthIntensity" type="range" min="0" max="50" step="1" value="15">
                </div>
                <div class="control-item">
                    <label for="baselineSeparation">Eye Sep</label>
                    <input id="baselineSeparation" type="range" min="0.5" max="8.0" step="0.1" value="3.0">
                    <span id="baselineSeparationValue" class="value-display">3.0%</span>
                </div>
                <div class="control-item">
                    <label for="blurRadius">Blur</label>
                    <input id="blurRadius" type="range" min="0" max="10" step="1" value="1">
                </div>
                <div class="control-item">
                    <label for="nuitFalloffFactor">Falloff</label>
                    <input id="nuitFalloffFactor" type="range" min="1" max="20" step="0.5" value="5.0">
                </div>
                <div class="control-item">
                    <label for="depthQuantize">Quantize</label>
                    <input id="depthQuantizeToggle" type="checkbox">
                </div>
                <div class="control-item">
                    <label for="depthLevels">Levels</label>
                    <input id="depthLevels" type="range" min="2" max="16" step="1" value="8">
                </div>
            </div>
        </div>
        
        <div class="control-row">
            <div class="control-section">
                <div class="section-header">S-Coordinate Mapping</div>
                <div class="control-item">
                    <label for="luminosityWeight">Luminosity</label>
                    <input id="luminosityWeight" type="range" min="0" max="1" step="0.05" value="0.0">
                    <span id="luminosityWeightValue" class="value-display">0.0</span>
                </div>
                <div class="control-item">
                    <label for="saturationWeight">Saturation</label>
                    <input id="saturationWeight" type="range" min="0" max="1" step="0.05" value="0.0">
                    <span id="saturationWeightValue" class="value-display">0.0</span>
                </div>
                <div class="control-item">
                    <label for="depthContrast">Contrast</label>
                    <input id="depthContrast" type="range" min="0.1" max="3.0" step="0.1" value="0.2">
                    <span id="depthContrastValue" class="value-display">0.2x</span>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Left Color</div>
                <div class="control-item">
                    <label for="redSlider1">Red</label>
                    <input id="redSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="greenSlider1">Green</label>
                    <input id="greenSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="blueSlider1">Blue</label>
                    <input id="blueSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Right Color</div>
                <div class="control-item">
                    <label for="redSlider2">Red</label>
                    <input id="redSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="greenSlider2">Green</label>
                    <input id="greenSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="blueSlider2">Blue</label>
                    <input id="blueSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Current Date and Time (UTC - YYYY-MM-DD HH:MM:SS formatted): 2025-06-07 03:10:54
        // Current User's Login: Angledcrystals

        // ==================== HADIT MATHEMATICS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            // Handle edge cases for phi
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function calculateHaditSCoordinate(px, py, width, height, lum, sat, haditTheta, haditPhi, haditInfluence, lumMapWeight, satMapWeight) {
            // Convert pixel to spherical coordinates
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            // Apply Hadit transformation
            const hadit_3d = sphericalToCartesian(haditTheta, haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            // Apply content modulation (if enabled)
            const contentModulation = (1 + lum * lumMapWeight + sat * satMapWeight);
            
            const S_modulated = {
                x: S_hadit.x * contentModulation * haditInfluence,
                y: S_hadit.y * contentModulation * haditInfluence
            };
            
            const sMagnitude = Math.sqrt(S_modulated.x * S_modulated.x + S_modulated.y * S_modulated.y);
            
            return {
                sCoord: S_modulated,
                sMagnitude: sMagnitude,
                originalG: G_3d,
                reflectedG: G_reflected,
                haditVector: hadit_3d,
                contentModulation: contentModulation,
                luminance: lum,
                saturation: sat
            };
        }

        function detectHaditInformationBand(imageData, config) {
            const { width, height, data } = imageData;
            const bandMode = config.bandMode || 'full_image';
            const bandSizeMultiplier = config.bandSizeMultiplier || 10.0;
            
            if (bandMode === 'full_image') {
                const bandWidth = config.sBounds * 10 * bandSizeMultiplier;
                return {
                    min: 0,
                    max: bandWidth,
                    center: bandWidth / 2,
                    width: bandWidth,
                    confidence: 1.0
                };
            }
            
            // For other modes, implement detection with band size multiplier
            const sMagnitudeHistogram = new Array(100).fill(0);
            const maxSMagnitude = config.sBounds * 2;
            
            // Sample pixels for band detection
            const sampleStep = Math.max(1, Math.floor(Math.min(width, height) / 50));
            
            for (let y = 0; y < height; y += sampleStep) {
                for (let x = 0; x < width; x += sampleStep) {
                    const pixelIdx = (y * width + x) * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const result = calculateHaditSCoordinate(x, y, width, height, lum, sat, 
                        config.haditTheta, config.haditPhi, config.haditInfluence, 
                        config.luminosityWeight, config.saturationWeight);
                    
                    const binIndex = Math.floor((result.sMagnitude / maxSMagnitude) * (sMagnitudeHistogram.length - 1));
                    if (binIndex >= 0 && binIndex < sMagnitudeHistogram.length) {
                        sMagnitudeHistogram[binIndex]++;
                    }
                }
            }
            
            // Find peak in histogram for auto detection
            let maxBin = 0;
            let maxCount = 0;
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                if (sMagnitudeHistogram[i] > maxCount) {
                    maxCount = sMagnitudeHistogram[i];
                    maxBin = i;
                }
            }
            
            const centerS = (maxBin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const baseBandWidth = maxSMagnitude * 0.3; // Base 30% of range
            const bandWidth = baseBandWidth * bandSizeMultiplier; // Apply multiplier
            
            return {
                min: Math.max(0, centerS - bandWidth / 2),
                max: centerS + bandWidth / 2,
                center: centerS,
                width: bandWidth,
                confidence: maxCount / (width * height / (sampleStep * sampleStep))
            };
        }

        function calculateHaditDepth(sResult, detectedBand, focusFactor, depthContrast) {
            const { sMagnitude } = sResult;
            
            // Check if pixel is in detected band
            const isInBand = sMagnitude >= detectedBand.min && sMagnitude <= detectedBand.max;
            
            let depth;
            
            if (detectedBand.width > 0) {
                // Band-relative depth calculation
                const bandPosition = Math.max(0, Math.min(1, (sMagnitude - detectedBand.min) / detectedBand.width));
                depth = 0.2 + bandPosition * 0.8; // Range: 0.2 to 1.0
            } else {
                // Fallback: magnitude-based depth
                const maxS = currentSBounds * 2;
                depth = 0.2 + Math.min(1.0, sMagnitude / maxS) * 0.8;
            }
            
            // Apply focus factor for in-band pixels
            if (isInBand && focusFactor > 1.0) {
                depth = 0.5 + (depth - 0.5) * focusFactor;
            }
            
            // Apply depth contrast
            depth = Math.pow(Math.max(0.01, depth), 1.0 / depthContrast);
            
            return {
                depth: Math.min(1.0, Math.max(0.01, depth)),
                isInBand: isInBand,
                sMagnitude: sMagnitude,
                sCoord: sResult.sCoord
            };
        }

        // ==================== DEPTH MAP IMPLEMENTATION ====================
        
        // Convert depth value to color
        function depthToColor(depth) {
            // Heat map gradient: blue (far) to green to red (near)
            if (depth < 0.33) {
                // Blue to green (far)
                const t = depth * 3;
                return {
                    r: 0,
                    g: Math.floor(255 * t),
                    b: Math.floor(255 * (1 - t))
                };
            } else if (depth < 0.66) {
                // Green to yellow
                const t = (depth - 0.33) * 3;
                return {
                    r: Math.floor(255 * t),
                    g: 255,
                    b: 0
                };
            } else {
                // Yellow to red (near)
                const t = (depth - 0.66) * 3;
                return {
                    r: 255,
                    g: Math.floor(255 * (1 - t)),
                    b: 0
                };
            }
        }
        
        // Generate depth map from current frame
        function generateDepthMapFromCurrentFrame() {
            if (!depthMapVisible || !video || video.readyState < 2) return;
            
            // Create temporary canvas for video frame
            const tempCanvas = document.createElement('canvas');
            const tempWidth = Math.round(video.videoWidth * 0.25);
            const tempHeight = Math.round(video.videoHeight * 0.25);
            tempCanvas.width = tempWidth;
            tempCanvas.height = tempHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0, tempWidth, tempHeight);
            
            // Get image data from the temp canvas
            const imageData = tempCtx.getImageData(0, 0, tempWidth, tempHeight);
            
            // Now get the actual depth map canvas
            const depthMapCanvas = document.getElementById('depthMapCanvas');
            if (!depthMapCanvas) return;
            
            // Set dimensions for depth map canvas
            depthMapCanvas.width = tempWidth;
            depthMapCanvas.height = tempHeight;
            const depthCtx = depthMapCanvas.getContext('2d');
            
            // Create our depth image data
            const depthImageData = depthCtx.createImageData(tempWidth, tempHeight);
            
            // Configure Hadit parameters - FIXED HARD-CODED VALUES
            const haditConfig = {
                haditTheta: 0.0,
                haditPhi: 0.1,
                haditInfluence: parseFloat(document.getElementById('haditInfluence').value),
                focusFactor: parseFloat(document.getElementById('focusFactor').value),
                bandMode: 'full_image',
                bandSizeMultiplier: 10.0,
                luminosityWeight: 0.0,
                saturationWeight: 0.0,
                depthContrast: 0.2,
                sBounds: 20.0
            };
            
            // Update UI to match our fixed settings
            document.getElementById('haditTheta').value = haditConfig.haditTheta;
            document.getElementById('haditThetaValue').textContent = haditConfig.haditTheta.toFixed(1) + '°';
            document.getElementById('haditPhi').value = haditConfig.haditPhi; 
            document.getElementById('haditPhiValue').textContent = haditConfig.haditPhi.toFixed(1) + '°';
            document.getElementById('luminosityWeight').value = haditConfig.luminosityWeight;
            document.getElementById('luminosityWeightValue').textContent = haditConfig.luminosityWeight.toFixed(1);
            document.getElementById('saturationWeight').value = haditConfig.saturationWeight;
            document.getElementById('saturationWeightValue').textContent = haditConfig.saturationWeight.toFixed(1);
            document.getElementById('sBounds').value = haditConfig.sBounds;
            document.getElementById('sBoundsValue').textContent = '±' + haditConfig.sBounds.toFixed(1);
            document.getElementById('bandSizeMultiplier').value = haditConfig.bandSizeMultiplier;
            document.getElementById('bandSizeMultiplierValue').textContent = haditConfig.bandSizeMultiplier.toFixed(1) + 'x';
            document.getElementById('depthContrast').value = haditConfig.depthContrast;
            document.getElementById('depthContrastValue').textContent = haditConfig.depthContrast.toFixed(1) + 'x';
            document.getElementById('bandMode').value = haditConfig.bandMode;
            
            // Update the Hadit indicator
            document.getElementById('haditIndicator').textContent = `Hadit: φ=${haditConfig.haditPhi.toFixed(1)}° θ=${haditConfig.haditTheta.toFixed(1)}° Focus=${haditConfig.focusFactor.toFixed(1)}x`;
            
            // Detect the band
            const band = detectHaditInformationBand(imageData, haditConfig);
            currentSBounds = haditConfig.sBounds; // Update global variable
            detectedBand = band; // Store for stereo view generation
            
            // Process each pixel for depth
            for (let y = 0; y < tempHeight; y++) {
                for (let x = 0; x < tempWidth; x++) {
                    const pixelIdx = (y * tempWidth + x) * 4;
                    
                    // Extract RGB values
                    const r = imageData.data[pixelIdx] / 255;
                    const g = imageData.data[pixelIdx + 1] / 255;
                    const b = imageData.data[pixelIdx + 2] / 255;
                    
                    // Calculate luminance and saturation
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    // Calculate Hadit S-Coordinate
                    const result = calculateHaditSCoordinate(
                        x, y, tempWidth, tempHeight, lum, sat,
                        haditConfig.haditTheta, haditConfig.haditPhi,
                        haditConfig.haditInfluence,
                        haditConfig.luminosityWeight,
                        haditConfig.saturationWeight
                    );
                    
                    // Calculate depth
                    const depthResult = calculateHaditDepth(
                        result, band, haditConfig.focusFactor, haditConfig.depthContrast
                    );
                    
                    // Convert depth to color
                    const depthColor = depthToColor(depthResult.depth);
                    
                    // Set pixel in depth map
                    depthImageData.data[pixelIdx] = depthColor.r;
                    depthImageData.data[pixelIdx + 1] = depthColor.g;
                    depthImageData.data[pixelIdx + 2] = depthColor.b;
                    depthImageData.data[pixelIdx + 3] = 255;
                }
            }
            
            // Put the depth map to the canvas
            depthCtx.putImageData(depthImageData, 0, 0);
            latestDepthMap = depthImageData;
        }

        // Utility function for debugging
        function debugLog(message) {
            console.log(message);
            const debugOutput = document.getElementById('debugOutput');
            if (debugOutput && debugOutput.style.display !== 'none') {
                debugOutput.innerHTML += message + '<br>';
                debugOutput.scrollTop = debugOutput.scrollHeight;
            }
        }

        // Browser detection
        const isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isMobile = isAndroid || isIOS;
        
        // Log useful browser information
        debugLog("Hadit AndroidVR - Current Date and Time (UTC): 2025-06-07 03:10:54");
        debugLog("Current User Login: Angledcrystals");
        debugLog("Browser Detection:");
        debugLog("- Firefox: " + isFirefox);
        debugLog("- Android: " + isAndroid);
        debugLog("- iOS: " + isIOS);
        debugLog("- Mobile: " + isMobile);
        debugLog("- User Agent: " + navigator.userAgent);
        
        // App state variables
        let currentStream = null;
        let video = null;
        let useFrontCamera = false;
        let controlsHidden = false;
        let qualityFactor = 0.5; // Default medium quality
        let lastFrameTime = 0;
        const targetFPS = 30;
        const frameInterval = 1000 / targetFPS;
        let isFrozen = false;
        
        // Depth map display state
        let depthMapVisible = false;
        let latestDepthMap = null;
        let detectedBand = null;
        
        // Hadit configuration with specified values
        let haditConfig = {
            haditTheta: 0.0,
            haditPhi: 0.1,
            haditInfluence: 1.0,
            focusFactor: 4.3,
            bandMode: 'full_image',
            bandSizeMultiplier: 10.0,
            luminosityWeight: 0.0,
            saturationWeight: 0.0,
            depthContrast: 0.2,
            sBounds: 20.0
        };
        
        // Dynamic Nuit Distance Method Parameters
        let currentNuitRadius = 7.0;
        let currentSBounds = 20.0; // Updated to match your settings
        
        // Improved camera tracking
        let detectedCameras = {
            front: null,
            back: null,
            current: null,
            all: []
        };
        
        // Window size variables
        let canvasSizeFactor = 1.0; // Default canvas size factor
        
        // Variables for flicker mode
        let flickerMode = false;
        let flickerFrame = 0; // 0 = normal, 1 = swapped
        let flickerInterval = null;
        let flickerSpeed = 16; // milliseconds (about 60fps)
        let originalCanvasPositions = {
            canvas1: { left: 0, margin: 0, transform: '' },
            canvas2: { left: 0, margin: 0, transform: '' }
        };
        
        // Method indicator - we'll determine the right method based on device capabilities
        let renderMethod = 'canvas2d'; // Start with standard canvas, will try to upgrade to WebGL
        
        // Canvas setup
        let processingCanvas = document.createElement('canvas');
        let processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });
        
        // Initialize the video element
        function initVideo() {
            video = document.createElement('video');
            video.setAttribute('playsinline', '');
            video.setAttribute('autoplay', '');
            video.setAttribute('muted', '');
            video.style.width = '100%';
            video.style.height = '100%';
            video.style.display = 'none';
            document.body.appendChild(video);
        }
        
        // Start camera
        async function startCamera() {
            const startButton = document.getElementById('startButton');
            if (!startButton) return;
            
            startButton.disabled = true;
            startButton.textContent = "Starting...";
            
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("Camera API not supported in this browser");
                }
                
                // Initialize video element if not already
                if (!video) initVideo();
                
                // List available devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoCameras = devices.filter(device => device.kind === 'videoinput');
                
                debugLog(`Found ${videoCameras.length} camera(s)`);
                detectedCameras.all = videoCameras;
                
                // Try to identify front and back cameras on mobile
                if (isMobile && videoCameras.length > 1) {
                    for (const camera of videoCameras) {
                        if (camera.label.toLowerCase().includes('front')) {
                            detectedCameras.front = camera.deviceId;
                        } else if (camera.label.toLowerCase().includes('back') || camera.label.toLowerCase().includes('rear')) {
                            detectedCameras.back = camera.deviceId;
                        }
                    }
                    
                    // If we couldn't identify by label, make educated guesses
                    if (!detectedCameras.front && !detectedCameras.back) {
                        if (videoCameras.length >= 2) {
                            detectedCameras.front = videoCameras[0].deviceId;
                            detectedCameras.back = videoCameras[1].deviceId;
                        } else {
                            detectedCameras.back = videoCameras[0].deviceId;
                        }
                    }
                }
                
                // Default to back camera if available, else use whatever is available
                const preferredCamera = useFrontCamera ? 
                    detectedCameras.front || videoCameras[0]?.deviceId : 
                    detectedCameras.back || videoCameras[0]?.deviceId;
                
                detectedCameras.current = preferredCamera;
                
                // Set up constraints
                const constraints = {
                    video: {
                        deviceId: preferredCamera ? { exact: preferredCamera } : undefined,
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                };
                
                debugLog(`Requesting camera access with constraints: ${JSON.stringify(constraints)}`);
                
                // Request camera stream
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                video.srcObject = stream;
                
                // Wait for video to be ready
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play().then(resolve).catch(e => {
                            debugLog(`Error playing video: ${e.message}`);
                            resolve();
                        });
                    };
                });
                
                // Update UI
                startButton.textContent = "Camera Active";
                document.getElementById('switchButton').disabled = false;
                
                // Reset frozen state
                isFrozen = false;
                const canvas1 = document.getElementById('canvas1');
                const canvas2 = document.getElementById('canvas2');
                if (canvas1) canvas1.classList.remove('frozen-canvas');
                if (canvas2) canvas2.classList.remove('frozen-canvas');
                
                // Setup rendering
                setupRendering();
                
                debugLog(`Camera started successfully: ${video.videoWidth}x${video.videoHeight}`);
            } catch (error) {
                debugLog(`Error starting camera: ${error.message}`);
                startButton.textContent = "Start Camera";
                startButton.disabled = false;
            }
        }
        
        // Switch camera (front/back)
        async function switchCamera() {
            const switchButton = document.getElementById('switchButton');
            if (!switchButton) return;
            
            switchButton.disabled = true;
            
            try {
                useFrontCamera = !useFrontCamera;
                await startCamera();
                switchButton.textContent = useFrontCamera ? "Switch to Back" : "Switch to Front";
            } catch (error) {
                debugLog(`Error switching camera: ${error.message}`);
            } finally {
                switchButton.disabled = false;
            }
        }
        
        // Set up rendering
        function setupRendering() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            if (!canvas1 || !canvas2) return;
            
            // Adjust canvas size based on video dimensions
            const videoAspect = video.videoWidth / video.videoHeight;
            const containerWidth = document.querySelector('.container').clientWidth;
            const canvasWidth = Math.min(containerWidth / 2 - 20, video.videoWidth * qualityFactor);
            const canvasHeight = canvasWidth / videoAspect;
            
            canvas1.width = canvas2.width = canvasWidth;
            canvas1.height = canvas2.height = canvasHeight;
            
            // Set processing canvas size
            processingCanvas.width = video.videoWidth * qualityFactor;
            processingCanvas.height = video.videoHeight * qualityFactor;
            
            // Start rendering
            requestAnimationFrame(renderFrame);
        }
        
        // Main render frame function - FIXED VERSION
        function renderFrame(time) {
            if (video && video.readyState >= 2) {
                const currentTime = performance.now();
                const elapsed = currentTime - lastFrameTime;
                
                // Control frame rate
                if (elapsed >= frameInterval) {
                    lastFrameTime = currentTime;
                    
                    // Don't process new frames if frozen
                    if (!isFrozen) {
                        // Process and render frame
                        const canvas1 = document.getElementById('canvas1');
                        const canvas2 = document.getElementById('canvas2');
                        
                        if (canvas1 && canvas2) {
                            const ctx1 = canvas1.getContext('2d');
                            const ctx2 = canvas2.getContext('2d');
                            
                            // Draw video frame to processing canvas
                            processingCtx.drawImage(video, 0, 0, processingCanvas.width, processingCanvas.height);
                            
                            // Apply stereo effect
                            const baselineSeparation = parseFloat(document.getElementById('baselineSeparation').value) || 3.0;
                            const depthIntensity = parseFloat(document.getElementById('depthIntensity').value) || 15;
                            const depthMode = document.getElementById('depthMode').value || 'hadit_scoord';
                            
                            // Get color tinting for left/right eyes
                            const leftEyeColor = {
                                r: parseInt(document.getElementById('redSlider1').value) / 255,
                                g: parseInt(document.getElementById('greenSlider1').value) / 255,
                                b: parseInt(document.getElementById('blueSlider1').value) / 255
                            };
                            
                            const rightEyeColor = {
                                r: parseInt(document.getElementById('redSlider2').value) / 255,
                                g: parseInt(document.getElementById('greenSlider2').value) / 255,
                                b: parseInt(document.getElementById('blueSlider2').value) / 255
                            };
                            
                            // Create stereo effect - FIXED VERSION
                            applyStereoEffect(processingCtx, ctx1, ctx2, leftEyeColor, rightEyeColor, 
                                baselineSeparation, depthIntensity, depthMode);
                            
                            // Update canvas transforms
                            updateCanvasTransforms();
                        }
                    }
                    
                    // Update depth map if visible (even when frozen)
                    if (depthMapVisible) {
                        generateDepthMapFromCurrentFrame();
                    }
                }
            }
            
            // Continue rendering
            requestAnimationFrame(renderFrame);
        }
        
        // Apply stereo effect to frames - FIXED VERSION
        function applyStereoEffect(processingCtx, leftCtx, rightCtx, leftColor, rightColor, separation, intensity, depthMode) {
            const width = processingCanvas.width;
            const height = processingCanvas.height;
            
            // Get original image data
            const imageData = processingCtx.getImageData(0, 0, width, height);
            
            // Make sure output canvases are the right size
            if (leftCtx.canvas.width !== rightCtx.canvas.width || leftCtx.canvas.height !== rightCtx.canvas.height) {
                leftCtx.canvas.width = rightCtx.canvas.width;
                leftCtx.canvas.height = rightCtx.canvas.height;
            }
            
            // Create output image data
            const leftImageData = leftCtx.createImageData(leftCtx.canvas.width, leftCtx.canvas.height);
            const rightImageData = rightCtx.createImageData(rightCtx.canvas.width, rightCtx.canvas.height);
            
            // Scale factor between processing and display canvases
            const scaleX = leftCtx.canvas.width / width;
            const scaleY = leftCtx.canvas.height / height;
            
            // Get Hadit configuration for depth mapping
            const haditConfig = {
                haditTheta: 0.0, // Fixed to requirements
                haditPhi: 0.1,   // Fixed to requirements
                haditInfluence: parseFloat(document.getElementById('haditInfluence').value),
                focusFactor: parseFloat(document.getElementById('focusFactor').value),
                bandMode: 'full_image', // Fixed to requirements
                bandSizeMultiplier: 10.0, // Fixed to requirements
                luminosityWeight: 0.0, // Fixed to requirements
                saturationWeight: 0.0, // Fixed to requirements
                depthContrast: 0.2, // Fixed to requirements
                sBounds: 20.0 // Fixed to requirements
            };
            
            // Detect the band if not already detected
            if (!detectedBand) {
                detectedBand = detectHaditInformationBand(imageData, haditConfig);
            }
            
            // Generate depth map for current frame
            const depthMap = new Float32Array(width * height);
            
            // Process each pixel in the original image for depth
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const pixelIdx = (y * width + x) * 4;
                    
                    // Extract RGB values
                    const r = imageData.data[pixelIdx] / 255;
                    const g = imageData.data[pixelIdx + 1] / 255;
                    const b = imageData.data[pixelIdx + 2] / 255;
                    
                    // Calculate luminance and saturation
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    // Calculate depth based on mode
                    let depth = 0.5;
                    
                    if (depthMode === 'hadit_scoord') {
                        // Use Hadit S-coordinate for depth mapping
                        const result = calculateHaditSCoordinate(
                            x, y, width, height, lum, sat,
                            haditConfig.haditTheta, haditConfig.haditPhi,
                            haditConfig.haditInfluence,
                            haditConfig.luminosityWeight,
                            haditConfig.saturationWeight
                        );
                        
                        const depthResult = calculateHaditDepth(
                            result, detectedBand, haditConfig.focusFactor, haditConfig.depthContrast
                        );
                        
                        depth = depthResult.depth;
                    } else {
                        // Fallback to basic luminance-based depth
                        depth = lum;
                    }
                    
                    depthMap[y * width + x] = depth;
                }
            }
            
            // Apply the depth map to create stereo offset - FIXED VERSION 
            const separationAmount = separation * width / 100; // Convert percentage to pixels
            const maxOffset = separationAmount * (intensity / 100);
            
            // Copy to output canvases with proper offsets
            for (let y = 0; y < leftCtx.canvas.height; y++) {
                for (let x = 0; x < leftCtx.canvas.width; x++) {
                    // Map back to processing canvas coordinates
                    const srcX = Math.floor(x / scaleX);
                    const srcY = Math.floor(y / scaleY);
                    
                    if (srcX < 0 || srcX >= width || srcY < 0 || srcY >= height) continue;
                    
                    // Get depth value for this pixel
                    const depth = depthMap[srcY * width + srcX];
                    const offset = Math.round(depth * maxOffset);
                    
                    // Output pixel index
                    const outIdx = (y * leftCtx.canvas.width + x) * 4;
                    
                    // Sample pixels for left eye (shifted right for near pixels)
                    const leftSampleX = srcX - offset;
                    if (leftSampleX >= 0 && leftSampleX < width) {
                        const leftSrcIdx = (srcY * width + leftSampleX) * 4;
                        leftImageData.data[outIdx] = imageData.data[leftSrcIdx] * leftColor.r;
                        leftImageData.data[outIdx + 1] = imageData.data[leftSrcIdx + 1] * leftColor.g;
                        leftImageData.data[outIdx + 2] = imageData.data[leftSrcIdx + 2] * leftColor.b;
                    } else {
                        // Fill with black for out-of-bounds
                        leftImageData.data[outIdx] = 0;
                        leftImageData.data[outIdx + 1] = 0;
                        leftImageData.data[outIdx + 2] = 0;
                    }
                    leftImageData.data[outIdx + 3] = 255;
                    
                    // Sample pixels for right eye (shifted left for near pixels) 
                    const rightSampleX = srcX + offset;
                    if (rightSampleX >= 0 && rightSampleX < width) {
                        const rightSrcIdx = (srcY * width + rightSampleX) * 4;
                        rightImageData.data[outIdx] = imageData.data[rightSrcIdx] * rightColor.r;
                        rightImageData.data[outIdx + 1] = imageData.data[rightSrcIdx + 1] * rightColor.g;
                        rightImageData.data[outIdx + 2] = imageData.data[rightSrcIdx + 2] * rightColor.b;
                    } else {
                        // Fill with black for out-of-bounds
                        rightImageData.data[outIdx] = 0;
                        rightImageData.data[outIdx + 1] = 0;
                        rightImageData.data[outIdx + 2] = 0;
                    }
                    rightImageData.data[outIdx + 3] = 255;
                }
            }
            
            // Put the processed images to the canvases
            leftCtx.putImageData(leftImageData, 0, 0);
            rightCtx.putImageData(rightImageData, 0, 0);
        }
        
        // Update canvas transforms
        function updateCanvasTransforms() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            if (!canvas1 || !canvas2) return;
            
            const tiltValue = parseFloat(document.getElementById('tiltSlider').value) || 0;
            const sizeValue = parseFloat(document.getElementById('sizeSlider').value) || 1.0;
            
            // Only update if not in flicker mode
            if (!flickerMode) {
                canvas1.style.transform = `scale(${sizeValue}) perspective(1000px) rotateX(${tiltValue * 20}deg)`;
                canvas2.style.transform = `scale(${sizeValue}) perspective(1000px) rotateX(${tiltValue * 20}deg)`;
            }
        }
        
        // Toggle flicker mode - FIXED VERSION
        function toggleFlickerMode() {
            const container = document.querySelector('.container');
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            const flickerSpeedContainer = document.getElementById('flickerSpeedContainer');
            const flickerIndicator = document.getElementById('flickerIndicator');
            const toggleBtn = document.getElementById('toggleFlickerMode');
            
            if (!container || !canvas1 || !canvas2 || !flickerSpeedContainer || !flickerIndicator || !toggleBtn) return;
            
            flickerMode = !flickerMode;
            
            if (flickerMode) {
                // Save original positions
                originalCanvasPositions.canvas1 = {
                    left: canvas1.style.left,
                    margin: canvas1.style.margin,
                    transform: canvas1.style.transform
                };
                originalCanvasPositions.canvas2 = {
                    left: canvas2.style.left,
                    margin: canvas2.style.margin,
                    transform: canvas2.style.transform
                };
                
                // Enable flicker
                container.classList.add('flicker-active');
                
                // Position canvases initially - FIXED
                canvas1.style.position = 'absolute';
                canvas2.style.position = 'absolute';
                
                flickerSpeedContainer.style.display = 'flex';
                flickerIndicator.style.opacity = '1';
                toggleBtn.textContent = 'Disable 3D Flicker';
                
                startFlicker();
            } else {
                // Disable flicker
                if (flickerInterval) {
                    clearInterval(flickerInterval);
                    flickerInterval = null;
                }
                
                // Restore original positions
                container.classList.remove('flicker-active');
                
                canvas1.style.position = '';
                canvas2.style.position = '';
                canvas1.classList.remove('canvas-left', 'canvas-right');
                canvas2.classList.remove('canvas-left', 'canvas-right');
                
                canvas1.style.left = originalCanvasPositions.canvas1.left;
                canvas1.style.margin = originalCanvasPositions.canvas1.margin;
                canvas1.style.transform = originalCanvasPositions.canvas1.transform;
                canvas2.style.left = originalCanvasPositions.canvas2.left;
                canvas2.style.margin = originalCanvasPositions.canvas2.margin;
                canvas2.style.transform = originalCanvasPositions.canvas2.transform;
                
                // Update UI
                flickerSpeedContainer.style.display = 'none';
                flickerIndicator.style.opacity = '0';
                toggleBtn.textContent = 'Enable 3D Flicker';
            }
        }
        
        // Start flicker animation - FIXED VERSION
        function startFlicker() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            if (!canvas1 || !canvas2) return;
            
            if (flickerInterval) {
                clearInterval(flickerInterval);
            }
            
            flickerSpeed = parseInt(document.getElementById('flickerSpeedSlider').value) || 16;
            
            // Initialize positions
            canvas1.classList.add('canvas-left');
            canvas2.classList.add('canvas-right');
            
            flickerFrame = 0;
            flickerInterval = setInterval(() => {
                if (flickerFrame === 0) {
                    canvas1.classList.remove('canvas-right');
                    canvas1.classList.add('canvas-left');
                    
                    canvas2.classList.remove('canvas-left');
                    canvas2.classList.add('canvas-right');
                } else {
                    canvas1.classList.remove('canvas-left');
                    canvas1.classList.add('canvas-right');
                    
                    canvas2.classList.remove('canvas-right');
                    canvas2.classList.add('canvas-left');
                }
                
                flickerFrame = 1 - flickerFrame;
            }, flickerSpeed);
        }
        
        // Toggle controls visibility
        function toggleControls() {
            const controlPanel = document.getElementById('controlPanel');
            const toggleBtn = document.getElementById('toggleControls');
            
            if (!controlPanel || !toggleBtn) return;
            
            controlsHidden = !controlsHidden;
            
            if (controlsHidden) {
                controlPanel.style.display = 'none';
                toggleBtn.textContent = 'Show Controls';
            } else {
                controlPanel.style.display = 'flex';
                toggleBtn.textContent = 'Hide Controls';
            }
        }
        
        // Handle quality selection
        function handleQualityChange() {
            const qualitySelect = document.getElementById('qualitySelect');
            const qualityIndicator = document.getElementById('qualityIndicator');
            
            if (!qualitySelect || !qualityIndicator) return;
            
            qualityFactor = parseFloat(qualitySelect.value);
            
            // Update UI
            let qualityText = '';
            switch (qualityFactor) {
                case 1.0: qualityText = '100%'; break;
                case 0.5: qualityText = '50%'; break;
                case 0.25: qualityText = '25%'; break;
                case 0.1: qualityText = '10%'; break;
                default: qualityText = (qualityFactor * 100) + '%';
            }
            
            qualityIndicator.textContent = `Processing at ${qualityText} resolution`;
            qualityIndicator.style.opacity = 1;
            setTimeout(() => { qualityIndicator.style.opacity = 0; }, 3000);
            
            // Restart camera to apply new quality
            if (currentStream) {
                setupRendering();
            }
        }
        
        // Initialize slider display updates
        function initSliderDisplays() {
            // Update all slider values to their spans on input
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                const valueSpan = document.getElementById(slider.id + 'Value');
                if (valueSpan) {
                    const updateValue = () => {
                        let value = slider.value;
                        
                        // Format values based on ID
                        if (slider.id === 'haditTheta' || slider.id === 'haditPhi') {
                            valueSpan.textContent = parseFloat(value).toFixed(1) + '°';
                        } else if (slider.id === 'focusFactor' || slider.id === 'bandSizeMultiplier' || slider.id === 'depthContrast') {
                            valueSpan.textContent = parseFloat(value).toFixed(1) + 'x';
                        } else if (slider.id === 'baselineSeparation') {
                            valueSpan.textContent = parseFloat(value).toFixed(1) + '%';
                        } else if (slider.id === 'sBounds') {
                            valueSpan.textContent = '±' + parseFloat(value).toFixed(1);
                        } else {
                            valueSpan.textContent = parseFloat(value).toFixed(1);
                        }
                    };
                    
                    slider.addEventListener('input', updateValue);
                    updateValue(); // Initial update
                }
            });
        }

        // Freeze frame with countdown - FIXED VERSION
        function freezeFrameWithDelay() {
            const freezeDelayToggle = document.getElementById('freezeDelayToggle');
            
            if (!freezeDelayToggle || !freezeDelayToggle.checked) {
                freezeFrame();
                return;
            }
            
            const freezeCountdown = document.getElementById('freezeCountdown');
            const countdownValue = document.getElementById('countdownValue');
            
            if (!freezeCountdown || !countdownValue) {
                freezeFrame();
                return;
            }
            
            freezeCountdown.style.display = 'block';
            let count = 3;
            countdownValue.textContent = count;
            
            const countdownInterval = setInterval(() => {
                count--;
                countdownValue.textContent = count;
                
                if (count <= 0) {
                    clearInterval(countdownInterval);
                    freezeCountdown.style.display = 'none';
                    freezeFrame();
                }
            }, 1000);
        }
        
        // Freeze frame - FIXED VERSION
        function freezeFrame() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            const freezeButton = document.getElementById('freezeButton');
            
            if (!canvas1 || !canvas2 || !freezeButton) return;
            
            // Toggle frozen state
            isFrozen = !isFrozen;
            
            // Update UI
            canvas1.classList.toggle('frozen-canvas', isFrozen);
            canvas2.classList.toggle('frozen-canvas', isFrozen);
            freezeButton.textContent = isFrozen ? "Unfreeze Frame" : "Freeze Frame";
            
            // Update depth map if visible
            if (depthMapVisible) {
                generateDepthMapFromCurrentFrame();
            }
        }
        
        // Initialize depth map display functionality
        function initializeDepthMap() {
            console.log("Initializing Hadit depth map system...");
            
            // Set up the toggle button
            const toggleDepthMapBtn = document.getElementById('toggleDepthMap');
            if (toggleDepthMapBtn) {
                toggleDepthMapBtn.addEventListener('click', function() {
                    depthMapVisible = !depthMapVisible;
                    document.getElementById('depthMapDisplay').style.display = depthMapVisible ? 'block' : 'none';
                    this.classList.toggle('active', depthMapVisible);
                    
                    if (depthMapVisible) {
                        // Force initial depth map generation
                        if (video && video.readyState >= 2) {
                            requestAnimationFrame(generateDepthMapFromCurrentFrame);
                        }
                    }
                    
                    // Update UI
                    if (depthMapVisible) {
                        document.getElementById('depthMapLabel').textContent = "Hadit Depth Map (Active)";
                    } else {
                        document.getElementById('depthMapLabel').textContent = "Hadit Depth Map";
                    }
                });
            }
            
            // Set the Hadit settings according to requirements
            document.getElementById('haditPhi').value = 0.1;
            document.getElementById('haditPhiValue').textContent = '0.1°';
            document.getElementById('haditTheta').value = 0.0;
            document.getElementById('haditThetaValue').textContent = '0.0°';
            document.getElementById('luminosityWeight').value = 0.0;
            document.getElementById('luminosityWeightValue').textContent = '0.0';
            document.getElementById('saturationWeight').value = 0.0;
            document.getElementById('saturationWeightValue').textContent = '0.0';
            document.getElementById('sBounds').value = 20.0;
            document.getElementById('sBoundsValue').textContent = '±20.0';
            document.getElementById('bandSizeMultiplier').value = 10.0;
            document.getElementById('bandSizeMultiplierValue').textContent = '10.0x';
            document.getElementById('depthContrast').value = 0.2;
            document.getElementById('depthContrastValue').textContent = '0.2x';
            document.getElementById('bandMode').value = 'full_image';
            
            // Update Hadit indicator
            document.getElementById('haditIndicator').textContent = 'Hadit: φ=0.1° θ=0.0° Focus=4.3x';
        }

        // ==================== INITIALIZATION ====================
        
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize UI
            initSliderDisplays();
            
            // Set up event listeners
            document.getElementById('startButton')?.addEventListener('click', startCamera);
            document.getElementById('switchButton')?.addEventListener('click', switchCamera);
            document.getElementById('toggleControls')?.addEventListener('click', toggleControls);
            document.getElementById('toggleFlickerMode')?.addEventListener('click', toggleFlickerMode);
            document.getElementById('flickerSpeedSlider')?.addEventListener('input', () => {
                flickerSpeed = parseInt(document.getElementById('flickerSpeedSlider').value);
                if (flickerInterval) {
                    clearInterval(flickerInterval);
                    startFlicker();
                }
            });
            document.getElementById('qualitySelect')?.addEventListener('change', handleQualityChange);
            document.getElementById('freezeButton')?.addEventListener('click', freezeFrameWithDelay);
            
            // Apply initial Hadit settings from requirements
            document.getElementById('haditPhi').value = 0.1;
            document.getElementById('haditPhiValue').textContent = '0.1°';
            document.getElementById('haditTheta').value = 0.0;
            document.getElementById('haditThetaValue').textContent = '0.0°';
            document.getElementById('luminosityWeight').value = 0.0;
            document.getElementById('luminosityWeightValue').textContent = '0.0';
            document.getElementById('saturationWeight').value = 0.0;
            document.getElementById('saturationWeightValue').textContent = '0.0';
            document.getElementById('sBounds').value = 20.0;
            document.getElementById('sBoundsValue').textContent = '±20.0';
            document.getElementById('bandSizeMultiplier').value = 10.0;
            document.getElementById('bandSizeMultiplierValue').textContent = '10.0x';
            document.getElementById('depthContrast').value = 0.2;
            document.getElementById('depthContrastValue').textContent = '0.2x';
            document.getElementById('bandMode').value = 'full_image';
            
            // Initialize depth map
            initializeDepthMap();
            
            console.log("AndroidVR initialized with Hadit depth settings:");
            console.log("- Phi: 0.1°, Theta: 0.0°");
            console.log("- Luminosity: 0, Saturation: 0");
            console.log("- S bounds: 20, Band Size: 10x");
            console.log("- Depth contrast: 0.2, Full Image coverage");
            console.log("Current Date and Time (UTC): 2025-06-07 03:17:17");
            console.log("Current User Login: Angledcrystals");
        });
    </script>
</body>
</html>
