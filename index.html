<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AndroidVR - Invisible Mirror</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 5px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-bottom: 15px;
        }

        /* VR-optimized camera layout */
        .camera-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        /* Stereo view - optimized for VR headsets with responsive scaling */
        .stereo-view {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 95vw;
            box-sizing: border-box;
        }

        /* Depth view - positioned below stereo frames */
        .depth-view {
            display: flex;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 600px;
        }

        .camera-feed {
            position: relative;
            overflow: hidden;
        }

        /* Enhanced stereo frame sizing for VR with dynamic scaling */
        .stereo-frame {
            flex: 1;
            max-width: calc(50% - 10px);
            min-width: 300px;
            width: 100%;
        }

        .stereo-frame canvas {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            display: block;
        }

        /* Depth frame sizing with responsive scaling */
        .depth-frame {
            width: 100%;
            max-width: 400px;
        }

        .depth-frame canvas {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            max-height: 40vh;
            object-fit: contain;
            display: block;
        }

        canvas, video {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            box-sizing: border-box;
        }

        .left-eye { border-color: #ff4444 !important; }
        .right-eye { border-color: #4444ff !important; }
        .depth-map { border-color: #ff8800 !important; }
        .raw-video { border-color: #00ff88 !important; }

        .camera-label {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .left-label { color: #ff4444; }
        .right-label { color: #4444ff; }
        .depth-label { color: #ff8800; }
        .raw-label { color: #00ff88; }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #00ff88;
            margin-bottom: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 3px;
            font-size: 10px;
            width: 60px;
        }

        select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            cursor: pointer;
            font-size: 10px;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .camera-control {
            background: rgba(0, 255, 136, 0.2) !important;
            border-color: #00ff88 !important;
        }

        .hadit-control {
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: #ff00ff !important;
        }

        .band-control {
            background: rgba(255, 255, 0, 0.2) !important;
            border-color: #ffff00 !important;
        }

        .stereo-control {
            background: rgba(255, 68, 136, 0.2) !important;
            border-color: #ff4488 !important;
        }

        .depth-control {
            background: rgba(255, 136, 0, 0.2) !important;
            border-color: #ff8800 !important;
        }

        .dual-input {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dual-input input[type="range"] {
            flex: 1;
            margin-bottom: 0;
        }

        .dual-input input[type="number"] {
            flex: 0 0 auto;
        }

        .info-panel {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .hadit-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .analysis-panel {
            background: rgba(136, 255, 0, 0.1);
            border: 1px solid #88ff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .processing {
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5) !important;
            animation: processing 1s ease-in-out infinite;
        }

        @keyframes processing {
            0% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
        }

        .fps-counter {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
        }

        .camera-status {
            text-align: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .status-connecting { color: #ffff00; }
        .status-active { color: #00ff88; }
        .status-error { color: #ff4444; }

        .error-message {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #ff4444;
        }

        /* GPU Status Panel - NEW */
        .gpu-status {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
            text-align: center;
        }

        /* Debug video (visible) */
        #debugVideo {
            max-width: 200px;
            border: 1px solid #ffff00;
        }

        /* Landscape optimizations for VR - Enhanced for better scaling */
        @media (orientation: landscape) and (min-width: 768px) {
            .stereo-view {
                padding: 25px;
                gap: 20px;
                max-width: 98vw;
            }
            
            .stereo-frame {
                max-width: calc(50% - 15px);
                min-width: 350px;
            }
            
            .stereo-frame canvas {
                max-height: 75vh;
            }
            
            .depth-view {
                max-width: 500px;
            }
            
            .camera-label {
                font-size: 14px;
                margin-bottom: 10px;
            }
        }

        /* Mobile and portrait optimizations */
        @media (max-width: 768px), (orientation: portrait) {
            .stereo-view {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                max-width: 95vw;
            }
            
            .stereo-frame {
                min-width: 280px;
                max-width: 90vw;
                width: 100%;
            }
            
            .stereo-frame canvas {
                max-height: 50vh;
            }
            
            .depth-view {
                max-width: 90vw;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Extra large landscape screens (VR friendly) - Enhanced */
        @media (orientation: landscape) and (min-width: 1200px) {
            .stereo-view {
                max-width: 98vw;
                padding: 30px;
                gap: 25px;
            }
            
            .stereo-frame {
                min-width: 450px;
                max-width: calc(50% - 20px);
            }
            
            .stereo-frame canvas {
                max-height: 80vh;
            }
            
            .camera-label {
                font-size: 16px;
            }
        }

        /* Ultra-wide displays (VR optimized) */
        @media (orientation: landscape) and (min-width: 1600px) {
            .stereo-view {
                max-width: 95vw;
                padding: 35px;
                gap: 30px;
            }
            
            .stereo-frame {
                min-width: 600px;
                max-width: calc(50% - 25px);
            }
            
            .stereo-frame canvas {
                max-height: 85vh;
            }
        }

        /* Small screens - ensure no cutoff */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .stereo-view {
                padding: 10px;
                gap: 10px;
                max-width: 98vw;
            }
            
            .stereo-frame {
                min-width: 250px;
                max-width: 95vw;
            }
            
            .stereo-frame canvas {
                max-height: 40vh;
            }
        }

        /* Force canvas to respect container bounds */
        canvas {
            max-width: 100% !important;
            height: auto !important;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AndroidVR - Invisible Mirror </h1>
        <div class="subtitle">Real-time Mirror angle Control with Band Detection & Depth Contrast: 0.1° Precision | 2025-06-07 11:16:24 UTC | User: Angledcrystals</div>

        <!-- GPU Status Panel - NEW -->
        <div class="gpu-status" id="gpuStatus" style="display: none;">
            <div style="color: #00ffff; font-weight: bold;">🔥 GPU Acceleration Status:</div>
            <div id="gpuStatusText">Checking WebGL support...</div>
        </div>

        <div class="hadit-info">
            <div style="color: #ff00ff; font-weight: bold;">⚡ Complete Live Hadit Processing:</div>
            <div>• Real-time camera feed with advanced Hadit band detection</div>
            <div>• θ (Theta): 0° to 360° in 0.1° increments for live adjustment</div>
            <div>• φ (Phi): 0.1° to 179.9° in 0.1° increments for extreme precision</div>
            <div>• Band detection modes: Auto, Content Analysis, Gradient-Based, Statistical, Manual, Full Image</div>
            <div>• Depth Contrast control for enhanced depth perception</div>
            <div>• Band size multiplier and focus controls for precise depth mapping</div>
            <div>• Parallel stereo view with pixel-perfect offset based on Hadit depth</div>
        </div>

        <div class="camera-status" id="cameraStatus">
            <span class="status-connecting">📹 Camera system ready - click Start Camera</span>
        </div>

        <div id="errorPanel" class="error-message" style="display: none;">
            <div style="font-weight: bold;">❌ Camera Error:</div>
            <div id="errorMessage">Unknown error occurred</div>
            <div style="margin-top: 5px; font-size: 10px;">
                • Make sure you allow camera permissions<br>
                • Try switching between front/back camera<br>
                • Check if another app is using the camera<br>
                • Refresh the page and try again
            </div>
        </div>

        <!-- Debug video element (visible for troubleshooting) -->
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="font-size: 11px; color: #ffff00; margin-bottom: 5px;">🔍 DEBUG: Raw Camera Feed</div>
            <video id="debugVideo" autoplay playsinline muted class="raw-video" style="display: none;"></video>
        </div>

        <div class="camera-container">
            <!-- Stereo frames optimized for VR headsets -->
            <div class="stereo-view">
                <div class="camera-feed stereo-frame">
                    <div class="camera-label left-label">Left Eye (Red)</div>
                    <canvas id="leftCanvas" width="640" height="480" class="left-eye"></canvas>
                    <div class="fps-counter" id="leftFps">0 FPS</div>
                </div>
                <div class="camera-feed stereo-frame">
                    <div class="camera-label right-label">Right Eye (Blue)</div>
                    <canvas id="rightCanvas" width="640" height="480" class="right-eye"></canvas>
                    <div class="fps-counter" id="rightFps">0 FPS</div>
                </div>
            </div>
            
            <!-- Depth map positioned below stereo frames -->
            <div class="depth-view">
                <div class="camera-feed depth-frame">
                    <div class="camera-label depth-label">Hadit Depth</div>
                    <canvas id="depthCanvas" width="320" height="240" class="depth-map"></canvas>
                    <div class="fps-counter" id="depthFps">0 FPS</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>📹 Camera Control</label>
                <button id="startCamera" class="camera-control">▶️ Start Camera</button>
                <button id="switchCamera" class="camera-control" style="display: none;">🔄 Switch Camera</button>
                <button id="stopCamera" class="camera-control" style="display: none;">⏹️ Stop Camera</button>
                <button id="requestPermissions" class="camera-control">🔑 Request Permissions</button>
                <button id="toggleDebugVideo" class="camera-control">👁️ Toggle Debug Video</button>
            </div>

    <div class="control-group">
    <label>🔧 Depth Source</label>
    <select id="depthSource" class="hadit-control">
        <option value="brightness">Brightness/Saturation</option>
        <option value="sMagnitude" selected>S-Magnitude</option>
        <option value="angular">Angular Reflection</option>
    </select>
</div>
            
            <div class="control-group">
                <label>📐 Camera Settings</label>
                <select id="resolutionSelect" class="camera-control">
                    <option value="320x240">320x240 (Low)</option>
                    <option value="640x480" selected>640x480 (VGA)</option>
                    <option value="1280x720">1280x720 (HD)</option>
                    <option value="1920x1080">1920x1080 (FHD)</option>
                </select>
                <select id="facingMode" class="camera-control">
                    <option value="environment" selected>Back Camera</option>
                    <option value="user">Front Camera</option>
                </select>
            </div>

            <div class="control-group">
                <label>📡 Band Detection Mode</label>
                <select id="bandDetectionMode" class="band-control">
                    <option value="auto_detect" selected>🔍 Auto-Detect Band</option>
                    <option value="content_analysis">📊 Content Analysis</option>
                    <option value="gradient_based">🌊 Gradient-Based</option>
                    <option value="statistical">📈 Statistical Analysis</option>
                    <option value="manual_range">✋ Manual Range</option>
                    <option value="full_image">🌍 Full Image Coverage</option>
                </select>
            </div>

            <div class="control-group">
                <label>🔧 Band Size Multiplier: <span id="bandSizeMultiplierValue">10.0x</span></label>
                <input type="range" id="bandSizeMultiplier" min="0.1" max="10.0" step="0.1" value="10.0" class="band-control">
            </div>

            <div class="control-group">
                <label>🎯 Focus Factor: <span id="focusFactorValue">4.0x</span></label>
                <input type="range" id="focusFactor" min="1.0" max="5.0" step="0.1" value="4.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>⚡ Hadit θ (Theta): <span id="haditThetaValue">0.0°</span></label>
                <div class="dual-input">
                    <input type="range" id="haditTheta" min="0" max="360" value="0" step="0.1" class="hadit-control">
                    <input type="number" id="haditThetaNumber" min="0" max="360" step="0.1" value="0" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>⚡ Hadit φ (Phi): <span id="haditPhiValue">0.1°</span></label>
                <div class="dual-input">
                    <input type="range" id="haditPhi" min="0.1" max="179.9" value="0.1" step="0.1" class="hadit-control">
                    <input type="number" id="haditPhiNumber" min="0.1" max="179.9" step="0.1" value="0.1" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>🌊 Hadit Influence: <span id="haditInfluenceValue">1.0</span></label>
                <input type="range" id="haditInfluence" min="0" max="2" value="1.0" step="0.1" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>👁️ Stereo Separation: <span id="separationValue">8px</span></label>
                <input type="range" id="separation" min="0" max="50" value="8" step="1" class="stereo-control">
            </div>
            
            <div class="control-group">
                <label>🗺️ Depth Intensity: <span id="depthIntensityValue">2.0x</span></label>
                <input type="range" id="depthIntensity" min="0.1" max="5.0" value="2.0" step="0.1" class="depth-control">
            </div>

            <div class="control-group">
                <label>🎨 Depth Contrast: <span id="depthContrastValue">0.2x</span></label>
                <input type="range" id="depthContrast" min="0.1" max="3.0" value="0.2" step="0.1" class="depth-control">
            </div>
            
            <div class="control-group">
                <label>📐 S Bounds: <span id="sBoundsValue">±20.0</span></label>
                <input type="range" id="sBounds" min="1.0" max="20.0" step="0.1" value="20.0" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>💡 Luminosity Weight: <span id="luminosityWeightValue">0.0</span></label>
                <input type="range" id="luminosityWeight" min="0" max="1" step="0.05" value="0.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>🌈 Saturation Weight: <span id="saturationWeightValue">0.0</span></label>
                <input type="range" id="saturationWeight" min="0" max="1" step="0.05" value="0.0" class="band-control">
            </div>
            
            <div class="control-group">
                <label>⚙️ Processing Quality</label>
                <select id="qualitySelect" class="depth-control">
                    <option value="1.0">Full Quality</option>
                    <option value="0.75" selected>High Quality</option>
                    <option value="0.5">Medium Quality</option>
                    <option value="0.25">Low Quality</option>
                </select>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <div>Status: Complete Live Hadit camera system ready... Angledcrystals | 2025-06-07 11:16:24 UTC</div>
        </div>

        <div class="analysis-grid">
            <div>
                <div class="control-group">
                    <label>Quick Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHaditPole" class="hadit-control">φ=0.1° (Pole)</button>
                        <button id="setHaditEquator" class="hadit-control">φ=90° (Equator)</button>
                        <button id="setHaditNear180" class="hadit-control">φ=179.9° (Anti-pole)</button>
                        <button id="animateTheta" class="hadit-control">🌀 Animate θ</button>
                        <button id="animatePhi" class="hadit-control">🌊 Animate φ</button>
                        <button id="stopAnimation" class="hadit-control">⏹️ Stop All</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Depth Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHighContrast" class="depth-control">🔆 High Contrast</button>
                        <button id="setLowContrast" class="depth-control">🔅 Low Contrast</button>
                        <button id="setExtremeDepth" class="depth-control">💥 Extreme Depth</button>
                        <button id="setSubtleDepth" class="depth-control">🌫️ Subtle Depth</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Band Actions</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="detectBand" class="band-control">📡 Detect Band</button>
                        <button id="expandBandFull" class="band-control">🌍 Expand Full</button>
                        <button id="resetBand" class="band-control">🔄 Reset Band</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Options & Debug</label>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label><input type="checkbox" id="enableStereo" checked> Enable Stereo</label>
                        <label><input type="checkbox" id="showDepthMap" checked> Show Depth</label>
                        <label><input type="checkbox" id="showBandVisualization"> Show Band Viz</label>
                        <label><input type="checkbox" id="focusOnlyBand"> Focus Only Band</label>
                        <label><input type="checkbox" id="mirrorCamera"> Mirror Camera</label>
                        <label><input type="checkbox" id="showFPS" checked> Show FPS</label>
                        <label><input type="checkbox" id="debugMode" checked> Debug Mode</label>
                        <label><input type="checkbox" id="showRawFeed"> Show Raw Feed</label>
                        <!-- NEW GPU CONTROL - but disabled by default -->
    <label>🔥 GPU Processing</label>
    <label><input type="checkbox" id="useGPU"> Enable GPU Acceleration</label>
    <select id="gpuStereoMode" class="camera-control" disabled>
        <option value="cpu">CPU Stereo Only</option>
        <option value="gpu_forward">GPU Forward + Hole Fill</option>
        <option value="gpu_bidirectional">GPU Bidirectional + Hole Fill</option>
    </select>
    <small style="color: #888; font-size: 9px;">GPU hole filling uses CPU depth data</small>                  
                </div>
            </div>
            
            <div class="analysis-panel" id="analysisPanel">
                <div style="color: #88ff00; font-weight: bold;">⚡ Live Hadit Band Analysis</div>
                <div>Ready for live camera processing with band detection...</div>
                <div>Camera permissions status: checking...</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== GPU ACCELERATION SYSTEM (NEW - OPTIONAL) ====================
        
        class WebGLProcessor {
            constructor() {
                this.gl = null;
                this.program = null;
                this.isInitialized = false;
                this.gpuEnabled = false;
            }

            async initialize() {
                // Only initialize when explicitly requested
                if (!document.getElementById('useGPU').checked) {
                    return false;
                }

                try {
                    this.canvas = document.createElement('canvas');
                    this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                    
                    if (!this.gl) {
                        throw new Error('WebGL not supported');
                    }

                    await this.createShaders();
                    this.createBuffers();
                    this.isInitialized = true;
                    this.gpuEnabled = true;
                    
                    console.log('🔥 GPU acceleration initialized');
                    this.updateGPUStatus(true, 'GPU Acceleration: ENABLED ✓');
                    
                    return true;
                } catch (error) {
                    console.warn('GPU acceleration failed:', error);
                    this.updateGPUStatus(false, 'GPU Acceleration: FAILED ❌');
                    this.gpuEnabled = false;
                    return false;
                }
            }

            async createShaders() {
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    attribute vec2 a_texCoord;
                    varying vec2 v_texCoord;
                    
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                        v_texCoord = a_texCoord;
                    }
                `;

                const fragmentShaderSource = `
                    precision highp float;
                    
                    uniform sampler2D u_image;
                    uniform float u_haditTheta;
                    uniform float u_haditPhi;
                    uniform float u_haditInfluence;
                    uniform float u_depthContrast;
                    uniform float u_luminosityWeight;
                    uniform float u_saturationWeight;
                    uniform vec2 u_resolution;
                    
                    varying vec2 v_texCoord;
                    
                    vec3 sphericalToCartesian(float theta, float phi) {
                        float thetaRad = theta * 3.14159265359 / 180.0;
                        float phiRad = clamp(phi, 0.1, 179.9) * 3.14159265359 / 180.0;
                        
                        return vec3(
                            sin(phiRad) * cos(thetaRad),
                            sin(phiRad) * sin(thetaRad),
                            cos(phiRad)
                        );
                    }
                    
                    vec3 householderReflection(vec3 g, vec3 hadit) {
                        vec3 haditUnit = normalize(hadit);
                        float dotProduct = dot(haditUnit, g);
                        return g - 2.0 * dotProduct * haditUnit;
                    }
                    
                    vec2 stereographicProjection(vec3 gReflected) {
                        if (abs(1.0 - gReflected.z) < 1e-10) {
                            return vec2(0.0, 0.0);
                        }
                        return vec2(
                            gReflected.x / (1.0 - gReflected.z),
                            gReflected.y / (1.0 - gReflected.z)
                        );
                    }
                    
                    void main() {
                        vec4 color = texture2D(u_image, v_texCoord);
                        
                        vec2 pixelCoord = v_texCoord * u_resolution;
                        
                        float lum = 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;
                        float maxCol = max(max(color.r, color.g), color.b);
                        float minCol = min(min(color.r, color.g), color.b);
                        float sat = maxCol > 0.0 ? (maxCol - minCol) / maxCol : 0.0;
                        
                        float gTheta = (pixelCoord.x / u_resolution.x) * 360.0;
                        float gPhi = (pixelCoord.y / u_resolution.y) * 180.0;
                        vec3 G_3d = sphericalToCartesian(gTheta, gPhi);
                        
                        vec3 hadit_3d = sphericalToCartesian(u_haditTheta, u_haditPhi);
                        vec3 G_reflected = householderReflection(G_3d, hadit_3d);
                        vec2 S_hadit = stereographicProjection(G_reflected);
                        
                        float contentModulation = 1.0 + lum * u_luminosityWeight + sat * u_saturationWeight;
                        vec2 sCoord = S_hadit * contentModulation * u_haditInfluence;
                        float sMagnitude = length(sCoord);
                        
                        float depth = 0.3 + lum * 0.4 + sat * 0.3;
                        depth = clamp(depth, 0.05, 1.0);
                        
                        float centerAdjusted = 0.5;
                        depth = centerAdjusted + (depth - centerAdjusted) * u_depthContrast;
                        depth = clamp(depth, 0.05, 1.0);
                        
                        gl_FragColor = vec4(depth, depth, depth, 1.0);
                    }
                `;

                this.program = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);
            }

            createShaderProgram(vertexSource, fragmentSource) {
                const gl = this.gl;
                
                const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error('Shader program linking failed');
                }
                
                return program;
            }

            createShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw new Error('Shader compilation failed');
                }
                
                return shader;
            }

            createBuffers() {
                const gl = this.gl;
                
                const positions = new Float32Array([
                    -1, -1,  0, 0,
                     1, -1,  1, 0,
                    -1,  1,  0, 1,
                     1,  1,  1, 1,
                ]);
                
                this.positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            }

            processDepthMap(imageData, config) {
                if (!this.isInitialized || !this.gpuEnabled) {
                    return null;
                }

                const gl = this.gl;
                const { width, height, data } = imageData;

                try {
                    this.canvas.width = width;
                    this.canvas.height = height;
                    gl.viewport(0, 0, width, height);

                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

                    gl.useProgram(this.program);

                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_haditTheta'), config.haditTheta);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_haditPhi'), config.haditPhi);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_haditInfluence'), config.haditInfluence);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_depthContrast'), config.depthContrast);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_luminosityWeight'), config.luminosityWeight);
                    gl.uniform1f(gl.getUniformLocation(this.program, 'u_saturationWeight'), config.saturationWeight);
                    gl.uniform2f(gl.getUniformLocation(this.program, 'u_resolution'), width, height);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.uniform1i(gl.getUniformLocation(this.program, 'u_image'), 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                    const texCoordLocation = gl.getAttribLocation(this.program, 'a_texCoord');
                    
                    gl.enableVertexAttribArray(positionLocation);
                    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
                    
                    gl.enableVertexAttribArray(texCoordLocation);
                    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    const pixels = new Uint8Array(width * height * 4);
                    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

                    gl.deleteTexture(texture);

                    return pixels;

                } catch (error) {
                    console.error('GPU processing error:', error);
                    this.gpuEnabled = false;
                    this.updateGPUStatus(false, 'GPU Acceleration: ERROR ❌');
                    return null;
                }
            }

            updateGPUStatus(enabled, message) {
                const statusElement = document.getElementById('gpuStatusText');
                const statusPanel = document.getElementById('gpuStatus');
                
                if (statusElement && statusPanel) {
                    statusElement.textContent = message;
                    statusPanel.style.display = 'block';
                    statusPanel.style.borderColor = enabled ? '#00ffff' : '#ffaa00';
                }
            }
        }

        // ==================== ALL YOUR ORIGINAL CODE (UNCHANGED) ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function calculateHaditModulatedSCoordinate(px, py, width, height, lum, sat, config) {
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            const contentModulation = (1 + lum * config.luminosityWeight + sat * config.saturationWeight);
            
            return {
                sCoord: {
                    x: S_hadit.x * contentModulation * config.haditInfluence,
                    y: S_hadit.y * contentModulation * config.haditInfluence
                },
                sMagnitude: Math.sqrt(
                    Math.pow(S_hadit.x * contentModulation * config.haditInfluence, 2) +
                    Math.pow(S_hadit.y * contentModulation * config.haditInfluence, 2)
                ),
                originalG: G_3d,
                reflectedG: G_reflected,
                haditVector: hadit_3d,
                contentModulation: contentModulation,
                luminance: lum,
                saturation: sat
            };
        }

        function applyDepthContrast(depth, contrast, bandCenteredness = 1.0) {
            const centerAdjusted = 0.5;
            let contrastAdjustedDepth = centerAdjusted + (depth - centerAdjusted) * contrast;
            
            if (bandCenteredness > 0.5) {
                const bandBoost = 1.0 + (bandCenteredness - 0.5) * 0.5;
                contrastAdjustedDepth = centerAdjusted + (contrastAdjustedDepth - centerAdjusted) * bandBoost;
            }
            
            return Math.max(0.05, Math.min(1.0, contrastAdjustedDepth));
        }

        let currentSBounds = 20.0;
        let detectedBand = { min: 0, max: 0, center: 0, width: 0, confidence: 0 };

        function detectHaditInformationBand(imageData, config) {
            console.log(`📡 Detecting band with Hadit θ=${config.haditTheta.toFixed(1)}°, φ=${config.haditPhi.toFixed(1)}°`);
            const startTime = performance.now();
            
            const { width, height, data } = imageData;
            const sMagnitudeHistogram = new Array(200).fill(0);
            const contentHistogram = new Array(200).fill(0);
            
            const maxSMagnitude = currentSBounds * 2;
            let totalPixels = 0;
            let totalContent = 0;
            
            const sampleStep = Math.max(1, Math.floor(Math.min(width, height) / 50));
            
            for (let y = 0; y < height; y += sampleStep) {
                for (let x = 0; x < width; x += sampleStep) {
                    const pixelIdx = (y * width + x) * 4;
                    
                    const r = data[pixelIdx] / 255;
                    const g = data[pixelIdx + 1] / 255;
                    const b = data[pixelIdx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const result = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                    const sMagnitude = result.sMagnitude;
                    
                    const contentImportance = lum * 0.5 + sat * 0.3 + 
                                            (Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r)) * 0.2;
                    
                    const binIndex = Math.floor((sMagnitude / maxSMagnitude) * (sMagnitudeHistogram.length - 1));
                    if (binIndex >= 0 && binIndex < sMagnitudeHistogram.length) {
                        sMagnitudeHistogram[binIndex]++;
                        contentHistogram[binIndex] += contentImportance;
                        totalContent += contentImportance;
                    }
                    
                    totalPixels++;
                }
            }
            
            let bandDetectionResult;
            
            switch (config.bandDetectionMode) {
                case 'full_image':
                    bandDetectionResult = {
                        min: 0,
                        max: maxSMagnitude * 2,
                        center: maxSMagnitude,
                        width: maxSMagnitude * 2,
                        confidence: 1.0
                    };
                    break;
                    
                case 'auto_detect':
                    bandDetectionResult = autoDetectBand(sMagnitudeHistogram, contentHistogram, maxSMagnitude, 0.1);
                    break;
                    
                case 'content_analysis':
                    bandDetectionResult = contentBasedBandDetection(contentHistogram, maxSMagnitude, 0.1);
                    break;
                    
                case 'gradient_based':
                    bandDetectionResult = gradientBasedBandDetection(sMagnitudeHistogram, maxSMagnitude, 0.1);
                    break;
                    
                case 'statistical':
                    bandDetectionResult = statisticalBandDetection(sMagnitudeHistogram, contentHistogram, maxSMagnitude, 0.1);
                    break;
                    
                case 'manual_range':
                    bandDetectionResult = {
                        min: config.manualBandMin || 0,
                        max: config.manualBandMax || maxSMagnitude,
                        center: ((config.manualBandMin || 0) + (config.manualBandMax || maxSMagnitude)) / 2,
                        width: (config.manualBandMax || maxSMagnitude) - (config.manualBandMin || 0),
                        confidence: 1.0
                    };
                    break;
            }
            
            if (config.bandSizeMultiplier !== 1.0) {
                const originalWidth = bandDetectionResult.width;
                const newWidth = originalWidth * config.bandSizeMultiplier;
                const expansion = (newWidth - originalWidth) / 2;
                
                bandDetectionResult.min = Math.max(0, bandDetectionResult.min - expansion);
                bandDetectionResult.max = bandDetectionResult.max + expansion;
                bandDetectionResult.width = newWidth;
            }
            
            const processingTime = performance.now() - startTime;
            
            console.log(`✅ Band detection completed in ${processingTime.toFixed(2)}ms`);
            console.log(`   Detected band: ${bandDetectionResult.min.toFixed(2)} to ${bandDetectionResult.max.toFixed(2)}`);
            
            return {
                band: bandDetectionResult,
                histograms: {
                    sMagnitude: sMagnitudeHistogram,
                    content: contentHistogram
                },
                stats: {
                    processingTime,
                    totalPixels,
                    totalContent,
                    maxSMagnitude,
                    samplingStep: sampleStep
                }
            };
        }

        function autoDetectBand(sMagnitudeHistogram, contentHistogram, maxSMagnitude, sensitivity) {
            const smoothedContent = smoothHistogram(contentHistogram, 3);
            const peaks = findHistogramPeaks(smoothedContent, sensitivity);
            
            if (peaks.length === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            const primaryPeak = peaks.reduce((max, peak) => peak.strength > max.strength ? peak : max);
            const bandHalfWidth = Math.max(0.5, maxSMagnitude * 0.1);
            const binToSMagnitude = (bin) => (bin / (smoothedContent.length - 1)) * maxSMagnitude;
            
            const bandCenter = binToSMagnitude(primaryPeak.bin);
            const bandMin = Math.max(0, bandCenter - bandHalfWidth);
            const bandMax = Math.min(maxSMagnitude, bandCenter + bandHalfWidth);
            
            return {
                min: bandMin,
                max: bandMax,
                center: bandCenter,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, primaryPeak.strength / (smoothedContent.length * 0.1))
            };
        }

        function contentBasedBandDetection(contentHistogram, maxSMagnitude, sensitivity) {
            let totalContent = contentHistogram.reduce((sum, val) => sum + val, 0);
            if (totalContent === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            let weightedSum = 0;
            for (let i = 0; i < contentHistogram.length; i++) {
                weightedSum += i * contentHistogram[i];
            }
            const centerOfMass = weightedSum / totalContent;
            
            const threshold = totalContent * sensitivity * 0.01;
            let minBin = 0, maxBin = contentHistogram.length - 1;
            
            for (let i = 0; i < contentHistogram.length; i++) {
                if (contentHistogram[i] > threshold) {
                    minBin = i;
                    break;
                }
            }
            
            for (let i = contentHistogram.length - 1; i >= 0; i--) {
                if (contentHistogram[i] > threshold) {
                    maxBin = i;
                    break;
                }
            }
            
            const binToSMagnitude = (bin) => (bin / (contentHistogram.length - 1)) * maxSMagnitude;
            
            return {
                min: binToSMagnitude(minBin),
                max: binToSMagnitude(maxBin),
                center: binToSMagnitude(centerOfMass),
                width: binToSMagnitude(maxBin) - binToSMagnitude(minBin),
                confidence: Math.min(1.0, (maxBin - minBin) / (contentHistogram.length * 0.5))
            };
        }

        function gradientBasedBandDetection(sMagnitudeHistogram, maxSMagnitude, sensitivity) {
            const gradient = [];
            for (let i = 1; i < sMagnitudeHistogram.length - 1; i++) {
                gradient[i] = sMagnitudeHistogram[i + 1] - sMagnitudeHistogram[i - 1];
            }
            
            const threshold = Math.max(...gradient) * sensitivity;
            let risingEdges = [];
            let fallingEdges = [];
            
            for (let i = 0; i < gradient.length; i++) {
                if (gradient[i] > threshold) risingEdges.push(i);
                if (gradient[i] < -threshold) fallingEdges.push(i);
            }
            
            if (risingEdges.length === 0 || fallingEdges.length === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            const binToSMagnitude = (bin) => (bin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const bandMin = binToSMagnitude(risingEdges[0]);
            const bandMax = binToSMagnitude(fallingEdges[fallingEdges.length - 1]);
            
            return {
                min: bandMin,
                max: bandMax,
                center: (bandMin + bandMax) / 2,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, (risingEdges.length + fallingEdges.length) / 10)
            };
        }

        function statisticalBandDetection(sMagnitudeHistogram, contentHistogram, maxSMagnitude, sensitivity) {
            let mean = 0, variance = 0, total = 0;
            
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                const count = sMagnitudeHistogram[i];
                mean += i * count;
                total += count;
            }
            
            if (total === 0) {
                return { min: 0, max: maxSMagnitude, center: maxSMagnitude / 2, width: maxSMagnitude, confidence: 0.1 };
            }
            
            mean /= total;
            
            for (let i = 0; i < sMagnitudeHistogram.length; i++) {
                const count = sMagnitudeHistogram[i];
                variance += Math.pow(i - mean, 2) * count;
            }
            variance /= total;
            
            const stdDev = Math.sqrt(variance);
            const bandHalfWidth = stdDev * (2 - sensitivity);
            
            const binToSMagnitude = (bin) => (bin / (sMagnitudeHistogram.length - 1)) * maxSMagnitude;
            const center = binToSMagnitude(mean);
            const bandMin = Math.max(0, center - binToSMagnitude(bandHalfWidth));
            const bandMax = Math.min(maxSMagnitude, center + binToSMagnitude(bandHalfWidth));
            
            return {
                min: bandMin,
                max: bandMax,
                center: center,
                width: bandMax - bandMin,
                confidence: Math.min(1.0, stdDev / (sMagnitudeHistogram.length * 0.2))
            };
        }

        function smoothHistogram(histogram, radius) {
            const smoothed = new Array(histogram.length).fill(0);
            for (let i = 0; i < histogram.length; i++) {
                let sum = 0, count = 0;
                for (let j = Math.max(0, i - radius); j <= Math.min(histogram.length - 1, i + radius); j++) {
                    sum += histogram[j];
                    count++;
                }
                smoothed[i] = sum / count;
            }
            return smoothed;
        }

        function findHistogramPeaks(histogram, sensitivity) {
            const peaks = [];
            const minPeakHeight = Math.max(...histogram) * sensitivity * 0.1;
            
            for (let i = 1; i < histogram.length - 1; i++) {
                if (histogram[i] > histogram[i - 1] && 
                    histogram[i] > histogram[i + 1] && 
                    histogram[i] > minPeakHeight) {
                    peaks.push({
                        bin: i,
                        strength: histogram[i]
                    });
                }
            }
            
            return peaks;
        }

function generateBandFocusedDepth(imageData, config, detectedBand) {
    console.log('📡 Generating precise Hadit depth map with contrast enhancement...');
    const startTime = performance.now();
    
    const { width, height, data } = imageData;
    const depthBuffer = new Array(width * height);
    
    currentSBounds = config.sBounds;
    
    let minDepth = 1, maxDepth = 0, totalDepth = 0;
    let pixelsInBand = 0, pixelsOutsideBand = 0;
    let bandDepthSum = 0, outsideDepthSum = 0;
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const pixelIdx = idx * 4;
            
            const r = data[pixelIdx] / 255;
            const g = data[pixelIdx + 1] / 255;
            const b = data[pixelIdx + 2] / 255;
            
            const lum = 0.299 * r + 0.587 * g + 0.114 * b;
            const maxCol = Math.max(r, g, b);
            const minCol = Math.min(r, g, b);
            const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
            
            const result = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
            const { sCoord, sMagnitude } = result;
            
            const isInBand = sMagnitude >= detectedBand.min && sMagnitude <= detectedBand.max;
            const distanceFromBandCenter = Math.abs(sMagnitude - detectedBand.center);
            const bandPosition = Math.max(0, Math.min(1, (sMagnitude - detectedBand.min) / Math.max(0.001, detectedBand.width)));
            
            // DEPTH SOURCE SELECTION - Choose depth calculation method based on config.depthSource
            let depth;
            switch (config.depthSource) {
                case 'sMagnitude':
                    depth = calculateDepthFromSCoords(x, y, width, height, config);
                    break;
                case 'angular':
                    depth = calculateAngularDepth(x, y, width, height, config);
                    break;
                case 'brightness':
                default:
                    // Original brightness/saturation based calculation
                    depth = 0.1 + lum * 0.6 + sat * 0.3;
                    break;
            }
            
            let bandCenteredness = 0;
            
            if (isInBand) {
                pixelsInBand++;
                
                bandCenteredness = detectedBand.width > 0 ? 
                    1.0 - (distanceFromBandCenter / (detectedBand.width * 0.5)) : 1.0;
                bandCenteredness = Math.max(0, Math.min(1, bandCenteredness));
                
                // Apply band-specific modulation only for brightness/saturation mode
                if (config.depthSource === 'brightness' || !config.depthSource) {
                    const contentWeight = lum * 0.5 + sat * 0.3;
                    
                    depth = 0.3 + bandPosition * 0.6;
                    depth *= (1 + Math.max(0, bandCenteredness) * config.focusFactor * 0.2);
                    depth *= (1 + contentWeight * 0.3);
                }
                
                bandDepthSum += depth;
                
            } else {
                pixelsOutsideBand++;
                
                // Apply focus-only-band logic only for brightness/saturation mode
                if (config.depthSource === 'brightness' || !config.depthSource) {
                    if (config.focusOnlyBand) {
                        depth = 0.05 + (lum * 0.1);
                    } else {
                        const falloffDistance = Math.min(
                            Math.abs(sMagnitude - detectedBand.min),
                            Math.abs(sMagnitude - detectedBand.max)
                        );
                        const falloffFactor = 1.0 / (1.0 + falloffDistance * 0.5);
                        depth = 0.1 + lum * 0.2 * falloffFactor;
                    }
                }
                
                outsideDepthSum += depth;
            }
            
            // Apply focus factor enhancement for in-band pixels
            if (isInBand && config.focusFactor > 1.0) {
                depth = 0.5 + (depth - 0.5) * config.focusFactor;
            }
            
            depth = applyDepthContrast(depth, config.depthContrast, bandCenteredness);
            
            depth = Math.max(0.05, Math.min(1.0, depth));
            
            minDepth = Math.min(minDepth, depth);
            maxDepth = Math.max(maxDepth, depth);
            totalDepth += depth;
            
            depthBuffer[idx] = {
                depth: depth,
                sCoord: sCoord,
                sMagnitude: sMagnitude,
                isInBand: isInBand,
                bandPosition: bandPosition,
                distanceFromBandCenter: distanceFromBandCenter,
                bandCenteredness: bandCenteredness,
                luminance: lum,
                saturation: sat,
                haditResult: result,
                coverage: true
            };
        }
    }
    
    const processingTime = performance.now() - startTime;
    const avgDepth = totalDepth / (width * height);
    const avgBandDepth = pixelsInBand > 0 ? bandDepthSum / pixelsInBand : 0;
    const avgOutsideDepth = pixelsOutsideBand > 0 ? outsideDepthSum / pixelsOutsideBand : 0;
    
    console.log(`✅ Precise depth with contrast generated in ${processingTime.toFixed(2)}ms`);
    console.log(`   θ=${config.haditTheta.toFixed(1)}°, φ=${config.haditPhi.toFixed(1)}°, Contrast=${config.depthContrast.toFixed(1)}x`);
    console.log(`   Pixels in band: ${pixelsInBand}/${width * height} (${(pixelsInBand/(width*height)*100).toFixed(1)}%)`);
    console.log(`   Depth source: ${config.depthSource || 'brightness'}`);
    
    return {
        depthBuffer,
        stats: {
            processingTime,
            minDepth,
            maxDepth,
            avgDepth,
            avgBandDepth,
            avgOutsideDepth,
            pixelsInBand,
            pixelsOutsideBand,
            bandCoverage: pixelsInBand / (width * height)
        }
    };
}
        function applyHaditStereoWithDepth(sourceCanvas, depthBuffer, config, isRightEye = false) {
            const sourceCtx = sourceCanvas.getContext('2d');
            const sourceImageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
            
            const outputImageData = new ImageData(sourceCanvas.width, sourceCanvas.height);
            const { width, height } = sourceImageData;
            
            const separationPixels = config.separation;
            const depthIntensity = config.depthIntensity;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    if (idx < depthBuffer.length && depthBuffer[idx]) {
                        const depthInfo = depthBuffer[idx];
                        const normalizedDepth = depthInfo.depth;
                        
                        let offsetX = (normalizedDepth - 0.5) * separationPixels * depthIntensity;
                        if (isRightEye) offsetX = -offsetX;
                        
                        const sourceX = Math.round(x - offsetX);
                        
                        if (sourceX >= 0 && sourceX < width) {
                            const sourceIdx = y * width + sourceX;
                            const sourcePixelIdx = sourceIdx * 4;
                            
                            outputImageData.data[pixelIdx] = sourceImageData.data[sourcePixelIdx];
                            outputImageData.data[pixelIdx + 1] = sourceImageData.data[sourcePixelIdx + 1];
                            outputImageData.data[pixelIdx + 2] = sourceImageData.data[sourcePixelIdx + 2];
                            outputImageData.data[pixelIdx + 3] = sourceImageData.data[sourcePixelIdx + 3];
                        } else {
                            outputImageData.data[pixelIdx] = 0;
                            outputImageData.data[pixelIdx + 1] = 0;
                            outputImageData.data[pixelIdx + 2] = 0;
                            outputImageData.data[pixelIdx + 3] = 255;
                        }
                    } else {
                        outputImageData.data[pixelIdx] = sourceImageData.data[pixelIdx];
                        outputImageData.data[pixelIdx + 1] = sourceImageData.data[pixelIdx + 1];
                        outputImageData.data[pixelIdx + 2] = sourceImageData.data[pixelIdx + 2];
                        outputImageData.data[pixelIdx + 3] = sourceImageData.data[pixelIdx + 3];
                    }
                }
            }
            
            return outputImageData;
        }

function calculateDepthFromSCoords(px, py, width, height, config) {
    const result = calculateHaditModulatedSCoordinate(px, py, width, height, 0, 0, config);
    const { sMagnitude } = result;
    
    // Use logarithmic scaling to handle larger S-magnitude ranges
    const logS = Math.log(1 + sMagnitude);
    const maxLogS = Math.log(1 + config.sBounds);
    const normalizedS = Math.min(logS / maxLogS, 1.0);
    const depth = 0.1 + (normalizedS * 0.8); // Maps to 0.1-0.9 range
    
    return Math.max(0.05, Math.min(1.0, depth));
}

function calculateAngularDepth(px, py, width, height, config) {
    const result = calculateHaditModulatedSCoordinate(px, py, width, height, 0, 0, config);
    const { originalG, reflectedG, haditVector } = result;
    
    // Calculate angle between original and reflected vectors
    const dotProduct = vectorOps.dot(originalG, reflectedG);
    const angle = Math.acos(Math.max(-1, Math.min(1, dotProduct)));
    
    // Larger angles = more depth
    const normalizedAngle = angle / Math.PI;
    return 0.1 + (normalizedAngle * 0.8);
}


        
function visualizeDepthMap(depthBuffer, canvas, config, detectedBand) {
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;
    
    const imageData = new ImageData(width, height);
    
    // First pass: find the actual depth range for better visualization
    let minActualDepth = 1.0;
    let maxActualDepth = 0.0;
    
    for (let i = 0; i < depthBuffer.length; i++) {
        if (depthBuffer[i] && depthBuffer[i].depth !== undefined) {
            minActualDepth = Math.min(minActualDepth, depthBuffer[i].depth);
            maxActualDepth = Math.max(maxActualDepth, depthBuffer[i].depth);
        }
    }
    
    const depthRange = maxActualDepth - minActualDepth;
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const pixelIdx = idx * 4;
            
            if (idx < depthBuffer.length && depthBuffer[idx]) {
                const depthInfo = depthBuffer[idx];
                let depth = depthInfo.depth;
                
                let r, g, b;
                
                if (config.showBandVisualization && depthInfo.isInBand) {
                    const bandCenteredness = depthInfo.bandCenteredness;
                    r = Math.floor(255 * (1 - bandCenteredness) + 255 * bandCenteredness * 0.2);
                    g = Math.floor(255 * bandCenteredness + 100 * (1 - bandCenteredness));
                    b = Math.floor(100 + 155 * (1 - bandCenteredness));
                } else {
                    // Enhanced visualization for S-magnitude and other geometric modes
                    if (config.depthSource === 'sMagnitude' || config.depthSource === 'angular') {
                        // Normalize depth to the actual range for better contrast
                        const normalizedDepth = depthRange > 0 ? (depth - minActualDepth) / depthRange : 0.5;
                        
                        // Use a colorful heatmap for geometric depth
                        if (normalizedDepth < 0.25) {
                            // Blue to cyan
                            r = 0;
                            g = Math.floor(normalizedDepth * 4 * 255);
                            b = 255;
                        } else if (normalizedDepth < 0.5) {
                            // Cyan to green
                            r = 0;
                            g = 255;
                            b = Math.floor((0.5 - normalizedDepth) * 4 * 255);
                        } else if (normalizedDepth < 0.75) {
                            // Green to yellow
                            r = Math.floor((normalizedDepth - 0.5) * 4 * 255);
                            g = 255;
                            b = 0;
                        } else {
                            // Yellow to red
                            r = 255;
                            g = Math.floor((1.0 - normalizedDepth) * 4 * 255);
                            b = 0;
                        }
                    } else {
                        // Standard grayscale for brightness mode
                        const intensity = Math.floor(depth * 255);
                        r = intensity;
                        g = intensity;
                        b = intensity;
                    }
                }
                
                imageData.data[pixelIdx] = r;
                imageData.data[pixelIdx + 1] = g;
                imageData.data[pixelIdx + 2] = b;
                imageData.data[pixelIdx + 3] = 255;
            } else {
                imageData.data[pixelIdx] = 0;
                imageData.data[pixelIdx + 1] = 0;
                imageData.data[pixelIdx + 2] = 0;
                imageData.data[pixelIdx + 3] = 255;
            }
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    // Add debug info for S-magnitude mode
    if (config.depthSource === 'sMagnitude') {
        ctx.font = '10px monospace';
        ctx.fillStyle = 'white';
        ctx.fillText(`Depth Range: ${minActualDepth.toFixed(3)} - ${maxActualDepth.toFixed(3)}`, 5, height - 25);
        ctx.fillText(`S-Magnitude Mode`, 5, height - 10);
    }
}
        
        // ==================== CAMERA AND VIDEO PROCESSING (WORKING ORIGINAL + OPTIONAL GPU) ====================
        
        let gpuProcessor = new WebGLProcessor();
        let videoElement = null;
        let animationFrameId = null;
        let processedFrames = 0;
        let startTime = Date.now();
        let currentConfig = {
            haditTheta: 0.0,
            haditPhi: 0.1,
            haditInfluence: 1.0,
            separation: 8,
            depthIntensity: 2.0,
            depthContrast: 0.2,
            sBounds: 20.0,
            bandDetectionMode: 'auto_detect',
            depthSource: 'sMagnitude',
            bandSizeMultiplier: 10.0,
            focusFactor: 4.0,
            luminosityWeight: 0.0,
            saturationWeight: 0.0,
            enableStereo: true,
            showDepthMap: true,
            showBandVisualization: false,
            focusOnlyBand: false,
            mirrorCamera: false,
            showFPS: true,
            debugMode: true,
            showRawFeed: false,
            useGPU: false, // Disabled by default to keep original working
            qualityScale: 0.75
        };

        const leftCanvas = document.getElementById('leftCanvas');
        const rightCanvas = document.getElementById('rightCanvas');
        const depthCanvas = document.getElementById('depthCanvas');
        const debugVideo = document.getElementById('debugVideo');

        function initializeCanvases() {
            const leftCtx = leftCanvas.getContext('2d');
            const rightCtx = rightCanvas.getContext('2d');
            const depthCtx = depthCanvas.getContext('2d');
            
            leftCtx.fillStyle = '#000';
            leftCtx.fillRect(0, 0, leftCanvas.width, leftCanvas.height);
            rightCtx.fillStyle = '#000';
            rightCtx.fillRect(0, 0, rightCanvas.width, rightCanvas.height);
            depthCtx.fillStyle = '#000';
            depthCtx.fillRect(0, 0, depthCanvas.width, depthCanvas.height);
        }

        function updateFPS() {
            if (!currentConfig.showFPS) return;
            
            const currentTime = Date.now();
            const elapsedTime = (currentTime - startTime) / 1000;
            const fps = elapsedTime > 0 ? (processedFrames / elapsedTime).toFixed(1) : '0';
            
            document.getElementById('leftFps').textContent = `${fps} FPS`;
            document.getElementById('rightFps').textContent = `${fps} FPS`;
            document.getElementById('depthFps').textContent = `${fps} FPS`;
        }

        // MAIN PROCESSING LOOP - KEEPS YOUR ORIGINAL CPU CODE WORKING
function processFrame() {
    if (!videoElement || videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
        animationFrameId = requestAnimationFrame(processFrame);
        return;
    }
    
    try {
        const perfStart = performance.now();
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = videoElement.videoWidth * currentConfig.qualityScale;
        tempCanvas.height = videoElement.videoHeight * currentConfig.qualityScale;
        const tempCtx = tempCanvas.getContext('2d');
        
        if (currentConfig.mirrorCamera) {
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(videoElement, -tempCanvas.width, 0, tempCanvas.width, tempCanvas.height);
        } else {
            tempCtx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);
        }
        
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        
        // ALWAYS use CPU for your core Hadit processing - this never changes
        const bandResult = detectHaditInformationBand(imageData, currentConfig);
        detectedBand = bandResult.band;
        
        const depthResult = generateBandFocusedDepth(imageData, currentConfig, detectedBand);
        
        // Resize canvases if needed
        if (leftCanvas.width !== tempCanvas.width || leftCanvas.height !== tempCanvas.height) {
            leftCanvas.width = tempCanvas.width;
            leftCanvas.height = tempCanvas.height;
            rightCanvas.width = tempCanvas.width;
            rightCanvas.height = tempCanvas.height;
        }
        
        if (depthCanvas.width !== tempCanvas.width || depthCanvas.height !== tempCanvas.height) {
            depthCanvas.width = tempCanvas.width;
            depthCanvas.height = tempCanvas.height;
        }
        
        // Draw original frame to left canvas
        const leftCtx = leftCanvas.getContext('2d');
        leftCtx.putImageData(imageData, 0, 0);
        
        // Stereo processing with multiple options
        if (currentConfig.enableStereo) {
            let usedGPUHoleFilling = false;
            let stereoMode = 'CPU';
            
            // Try GPU hole filling ONLY for stereo rendering (uses CPU depth data)
            if (currentConfig.useGPU && 
                currentConfig.gpuStereoMode !== 'cpu' &&
                gpuProcessor.isInitialized && 
                gpuProcessor.gpuEnabled) {
                
                try {
                    // Convert YOUR CPU depth buffer to GPU format for hole filling
                    const gpuDepthData = convertDepthBufferToGPUFormat(depthResult.depthBuffer, tempCanvas.width, tempCanvas.height);
                    
                    const success = gpuProcessor.renderStereoWithHoleFilling(
                        leftCanvas, rightCanvas, imageData, gpuDepthData, currentConfig
                    );
                    
                    if (success) {
                        usedGPUHoleFilling = true;
                        stereoMode = `GPU ${currentConfig.useBidirectional ? 'Bidirectional' : 'Forward'} Hole Fill`;
                    }
                } catch (error) {
                    console.warn('GPU hole filling failed, using CPU:', error);
                }
            }
            
            // Use CPU stereo if GPU hole filling not used
            if (!usedGPUHoleFilling) {
                if (currentConfig.useCPUHoleFilling) {
                    // CPU stereo with CPU hole filling
                    const leftStereoData = applyHaditStereoWithDepthAndHoleFilling(leftCanvas, depthResult.depthBuffer, currentConfig, false);
                    const rightStereoData = applyHaditStereoWithDepthAndHoleFilling(leftCanvas, depthResult.depthBuffer, currentConfig, true);
                    
                    leftCtx.putImageData(leftStereoData, 0, 0);
                    
                    const rightCtx = rightCanvas.getContext('2d');
                    rightCtx.putImageData(rightStereoData, 0, 0);
                    
                    stereoMode = 'CPU + CPU Hole Fill';
                } else {
                    // Your original CPU stereo (no hole filling)
                    const leftStereoData = applyHaditStereoWithDepth(leftCanvas, depthResult.depthBuffer, currentConfig, false);
                    const rightStereoData = applyHaditStereoWithDepth(leftCanvas, depthResult.depthBuffer, currentConfig, true);
                    
                    leftCtx.putImageData(leftStereoData, 0, 0);
                    
                    const rightCtx = rightCanvas.getContext('2d');
                    rightCtx.putImageData(rightStereoData, 0, 0);
                    
                    stereoMode = 'CPU Original';
                }
            }
            
            console.log(`🎮 Stereo mode: ${stereoMode}`);
        } else {
            const rightCtx = rightCanvas.getContext('2d');
            rightCtx.putImageData(imageData, 0, 0);
        }
        
        // ALWAYS update depth map visualization using YOUR CPU Hadit depth buffer
        if (currentConfig.showDepthMap) {
            visualizeDepthMap(depthResult.depthBuffer, depthCanvas, currentConfig, detectedBand);
        }
        
        const perfEnd = performance.now();
        const processingTime = perfEnd - perfStart;
        
        processedFrames++;
        updateFPS();
        
        // Update processing mode indicator
        const analysisPanel = document.getElementById('analysisPanel');
        if (analysisPanel) {
            const depthMode = '⚙️ Pure CPU Hadit';
            const stereoMode = usedGPUHoleFilling ? 
                              `🔥 GPU Hole Fill (CPU Depth)` : 
                              (currentConfig.useCPUHoleFilling ? '🔧 CPU + CPU Hole Fill' : '⚙️ CPU Original');
            const performanceText = `Depth: ${depthMode} | Stereo: ${stereoMode} | ${processingTime.toFixed(1)}ms/frame`;
            
            const lines = analysisPanel.innerHTML.split('<div>');
            if (lines.length > 3) {
                lines[3] = `${performanceText}</div>`;
            } else {
                lines.push(`${performanceText}</div>`);
            }
            analysisPanel.innerHTML = lines.join('<div>');
        }
        
    } catch (error) {
        console.error('Frame processing error:', error);
    }
    
    animationFrameId = requestAnimationFrame(processFrame);
}

        // Helper function to convert GPU depth data to your depth buffer format
        function convertGPUDepthToBuffer(gpuDepthData, width, height, originalImageData, config, detectedBand) {
            const depthBuffer = new Array(width * height);
            
            for (let i = 0; i < width * height; i++) {
                const pixelIdx = i * 4;
                const depth = gpuDepthData[pixelIdx] / 255; // Convert back to 0-1 range
                
                // Add minimal metadata for compatibility with your stereo function
                const y = Math.floor(i / width);
                const x = i % width;
                
                const originalPixelIdx = i * 4;
                const r = originalImageData.data[originalPixelIdx] / 255;
                const g = originalImageData.data[originalPixelIdx + 1] / 255;
                const b = originalImageData.data[originalPixelIdx + 2] / 255;
                
                const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                const maxCol = Math.max(r, g, b);
                const minCol = Math.min(r, g, b);
                const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                
                const result = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                const isInBand = result.sMagnitude >= detectedBand.min && result.sMagnitude <= detectedBand.max;
                
                depthBuffer[i] = {
                    depth: depth,
                    sCoord: result.sCoord,
                    sMagnitude: result.sMagnitude,
                    isInBand: isInBand,
                    bandCenteredness: isInBand ? 1.0 - Math.abs(result.sMagnitude - detectedBand.center) / (detectedBand.width * 0.5) : 0,
                    luminance: lum,
                    saturation: sat,
                    coverage: true
                };
            }
            
            return depthBuffer;
        }

        // ==================== ALL YOUR ORIGINAL CAMERA AND UI CODE (UNCHANGED) ====================
        
        let stream = null;
        let devices = [];
        let currentDeviceIndex = 0;
        let animationActive = false;
        let animationDirection = 1;
        let animationTarget = 'theta';

        async function startCamera() {
            try {
                document.getElementById('cameraStatus').innerHTML = '<span class="status-connecting">📹 Starting camera...</span>';
                
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                const resolution = document.getElementById('resolutionSelect').value;
                const [width, height] = resolution.split('x').map(Number);
                const facingMode = document.getElementById('facingMode').value;

                const constraints = {
                    video: {
                        width: { ideal: width },
                        height: { ideal: height },
                        facingMode: facingMode
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                if (!videoElement) {
                    videoElement = document.getElementById('debugVideo');
                }
                
                videoElement.srcObject = stream;
                
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });

                document.getElementById('cameraStatus').innerHTML = '<span class="status-active">📹 Camera active</span>';
                document.getElementById('startCamera').style.display = 'none';
                document.getElementById('switchCamera').style.display = 'inline-block';
                document.getElementById('stopCamera').style.display = 'inline-block';
                
                if (!animationFrameId) {
                    processFrame();
                }
                
                startTime = Date.now();
                processedFrames = 0;

            } catch (error) {
                console.error('Camera error:', error);
                document.getElementById('errorPanel').style.display = 'block';
                document.getElementById('errorMessage').textContent = error.message;
                document.getElementById('cameraStatus').innerHTML = '<span class="status-error">📹 Camera error</span>';
            }
        }

        async function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            if (videoElement) {
                videoElement.srcObject = null;
            }
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            document.getElementById('cameraStatus').innerHTML = '<span class="status-connecting">📹 Camera stopped</span>';
            document.getElementById('startCamera').style.display = 'inline-block';
            document.getElementById('switchCamera').style.display = 'none';
            document.getElementById('stopCamera').style.display = 'none';
        }

        async function switchCamera() {
            try {
                devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (videoDevices.length > 1) {
                    currentDeviceIndex = (currentDeviceIndex + 1) % videoDevices.length;
                    const selectedDevice = videoDevices[currentDeviceIndex];
                    
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop());
                    }

                    const resolution = document.getElementById('resolutionSelect').value;
                    const [width, height] = resolution.split('x').map(Number);

                    const constraints = {
                        video: {
                            deviceId: { exact: selectedDevice.deviceId },
                            width: { ideal: width },
                            height: { ideal: height }
                        }
                    };

                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    videoElement.srcObject = stream;
                }
            } catch (error) {
                console.error('Switch camera error:', error);
            }
        }

        async function requestPermissions() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(track => track.stop());
                document.getElementById('cameraStatus').innerHTML = '<span class="status-active">📹 Permissions granted</span>';
            } catch (error) {
                document.getElementById('errorPanel').style.display = 'block';
                document.getElementById('errorMessage').textContent = 'Camera permission denied: ' + error.message;
            }
        }

        function toggleDebugVideo() {
            const debugVideo = document.getElementById('debugVideo');
            if (debugVideo.style.display === 'none') {
                debugVideo.style.display = 'block';
            } else {
                debugVideo.style.display = 'none';
            }
        }

        function startThetaAnimation() {
            if (animationActive) return;
            animationActive = true;
            animationTarget = 'theta';
            animationDirection = 1;
            animateValues();
        }

        function startPhiAnimation() {
            if (animationActive) return;
            animationActive = true;
            animationTarget = 'phi';
            animationDirection = 1;
            animateValues();
        }

        function stopAllAnimations() {
            animationActive = false;
        }

        function animateValues() {
            if (!animationActive) return;
            
            if (animationTarget === 'theta') {
                currentConfig.haditTheta += animationDirection * 0.5;
                if (currentConfig.haditTheta >= 360) {
                    currentConfig.haditTheta = 0;
                } else if (currentConfig.haditTheta < 0) {
                    currentConfig.haditTheta = 359.5;
                }
                
                document.getElementById('haditTheta').value = currentConfig.haditTheta;
                document.getElementById('haditThetaNumber').value = currentConfig.haditTheta;
                document.getElementById('haditThetaValue').textContent = currentConfig.haditTheta.toFixed(1) + '°';
                
            } else if (animationTarget === 'phi') {
                currentConfig.haditPhi += animationDirection * 0.2;
                if (currentConfig.haditPhi >= 179.9) {
                    animationDirection = -1;
                } else if (currentConfig.haditPhi <= 0.1) {
                    animationDirection = 1;
                }
                
                currentConfig.haditPhi = Math.max(0.1, Math.min(179.9, currentConfig.haditPhi));
                
                document.getElementById('haditPhi').value = currentConfig.haditPhi;
                document.getElementById('haditPhiNumber').value = currentConfig.haditPhi;
                document.getElementById('haditPhiValue').textContent = currentConfig.haditPhi.toFixed(1) + '°';
            }
            
            setTimeout(animateValues, 50);
        }

        // ==================== EVENT LISTENERS (ORIGINAL + GPU TOGGLE) ====================

        document.addEventListener('DOMContentLoaded', async function() {
            initializeCanvases();

            // Camera controls
            document.getElementById('startCamera').addEventListener('click', startCamera);
            document.getElementById('stopCamera').addEventListener('click', stopCamera);
            document.getElementById('switchCamera').addEventListener('click', switchCamera);
            document.getElementById('requestPermissions').addEventListener('click', requestPermissions);
            document.getElementById('toggleDebugVideo').addEventListener('click', toggleDebugVideo);

            // Hadit controls with dual sync
            const haditThetaSlider = document.getElementById('haditTheta');
            const haditThetaNumber = document.getElementById('haditThetaNumber');
            const haditThetaValue = document.getElementById('haditThetaValue');

            function updateHaditTheta(value) {
                currentConfig.haditTheta = parseFloat(value);
                haditThetaSlider.value = value;
                haditThetaNumber.value = value;
                haditThetaValue.textContent = parseFloat(value).toFixed(1) + '°';
            }

            haditThetaSlider.addEventListener('input', (e) => updateHaditTheta(e.target.value));
            haditThetaNumber.addEventListener('input', (e) => updateHaditTheta(e.target.value));

            const haditPhiSlider = document.getElementById('haditPhi');
            const haditPhiNumber = document.getElementById('haditPhiNumber');
            const haditPhiValue = document.getElementById('haditPhiValue');

            function updateHaditPhi(value) {
                currentConfig.haditPhi = parseFloat(value);
                haditPhiSlider.value = value;
                haditPhiNumber.value = value;
                haditPhiValue.textContent = parseFloat(value).toFixed(1) + '°';
            }

            haditPhiSlider.addEventListener('input', (e) => updateHaditPhi(e.target.value));
            haditPhiNumber.addEventListener('input', (e) => updateHaditPhi(e.target.value));

            // All other controls (unchanged from your original)
            document.getElementById('haditInfluence').addEventListener('input', (e) => {
                currentConfig.haditInfluence = parseFloat(e.target.value);
                document.getElementById('haditInfluenceValue').textContent = parseFloat(e.target.value).toFixed(1);
            });

            document.getElementById('separation').addEventListener('input', (e) => {
                currentConfig.separation = parseFloat(e.target.value);
                document.getElementById('separationValue').textContent = e.target.value + 'px';
            });

            document.getElementById('depthIntensity').addEventListener('input', (e) => {
                currentConfig.depthIntensity = parseFloat(e.target.value);
                document.getElementById('depthIntensityValue').textContent = parseFloat(e.target.value).toFixed(1) + 'x';
            });

            document.getElementById('depthContrast').addEventListener('input', (e) => {
                currentConfig.depthContrast = parseFloat(e.target.value);
                document.getElementById('depthContrastValue').textContent = parseFloat(e.target.value).toFixed(1) + 'x';
            });

            document.getElementById('sBounds').addEventListener('input', (e) => {
                currentConfig.sBounds = parseFloat(e.target.value);
                document.getElementById('sBoundsValue').textContent = '±' + parseFloat(e.target.value).toFixed(1);
            });

            document.getElementById('bandSizeMultiplier').addEventListener('input', (e) => {
                currentConfig.bandSizeMultiplier = parseFloat(e.target.value);
                document.getElementById('bandSizeMultiplierValue').textContent = parseFloat(e.target.value).toFixed(1) + 'x';
            });

            document.getElementById('focusFactor').addEventListener('input', (e) => {
                currentConfig.focusFactor = parseFloat(e.target.value);
                document.getElementById('focusFactorValue').textContent = parseFloat(e.target.value).toFixed(1) + 'x';
            });

            document.getElementById('luminosityWeight').addEventListener('input', (e) => {
                currentConfig.luminosityWeight = parseFloat(e.target.value);
                document.getElementById('luminosityWeightValue').textContent = parseFloat(e.target.value).toFixed(2);
            });

            document.getElementById('saturationWeight').addEventListener('input', (e) => {
                currentConfig.saturationWeight = parseFloat(e.target.value);
                document.getElementById('saturationWeightValue').textContent = parseFloat(e.target.value).toFixed(2);
            });

            document.getElementById('bandDetectionMode').addEventListener('change', (e) => {
                currentConfig.bandDetectionMode = e.target.value;
            });

            document.getElementById('qualitySelect').addEventListener('change', (e) => {
                currentConfig.qualityScale = parseFloat(e.target.value);
            });

            // Checkbox controls
            document.getElementById('enableStereo').addEventListener('change', (e) => {
                currentConfig.enableStereo = e.target.checked;
            });

            document.getElementById('showDepthMap').addEventListener('change', (e) => {
                currentConfig.showDepthMap = e.target.checked;
            });

            document.getElementById('showBandVisualization').addEventListener('change', (e) => {
                currentConfig.showBandVisualization = e.target.checked;
            });

            document.getElementById('depthSource').addEventListener('change', function(e) {
                currentConfig.depthSource = e.target.value;
            });

            document.getElementById('focusOnlyBand').addEventListener('change', (e) => {
                currentConfig.focusOnlyBand = e.target.checked;
            });

            document.getElementById('mirrorCamera').addEventListener('change', (e) => {
                currentConfig.mirrorCamera = e.target.checked;
            });

            document.getElementById('showFPS').addEventListener('change', (e) => {
                currentConfig.showFPS = e.target.checked;
                if (!e.target.checked) {
                    document.getElementById('leftFps').textContent = '';
                    document.getElementById('rightFps').textContent = '';
                    document.getElementById('depthFps').textContent = '';
                }
            });

            document.getElementById('debugMode').addEventListener('change', (e) => {
                currentConfig.debugMode = e.target.checked;
            });

            document.getElementById('showRawFeed').addEventListener('change', (e) => {
                currentConfig.showRawFeed = e.target.checked;
                const debugVideo = document.getElementById('debugVideo');
                debugVideo.style.display = e.target.checked ? 'block' : 'none';
            });

            // NEW GPU control - only initializes when enabled
            document.getElementById('useGPU').addEventListener('change', async (e) => {
                currentConfig.useGPU = e.target.checked;
                
                if (e.target.checked && !gpuProcessor.isInitialized) {
                    console.log('Initializing GPU acceleration...');
                    await gpuProcessor.initialize();
                } else if (!e.target.checked) {
                    document.getElementById('gpuStatus').style.display = 'none';
                }
            });

            // Preset buttons
            document.getElementById('setHaditPole').addEventListener('click', () => {
                updateHaditPhi(0.1);
            });

            document.getElementById('setHaditEquator').addEventListener('click', () => {
                updateHaditPhi(90.0);
            });

            document.getElementById('setHaditNear180').addEventListener('click', () => {
                updateHaditPhi(179.9);
            });

            document.getElementById('animateTheta').addEventListener('click', startThetaAnimation);
            document.getElementById('animatePhi').addEventListener('click', startPhiAnimation);
            document.getElementById('stopAnimation').addEventListener('click', stopAllAnimations);

            // Depth preset buttons
            document.getElementById('setHighContrast').addEventListener('click', () => {
                currentConfig.depthContrast = 2.5;
                document.getElementById('depthContrast').value = 2.5;
                document.getElementById('depthContrastValue').textContent = '2.5x';
            });

            document.getElementById('setLowContrast').addEventListener('click', () => {
                currentConfig.depthContrast = 0.1;
                document.getElementById('depthContrast').value = 0.1;
                document.getElementById('depthContrastValue').textContent = '0.1x';
            });

            document.getElementById('setExtremeDepth').addEventListener('click', () => {
                currentConfig.depthIntensity = 5.0;
                document.getElementById('depthIntensity').value = 5.0;
                document.getElementById('depthIntensityValue').textContent = '5.0x';
            });

            document.getElementById('setSubtleDepth').addEventListener('click', () => {
                currentConfig.depthIntensity = 0.5;
                document.getElementById('depthIntensity').value = 0.5;
                document.getElementById('depthIntensityValue').textContent = '0.5x';
            });

            // Band action buttons
            document.getElementById('detectBand').addEventListener('click', () => {
                console.log('Manual band detection triggered');
            });

            document.getElementById('expandBandFull').addEventListener('click', () => {
                currentConfig.bandDetectionMode = 'full_image';
                document.getElementById('bandDetectionMode').value = 'full_image';
            });

            document.getElementById('resetBand').addEventListener('click', () => {
                currentConfig.bandDetectionMode = 'auto_detect';
                document.getElementById('bandDetectionMode').value = 'auto_detect';
            });
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>
