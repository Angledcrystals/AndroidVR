<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AndroidVR - Live Hadit Camera</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 5px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-bottom: 15px;
        }

        .camera-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stereo-view {
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .camera-feed {
            position: relative;
        }

        canvas, video {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000; /* Canvas background is black */
            max-width: 100%;
            height: auto;
        }

        .left-eye { border-color: #ff4444 !important; }
        .right-eye { border-color: #4444ff !important; }
        .depth-map { border-color: #ff8800 !important; }
        .raw-video { border-color: #00ff88 !important; } /* For the debug video element */

        .camera-label {
            text-align: center;
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .left-label { color: #ff4444; }
        .right-label { color: #4444ff; }
        .depth-label { color: #ff8800; }
        .raw-label { color: #00ff88; }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #00ff88;
            margin-bottom: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 3px;
            font-size: 10px;
            width: 60px;
        }

        select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            cursor: pointer;
            font-size: 10px;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .camera-control {
            background: rgba(0, 255, 136, 0.2) !important;
            border-color: #00ff88 !important;
        }

        .hadit-control {
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: #ff00ff !important;
        }

        .stereo-control {
            background: rgba(255, 68, 136, 0.2) !important;
            border-color: #ff4488 !important;
        }

        .depth-control {
            background: rgba(255, 136, 0, 0.2) !important;
            border-color: #ff8800 !important;
        }

        .dual-input {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dual-input input[type="range"] {
            flex: 1;
            margin-bottom: 0;
        }

        .dual-input input[type="number"] {
            flex: 0 0 auto;
        }

        .info-panel {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .hadit-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .analysis-panel {
            background: rgba(136, 255, 0, 0.1);
            border: 1px solid #88ff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .processing {
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5) !important;
            animation: processing 1s ease-in-out infinite;
        }

        @keyframes processing {
            0% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
        }

        .fps-counter {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
        }

        .camera-status {
            text-align: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .status-connecting { color: #ffff00; }
        .status-active { color: #00ff88; }
        .status-error { color: #ff4444; }

        .error-message {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #ff4444;
        }

        /* Debug video (visible) */
        #debugVideo {
            max-width: 200px;
            border: 1px solid #ffff00;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .stereo-view {
                flex-direction: column;
                align-items: center;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            
            canvas {
                max-width: 90vw;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AndroidVR - Live Hadit Camera</h1>
        <div class="subtitle">Real-time Fine Hadit Control: 0.1¬∞ Precision | 2025-06-07 07:40:56 UTC | User: Angledcrystals</div>

        <div class="hadit-info">
            <div style="color: #ff00ff; font-weight: bold;">‚ö° Live Hadit Processing:</div>
            <div>‚Ä¢ Real-time camera feed with Hadit depth generation</div>
            <div>‚Ä¢ Œ∏ (Theta): 0¬∞ to 360¬∞ in 0.1¬∞ increments for live adjustment</div>
            <div>‚Ä¢ œÜ (Phi): 0.1¬∞ to 179.9¬∞ in 0.1¬∞ increments for extreme precision</div>
            <div>‚Ä¢ Parallel stereo view with pixel-perfect offset based on Hadit depth</div>
            <div>‚Ä¢ Enhanced debugging for camera feed issues</div>
        </div>

        <div class="camera-status" id="cameraStatus">
            <span class="status-connecting">üìπ Camera system ready - click Start Camera</span>
        </div>

        <div id="errorPanel" class="error-message" style="display: none;">
            <div style="font-weight: bold;">‚ùå Camera Error:</div>
            <div id="errorMessage">Unknown error occurred</div>
            <div style="margin-top: 5px; font-size: 10px;">
                ‚Ä¢ Make sure you allow camera permissions<br>
                ‚Ä¢ Try switching between front/back camera<br>
                ‚Ä¢ Check if another app is using the camera<br>
                ‚Ä¢ Refresh the page and try again
            </div>
        </div>

        <!-- Debug video element (visible for troubleshooting) -->
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="font-size: 11px; color: #ffff00; margin-bottom: 5px;">üîç DEBUG: Raw Camera Feed</div>
            <video id="debugVideo" autoplay playsinline muted class="raw-video" style="display: none;"></video>
        </div>

        <div class="camera-container">
            <div class="stereo-view">
                <div class="camera-feed">
                    <div class="camera-label left-label">Left Eye (Red)</div>
                    <canvas id="leftCanvas" width="640" height="480" class="left-eye"></canvas>
                    <div class="fps-counter" id="leftFps">0 FPS</div>
                </div>
                <div class="camera-feed">
                    <div class="camera-label right-label">Right Eye (Blue)</div>
                    <canvas id="rightCanvas" width="640" height="480" class="right-eye"></canvas>
                    <div class="fps-counter" id="rightFps">0 FPS</div>
                </div>
                <div class="camera-feed">
                    <div class="camera-label depth-label">Hadit Depth</div>
                    <canvas id="depthCanvas" width="320" height="240" class="depth-map"></canvas>
                    <div class="fps-counter" id="depthFps">0 FPS</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>üìπ Camera Control</label>
                <button id="startCamera" class="camera-control">‚ñ∂Ô∏è Start Camera</button>
                <button id="switchCamera" class="camera-control" style="display: none;">üîÑ Switch Camera</button>
                <button id="stopCamera" class="camera-control" style="display: none;">‚èπÔ∏è Stop Camera</button>
                <button id="requestPermissions" class="camera-control">üîë Request Permissions</button>
                <button id="toggleDebugVideo" class="camera-control">üëÅÔ∏è Toggle Debug Video</button>
            </div>
            
            <div class="control-group">
                <label>üìê Camera Settings</label>
                <select id="resolutionSelect" class="camera-control">
                    <option value="320x240">320x240 (Low)</option>
                    <option value="640x480" selected>640x480 (VGA)</option>
                    <option value="1280x720">1280x720 (HD)</option>
                    <option value="1920x1080">1920x1080 (FHD)</option>
                </select>
                <select id="facingMode" class="camera-control">
                    <option value="environment" selected>Back Camera</option>
                    <option value="user">Front Camera</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit Œ∏ (Theta): <span id="haditThetaValue">45.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditTheta" min="0" max="360" value="45" step="0.1" class="hadit-control">
                    <input type="number" id="haditThetaNumber" min="0" max="360" step="0.1" value="45" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit œÜ (Phi): <span id="haditPhiValue">60.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditPhi" min="0.1" max="179.9" value="60" step="0.1" class="hadit-control">
                    <input type="number" id="haditPhiNumber" min="0.1" max="179.9" step="0.1" value="60" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>üåä Hadit Influence: <span id="haditInfluenceValue">1.0</span></label>
                <input type="range" id="haditInfluence" min="0" max="2" value="1.0" step="0.1" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üéØ Focus Factor: <span id="focusFactorValue">2.0x</span></label>
                <input type="range" id="focusFactor" min="1.0" max="5.0" step="0.1" value="2.0" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üëÅÔ∏è Stereo Separation: <span id="separationValue">8px</span></label>
                <input type="range" id="separation" min="0" max="50" value="8" step="1" class="stereo-control">
            </div>
            
            <div class="control-group">
                <label>üó∫Ô∏è Depth Intensity: <span id="depthIntensityValue">1.5x</span></label>
                <input type="range" id="depthIntensity" min="0.1" max="5.0" value="1.5" step="0.1" class="depth-control">
            </div>
            
            <div class="control-group">
                <label>üìê S Bounds: <span id="sBoundsValue">¬±10.0</span></label>
                <input type="range" id="sBounds" min="1.0" max="20.0" step="0.1" value="10.0" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üí° Luminosity Weight: <span id="luminosityWeightValue">0.7</span></label>
                <input type="range" id="luminosityWeight" min="0" max="1" step="0.05" value="0.7">
            </div>
            
            <div class="control-group">
                <label>üåà Saturation Weight: <span id="saturationWeightValue">0.3</span></label>
                <input type="range" id="saturationWeight" min="0" max="1" step="0.05" value="0.3">
            </div>
            
            <div class="control-group">
                <label>‚öôÔ∏è Processing Quality</label>
                <select id="qualitySelect" class="depth-control">
                    <option value="1.0">Full Quality</option>
                    <option value="0.75" selected>High Quality</option>
                    <option value="0.5">Medium Quality</option>
                    <option value="0.25">Low Quality</option>
                </select>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <div>Status: Live Hadit camera system ready... Angledcrystals | 2025-06-07 07:40:56 UTC</div>
        </div>

        <div class="analysis-grid">
            <div>
                <div class="control-group">
                    <label>Quick Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHaditPole" class="hadit-control">œÜ=0.1¬∞ (Pole)</button>
                        <button id="setHaditEquator" class="hadit-control">œÜ=90¬∞ (Equator)</button>
                        <button id="setHaditNear180" class="hadit-control">œÜ=179.9¬∞ (Anti-pole)</button>
                        <button id="animateTheta" class="hadit-control">üåÄ Animate Œ∏</button>
                        <button id="animatePhi" class="hadit-control">üåä Animate œÜ</button>
                        <button id="stopAnimation" class="hadit-control">‚èπÔ∏è Stop All</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Options & Debug</label>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label><input type="checkbox" id="enableStereo" checked> Enable Stereo</label>
                        <label><input type="checkbox" id="showDepthMap" checked> Show Depth</label>
                        <label><input type="checkbox" id="mirrorCamera"> Mirror Camera</label>
                        <label><input type="checkbox" id="showFPS" checked> Show FPS</label>
                        <label><input type="checkbox" id="debugMode" checked> Debug Mode</label>
                        <label><input type="checkbox" id="showRawFeed"> Show Raw Feed</label>
                    </div>
                </div>
            </div>
            
            <div class="analysis-panel" id="analysisPanel">
                <div style="color: #88ff00; font-weight: bold;">‚ö° Live Hadit Analysis</div>
                <div>Ready for live camera processing...</div>
                <div>Camera permissions status: checking...</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== HADIT MATHEMATICS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 }; // Or handle as an error/special case
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function calculateHaditModulatedSCoordinate(px, py, width, height, lum, sat, config) {
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            const contentModulation = (1 + lum * config.luminosityWeight + sat * config.saturationWeight);
            
            return {
                x: S_hadit.x * contentModulation * config.haditInfluence,
                y: S_hadit.y * contentModulation * config.haditInfluence
            };
        }

        // ==================== ENHANCED CAMERA SYSTEM WITH DEBUGGING ====================
        
        class LiveHaditCamera {
            constructor() {
                this.video = null; // For processing, will be hidden
                this.debugVideo = document.getElementById('debugVideo'); // For direct user view if toggled
                this.stream = null;
                this.isRunning = false;
                this.animationFrameId = null;
                this.animationId = null; // For theta/phi animation
                this.availableCameras = [];
                this.currentCameraIndex = 0;
                
                this.frameCount = 0;
                this.lastFpsTime = 0;
                this.currentFps = 0;
                
                this.processingCanvas = document.createElement('canvas');
                this.processingCtx = this.processingCanvas.getContext('2d');
                
                this.initializeControls();
                this.setupCanvases();
                this.setupDebugVideo(); // Ensures debugVideo properties are set
                this.checkCameraPermissions();
                this.updateInfoPanel(`Live Hadit camera system ready! | Angledcrystals | ${new Date().toISOString()}`);
                
                console.log('‚úÖ Live Hadit Camera System initialized!');
                console.log('üêõ Debug mode enabled - raw video feed available via toggle');
                console.log('Œ∏ (Theta) range: 0¬∞ to 360¬∞ in 0.1¬∞ increments');
                console.log('œÜ (Phi) range: 0.1¬∞ to 179.9¬∞ in 0.1¬∞ increments');
            }

            setupDebugVideo() {
                // this.debugVideo is already assigned in constructor
                if (this.debugVideo) {
                    this.debugVideo.autoplay = true;
                    this.debugVideo.playsInline = true;
                    this.debugVideo.muted = true;
                    // initial display style is handled by HTML
                } else {
                    console.error("Debug video element not found in HTML!");
                }
            }

            async checkCameraPermissions() {
                try {
                    if (!navigator.permissions || !navigator.permissions.query) {
                        this.updateAnalysisInfo('Camera permission: query API not supported, will try direct access on start.');
                        console.log('Permission query not supported, will try direct access');
                        return;
                    }
                    const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                    this.updateAnalysisInfo(`Camera permission: ${permissionStatus.state}`);
                    
                    if (permissionStatus.state === 'granted') {
                        await this.enumerateCameras();
                    } else if (permissionStatus.state === 'prompt') {
                        this.updateAnalysisInfo('Camera permission: will prompt when starting');
                    } else { // 'denied'
                        this.showError('Camera permission denied. Please enable camera access in browser settings.');
                    }
                    
                    permissionStatus.onchange = () => { // Use onchange for broader compatibility
                        this.updateAnalysisInfo(`Camera permission changed: ${permissionStatus.state}`);
                        if (permissionStatus.state === 'granted' && !this.isRunning) {
                           // Optionally, re-enumerate or prompt user to start if they grant later
                        }
                    };
                    
                } catch (error) {
                    console.error('Error checking camera permissions:', error);
                    this.updateAnalysisInfo('Camera permission: error checking status.');
                }
            }

            async enumerateCameras() {
                try {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                        this.updateAnalysisInfo("Camera enumeration not supported.");
                        return;
                    }
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.availableCameras = devices.filter(device => device.kind === 'videoinput');
                    this.updateAnalysisInfo(`Found ${this.availableCameras.length} camera(s)`);
                    this.availableCameras.forEach((camera, index) => {
                        console.log(`Camera ${index}: ${camera.label || `Camera ${index+1}`} (ID: ${camera.deviceId})`);
                    });
                    if (this.availableCameras.length === 0) {
                        this.updateAnalysisInfo("No video input devices found.");
                    }
                } catch (error) {
                    console.error('Camera enumeration error:', error);
                    this.updateAnalysisInfo('Camera enumeration failed.');
                }
            }

            setupCanvases() {
                this.leftCanvas = document.getElementById('leftCanvas');
                this.rightCanvas = document.getElementById('rightCanvas');
                this.depthCanvas = document.getElementById('depthCanvas');
                
                if (!this.leftCanvas || !this.rightCanvas || !this.depthCanvas) {
                    console.error("One or more display canvases not found!");
                    this.showError("Critical error: Display canvases missing.");
                    return;
                }

                this.leftCtx = this.leftCanvas.getContext('2d');
                this.rightCtx = this.rightCanvas.getContext('2d');
                this.depthCtx = this.depthCanvas.getContext('2d');
            }

            getConfiguration() {
                return {
                    haditTheta: parseFloat(document.getElementById('haditTheta')?.value || 45),
                    haditPhi: parseFloat(document.getElementById('haditPhi')?.value || 60),
                    haditInfluence: parseFloat(document.getElementById('haditInfluence')?.value || 1.0),
                    focusFactor: parseFloat(document.getElementById('focusFactor')?.value || 2.0),
                    separation: parseFloat(document.getElementById('separation')?.value || 8),
                    depthIntensity: parseFloat(document.getElementById('depthIntensity')?.value || 1.5),
                    sBounds: parseFloat(document.getElementById('sBounds')?.value || 10.0),
                    luminosityWeight: parseFloat(document.getElementById('luminosityWeight')?.value || 0.7),
                    saturationWeight: parseFloat(document.getElementById('saturationWeight')?.value || 0.3),
                    quality: parseFloat(document.getElementById('qualitySelect')?.value || 0.75),
                    enableStereo: document.getElementById('enableStereo')?.checked ?? true,
                    showDepthMap: document.getElementById('showDepthMap')?.checked ?? true,
                    mirrorCamera: document.getElementById('mirrorCamera')?.checked ?? false,
                    showFPS: document.getElementById('showFPS')?.checked ?? true,
                    debugMode: document.getElementById('debugMode')?.checked ?? false,
                    showRawFeed: document.getElementById('showRawFeed')?.checked ?? false // For the debugVideo visibility
                };
            }

            async requestPermissions() {
                try {
                    this.updateCameraStatus('üìπ Requesting camera permissions...', 'connecting');
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                         this.showError('getUserMedia is not supported in this browser.');
                         this.updateCameraStatus('‚ùå getUserMedia not supported', 'error');
                         return;
                    }
                    // Request basic camera access to trigger permission prompt
                    const testStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: { ideal: 320 }, height: { ideal: 240 } } 
                    });
                    testStream.getTracks().forEach(track => track.stop()); // Stop the test stream immediately
                    this.updateCameraStatus('‚úÖ Camera permissions granted', 'active');
                    await this.checkCameraPermissions(); // Re-check and enumerate
                } catch (error) {
                    console.error('Failed to get camera permissions:', error);
                    this.showError(`Failed to get camera permissions: ${error.message} (Name: ${error.name})`);
                    this.updateCameraStatus('‚ùå Camera permissions denied', 'error');
                }
            }

            async startCamera() {
                try {
                    this.hideError();
                    this.updateCameraStatus('üìπ Starting camera...', 'connecting');
                    
                    const resolution = document.getElementById('resolutionSelect').value.split('x');
                    const width = parseInt(resolution[0]);
                    const height = parseInt(resolution[1]);
                    const facingMode = document.getElementById('facingMode').value;
                    
                    const constraints = {
                        video: {
                            width: { ideal: width, min: 320 },
                            height: { ideal: height, min: 240 },
                            frameRate: { ideal: 30, min: 15 }
                        }
                    };

                    if (this.availableCameras.length > 0 && this.availableCameras[this.currentCameraIndex]?.deviceId) {
                        constraints.video.deviceId = { exact: this.availableCameras[this.currentCameraIndex].deviceId };
                         console.log(`Attempting to use camera by ID: ${constraints.video.deviceId.exact}`);
                    } else {
                        constraints.video.facingMode = { ideal: facingMode };
                        console.log(`Attempting to use camera by facingMode: ${constraints.video.facingMode.ideal}`);
                    }

                    console.log('üé• Camera constraints:', JSON.stringify(constraints));

                    if (this.stream) {
                        this.stream.getTracks().forEach(track => track.stop());
                        console.log("Stopped existing stream tracks.");
                    }

                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                         this.showError('getUserMedia is not supported in this browser.');
                         this.updateCameraStatus('‚ùå getUserMedia not supported', 'error');
                         return;
                    }
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('‚úÖ Camera stream obtained');
                    if (this.stream.getVideoTracks().length === 0) {
                        console.error("Stream obtained but has no video tracks.");
                        this.showError("Failed to obtain a video track from the camera.");
                        this.updateCameraStatus('‚ùå No video track', 'error');
                        return;
                    }
                    console.log(`Stream active: ${this.stream.active}, Video track readyState: ${this.stream.getVideoTracks()[0].readyState}`);

                    // Setup main processing video element
                    if (!this.video) {
                        this.video = document.createElement('video');
                        this.video.autoplay = true;
                        this.video.playsInline = true;
                        this.video.muted = true;
                        this.video.style.display = 'none'; // Keep it hidden
                        document.body.appendChild(this.video); // ***FIX 1: Add to DOM***
                        console.log("Processing video element created and added to DOM.");
                    }
                    
                    this.video.srcObject = this.stream;
                    // Also ensure debugVideo gets the stream if it exists
                    if (this.debugVideo) {
                        this.debugVideo.srcObject = this.stream; // Share the same stream
                        console.log("Stream assigned to debugVideo.");
                    }
                    
                    // ***FIX 2: Explicitly play both video elements***
                    const playPromises = [];
                    if (this.video) {
                        playPromises.push(this.video.play().catch(e => {
                            console.error("Processing video play error:", e);
                            this.showError(`Processing video play error: ${e.message}`);
                        }));
                    }
                    if (this.debugVideo) { // debugVideo is from HTML, should exist
                        playPromises.push(this.debugVideo.play().catch(e => {
                             console.error("Debug video play error:", e);
                             this.showError(`Debug video play error: ${e.message}`);
                        }));
                    }
                    
                    await Promise.all(playPromises);
                    console.log('‚ñ∂Ô∏è Play initiated for video elements');

                    // Wait for video metadata to be ready (for this.video, which is used for processing)
                    await new Promise((resolve, reject) => {
                        if (!this.video) {
                            reject(new Error("Processing video element not found for loadedmetadata event"));
                            return;
                        }
                        const timeout = setTimeout(() => {
                            reject(new Error(`Video load timeout for processing video. ReadyState: ${this.video?.readyState}. Stream active: ${this.stream?.active}`));
                        }, 10000); // 10 second timeout
                        
                        const handleLoad = () => {
                            clearTimeout(timeout);
                            if (!this.video || this.video.videoWidth === 0 || this.video.videoHeight === 0) {
                                console.warn(`üì∫ Processing video metadata loaded, but dimensions are zero or video element missing: ${this.video?.videoWidth}x${this.video?.videoHeight}`);
                                // Do not reject here, as some browsers might still stream. Log and continue.
                                // The processVideoFrame will check dimensions again.
                            } else {
                                console.log(`üì∫ Processing video ready: ${this.video.videoWidth}x${this.video.videoHeight}`);
                            }
                            resolve();
                        };
                        
                        this.video.addEventListener('loadedmetadata', handleLoad, { once: true });
                        this.video.addEventListener('error', (e) => {
                            clearTimeout(timeout);
                            let errorMsg = 'Processing video load error';
                            if (this.video && this.video.error) { // Check if this.video exists
                                errorMsg += `: Code ${this.video.error.code}, Message: ${this.video.error.message}`;
                            }
                            console.error(errorMsg, e);
                            reject(new Error(errorMsg));
                        }, { once: true });

                        if (this.video.readyState >= HTMLMediaElement.HAVE_METADATA) { // Use constant
                           console.log("Video metadata already loaded, calling handleLoad directly.");
                           handleLoad();
                        }
                    });
                    
                    this.isRunning = true;
                    this.updateCameraStatus('üìπ Camera active - Live Hadit processing', 'active');
                    this.updateInfoPanel(`Camera started: ${this.video?.videoWidth || 'N/A'}x${this.video?.videoHeight || 'N/A'} | Live Hadit processing active`);
                    
                    this.startProcessingLoop();
                    
                    document.getElementById('startCamera').style.display = 'none';
                    document.getElementById('switchCamera').style.display = 'inline-block';
                    document.getElementById('stopCamera').style.display = 'inline-block';
                    
                } catch (error) {
                    console.error('üö´ Camera start error:', error);
                    this.showError('Camera start failed: ' + (error.message || error.name || error));
                    this.updateCameraStatus('‚ùå Camera start failed', 'error');
                    
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        this.showError('Camera permission denied. Please allow camera access and try again.');
                    } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                        this.showError('No camera found. Please connect a camera and try again.');
                    } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                        this.showError('Camera is busy or unreadable. Close other apps using the camera, or try a different camera/resolution, and then try again.');
                    } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
                        this.showError(`The selected resolution/camera is not supported. Try different settings. Error: ${error.message}`);
                    } else if (error.message && error.message.includes("Video load timeout")) {
                         this.showError('Video stream failed to load in time. Check camera connection and permissions.');
                    } else {
                        this.showError(`Camera error: ${error.name} - ${error.message}`);
                    }
                }
            }


            stopCamera() {
                this.isRunning = false;
                console.log("Stopping camera...");
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                 if (this.animationId) { // Stop theta/phi animation
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                    console.log("Stream tracks stopped.");
                }
                
                if (this.video) {
                    this.video.srcObject = null;
                    // Optionally remove from DOM if you want to recreate it each time
                    // if (this.video.parentNode) {
                    //    this.video.parentNode.removeChild(this.video);
                    // }
                    // this.video = null; // If you want to recreate it fully
                    console.log("Processing video srcObject cleared.");
                }
                
                if (this.debugVideo) { // This is the one from HTML
                    this.debugVideo.srcObject = null;
                    console.log("Debug video srcObject cleared.");
                }
                
                this.updateCameraStatus('üìπ Camera stopped', 'connecting'); // Or 'idle'
                this.updateInfoPanel('Camera stopped. Click Start Camera to resume live Hadit processing.');
                
                document.getElementById('startCamera').style.display = 'inline-block';
                document.getElementById('switchCamera').style.display = 'none';
                document.getElementById('stopCamera').style.display = 'none';
                
                // Clear canvases
                [this.leftCtx, this.rightCtx, this.depthCtx].forEach(ctx => {
                    if (ctx && ctx.canvas) { // Ensure context and canvas exist
                        ctx.fillStyle = '#000'; // Set to black
                        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    }
                });
                this.updateFpsDisplay(true); // Reset FPS to 0
                console.log("Camera stopped and canvases cleared.");
            }

            async switchCamera() {
                this.updateCameraStatus('üîÑ Switching camera...', 'connecting');
                if (this.availableCameras.length > 1) {
                    this.currentCameraIndex = (this.currentCameraIndex + 1) % this.availableCameras.length;
                    const selectedCamera = this.availableCameras[this.currentCameraIndex];
                    this.updateInfoPanel(`Switching to camera ${selectedCamera.label || `Camera ${this.currentCameraIndex + 1}`}...`);
                    await this.startCamera(); // Restart with new camera ID
                } else if (this.availableCameras.length === 1) {
                    this.updateInfoPanel(`Only one camera available. Attempting to toggle facing mode as fallback.`);
                     // Fallback: toggle facing mode if only one camera or enumeration failed but we might have front/back
                    const facingModeSelect = document.getElementById('facingMode');
                    facingModeSelect.value = facingModeSelect.value === 'user' ? 'environment' : 'user';
                    this.updateInfoPanel(`Switched facing mode to ${facingModeSelect.value}. Restarting camera...`);
                    await this.startCamera(); // Restart with new facing mode
                } else {
                    this.updateInfoPanel('No other cameras available to switch to. Trying to toggle facing mode.');
                    const facingModeSelect = document.getElementById('facingMode');
                    facingModeSelect.value = facingModeSelect.value === 'user' ? 'environment' : 'user';
                    this.updateInfoPanel(`Switched facing mode to ${facingModeSelect.value}. Restarting camera...`);
                    await this.startCamera();
                }
            }

            toggleDebugVideo() {
                // const debugVideo = document.getElementById('debugVideo'); // Already this.debugVideo
                const showRawFeedCheckbox = document.getElementById('showRawFeed');
                
                if (!this.debugVideo) {
                    console.error("Debug video element not found for toggle.");
                    return;
                }

                if (this.debugVideo.style.display === 'none') {
                    this.debugVideo.style.display = 'block'; // Or 'inline-block' or '' depending on desired layout
                    if (showRawFeedCheckbox) showRawFeedCheckbox.checked = true;
                    this.updateInfoPanel('Debug video enabled - raw camera feed should be visible.');
                } else {
                    this.debugVideo.style.display = 'none';
                    if (showRawFeedCheckbox) showRawFeedCheckbox.checked = false;
                    this.updateInfoPanel('Debug video hidden.');
                }
            }

            startProcessingLoop() {
                const targetFPS = parseInt(document.getElementById('targetFpsSelect')?.value || 30); // Example if you add a target FPS selector
                // const targetFPS = 30; // Or fixed
                const targetInterval = 1000 / targetFPS;
                let lastTime = performance.now(); // Use performance.now() for higher precision
                
                console.log(`üîÑ Starting processing loop with target FPS: ${targetFPS}`);
                
                const processFrame = (currentTime) => {
                    if (!this.isRunning) {
                        console.log('‚èπÔ∏è Processing loop stopped');
                        return;
                    }
                    
                    this.animationFrameId = requestAnimationFrame(processFrame); // Request next frame immediately for smoother animation timing

                    const deltaTime = currentTime - lastTime;
                    if (deltaTime >= targetInterval) {
                        lastTime = currentTime - (deltaTime % targetInterval); // Adjust lastTime to maintain target interval
                        
                        this.processVideoFrame();
                        
                        // Update FPS
                        this.frameCount++;
                        // FPS calculation should be independent of processing interval, based on real time
                    }
                    // Moved FPS calculation outside the interval check to be based on actual time passed
                    if (currentTime - this.lastFpsTime >= 1000) { // Update FPS counter every second
                        this.currentFps = this.frameCount;
                        this.frameCount = 0;
                        this.lastFpsTime = currentTime;
                        if (this.getConfiguration().showFPS) {
                            this.updateFpsDisplay();
                        }
                    }
                };
                
                this.animationFrameId = requestAnimationFrame(processFrame);
            }

            processVideoFrame() {
                if (!this.video || this.video.readyState < HTMLMediaElement.HAVE_CURRENT_DATA || this.video.videoWidth === 0 || this.video.videoHeight === 0) {
                    // console.log('‚ö†Ô∏è Video not ready yet or dimensions are zero...');
                    return;
                }
                
                const config = this.getConfiguration();
                const startTime = performance.now();
                
                try {
                    const sourceWidth = this.video.videoWidth;
                    const sourceHeight = this.video.videoHeight;
                    const processWidth = Math.max(1, Math.floor(sourceWidth * config.quality)); // Ensure at least 1px
                    const processHeight = Math.max(1, Math.floor(sourceHeight * config.quality));
                    
                    if (this.processingCanvas.width !== processWidth) this.processingCanvas.width = processWidth;
                    if (this.processingCanvas.height !== processHeight) this.processingCanvas.height = processHeight;
                    
                    this.processingCtx.save();
                    if (config.mirrorCamera) {
                        this.processingCtx.scale(-1, 1);
                        this.processingCtx.translate(-processWidth, 0);
                    }
                    
                    this.processingCtx.clearRect(0, 0, processWidth, processHeight); // Clear before drawing
                    this.processingCtx.drawImage(this.video, 0, 0, processWidth, processHeight);
                    this.processingCtx.restore();
                    
                    const imageData = this.processingCtx.getImageData(0, 0, processWidth, processHeight);
                    if (!imageData || imageData.data.length === 0) {
                        console.warn('‚ö†Ô∏è No image data received from processing canvas');
                        return;
                    }
                    
                    this.generateHaditStereoViews(imageData, config);
                    
                    const processingTime = performance.now() - startTime;
                    if (config.debugMode) {
                        this.updateAnalysisPanel(processingTime, config, processWidth, processHeight);
                    }
                    
                } catch (error) {
                    console.error('üö´ Frame processing error:', error);
                    // this.showError('Frame processing error: ' + error.message); // Can be too spammy
                    // this.stopCamera(); // Optionally stop on critical error
                }
            }

            generateHaditStereoViews(imageData, config) {
                const { width, height, data } = imageData;
                
                if (width === 0 || height === 0 || !data || data.length === 0) {
                    console.warn('‚ö†Ô∏è Invalid image data for Hadit processing');
                    return;
                }
                
                // Resize output canvases if necessary and not already matching processing size
                if (this.leftCanvas.width !== width) this.leftCanvas.width = width;
                if (this.leftCanvas.height !== height) this.leftCanvas.height = height;
                if (this.rightCanvas.width !== width) this.rightCanvas.width = width;
                if (this.rightCanvas.height !== height) this.rightCanvas.height = height;
                
                const depthDisplayWidth = config.showDepthMap ? Math.floor(width / 2) : width; // Example: depth map half size
                const depthDisplayHeight = config.showDepthMap ? Math.floor(height / 2) : height;
                if (this.depthCanvas.width !== depthDisplayWidth) this.depthCanvas.width = depthDisplayWidth;
                if (this.depthCanvas.height !== depthDisplayHeight) this.depthCanvas.height = depthDisplayHeight;

                const leftImageData = this.leftCtx.createImageData(width, height);
                const rightImageData = this.rightCtx.createImageData(width, height);
                const depthImageData = config.showDepthMap ? this.depthCtx.createImageData(depthDisplayWidth, depthDisplayHeight) : null;
                
                const leftData = leftImageData.data;
                const rightData = rightImageData.data;
                const depthOutData = depthImageData ? depthImageData.data : null;
                
                let minDepth = 1.0, maxDepth = 0.0;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        const r = data[idx] / 255;
                        const g = data[idx + 1] / 255;
                        const b = data[idx + 2] / 255;
                        
                        const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                        const maxCol = Math.max(r, g, b);
                        const minCol = Math.min(r, g, b);
                        const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0; // Avoid division by zero
                        
                        const sCoord = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                        const sMagnitude = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                        
                        const normalizedDepthFromS = Math.min(sMagnitude / (config.sBounds * 2), 1.0); // Normalize based on sBounds
                        let depth = 0.2 + (normalizedDepthFromS * 0.8);
                        depth = 0.5 + (depth - 0.5) * config.focusFactor;
                        const contentWeight = lum * 0.5 + sat * 0.3; // Simplified content weight
                        depth *= (1 + contentWeight * 0.3);
                        depth = Math.max(0.05, Math.min(1.0, depth)); // Clamp depth

                        minDepth = Math.min(minDepth, depth);
                        maxDepth = Math.max(maxDepth, depth);
                        
                        const normalizedDepthDisplacement = (depth - 0.5) * 2; // Range -1 to 1
                        const displacement = Math.round(normalizedDepthDisplacement * config.separation * config.depthIntensity);
                        
                        if (config.enableStereo) {
                            const leftSampleX = Math.max(0, Math.min(width - 1, x + displacement));
                            const leftSampleIdx = (y * width + leftSampleX) * 4;
                            leftData[idx]     = data[leftSampleIdx];
                            leftData[idx + 1] = data[leftSampleIdx + 1];
                            leftData[idx + 2] = data[leftSampleIdx + 2];
                            leftData[idx + 3] = 255;
                            
                            const rightSampleX = Math.max(0, Math.min(width - 1, x - displacement));
                            const rightSampleIdx = (y * width + rightSampleX) * 4;
                            rightData[idx]     = data[rightSampleIdx];
                            rightData[idx + 1] = data[rightSampleIdx + 1];
                            rightData[idx + 2] = data[rightSampleIdx + 2];
                            rightData[idx + 3] = 255;
                        } else {
                            leftData[idx] = rightData[idx] = data[idx];
                            leftData[idx + 1] = rightData[idx + 1] = data[idx + 1];
                            leftData[idx + 2] = rightData[idx + 2] = data[idx + 2];
                            leftData[idx + 3] = rightData[idx + 3] = 255;
                        }

                        if (config.showDepthMap && depthOutData) {
                            // For depth map, scale x, y to depthDisplayWidth, depthDisplayHeight
                            const dx = Math.floor(x * depthDisplayWidth / width);
                            const dy = Math.floor(y * depthDisplayHeight / height);
                            if (dx < depthDisplayWidth && dy < depthDisplayHeight) { // Check bounds
                                const depthIdx = (dy * depthDisplayWidth + dx) * 4;
                                const depthColor = Math.floor(depth * 255);
                                depthOutData[depthIdx] = depthColor;     // R
                                depthOutData[depthIdx + 1] = depthColor; // G
                                depthOutData[depthIdx + 2] = depthColor; // B
                                depthOutData[depthIdx + 3] = 255;        // Alpha
                            }
                        }
                    }
                }
                
                this.leftCtx.putImageData(leftImageData, 0, 0);
                this.rightCtx.putImageData(rightImageData, 0, 0);
                if (config.showDepthMap && depthImageData) {
                    this.depthCtx.putImageData(depthImageData, 0, 0);
                } else if (!config.showDepthMap) {
                    this.depthCtx.fillStyle = '#000';
                    this.depthCtx.fillRect(0,0, this.depthCanvas.width, this.depthCanvas.height);
                }
                 this.latestMinDepth = minDepth; // Store for analysis panel
                 this.latestMaxDepth = maxDepth;
            }
            
            // UI Update methods
            updateFpsDisplay(reset = false) {
                const fps = reset ? 0 : this.currentFps;
                document.getElementById('leftFps').textContent = `${fps} FPS`;
                document.getElementById('rightFps').textContent = `${fps} FPS`; // Assuming same FPS for both
                document.getElementById('depthFps').textContent = `${fps} FPS`; // And for depth
            }

            updateCameraStatus(message, statusClass) { // statusClass: 'connecting', 'active', 'error'
                const statusEl = document.getElementById('cameraStatus');
                statusEl.innerHTML = `<span class="status-${statusClass}">${message}</span>`;
            }

            showError(message) {
                const errorPanel = document.getElementById('errorPanel');
                const errorMessageDiv = document.getElementById('errorMessage');
                errorMessageDiv.textContent = message;
                errorPanel.style.display = 'block';
                console.error("Error Displayed:", message); // Log to console as well
            }

            hideError() {
                document.getElementById('errorPanel').style.display = 'none';
            }
            
            updateInfoPanel(message) {
                document.getElementById('infoPanel').innerHTML = `<div>Status: ${message}</div>`;
            }

            updateAnalysisInfo(message) {
                const analysisPanel = document.getElementById('analysisPanel');
                const div = document.createElement('div');
                div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                analysisPanel.appendChild(div);
                analysisPanel.scrollTop = analysisPanel.scrollHeight; // Auto-scroll
            }
            
            updateAnalysisPanel(processingTime, config, processWidth, processHeight) {
                const panel = document.getElementById('analysisPanel');
                panel.innerHTML = `
                    <div style="color: #88ff00; font-weight: bold;">‚ö° Live Hadit Analysis</div>
                    <div>Processing Time: ${processingTime.toFixed(2)} ms</div>
                    <div>Resolution (Processing): ${processWidth}x${processHeight}</div>
                    <div>Hadit Œ∏: ${config.haditTheta.toFixed(1)}¬∞, œÜ: ${config.haditPhi.toFixed(1)}¬∞</div>
                    <div>Influence: ${config.haditInfluence.toFixed(2)}, Focus: ${config.focusFactor.toFixed(1)}x</div>
                    <div>Separation: ${config.separation}px, Depth Intensity: ${config.depthIntensity.toFixed(1)}x</div>
                    <div>S Bounds: ¬±${config.sBounds.toFixed(1)}</div>
                    <div>Lum Weight: ${config.luminosityWeight.toFixed(2)}, Sat Weight: ${config.saturationWeight.toFixed(2)}</div>
                    <div>Quality Setting: ${config.quality * 100}%</div>
                    <div>FPS: ${this.currentFps}</div>
                    <div>Depth Range: ${this.latestMinDepth?.toFixed(3) || 'N/A'} - ${this.latestMaxDepth?.toFixed(3) || 'N/A'}</div>
                    <div>Mirror: ${config.mirrorCamera}, Stereo: ${config.enableStereo}, Show Depth: ${config.showDepthMap}</div>
                `;
            }

            // Control initializations
            initializeControls() {
                // Camera controls
                document.getElementById('startCamera').addEventListener('click', () => this.startCamera());
                document.getElementById('switchCamera').addEventListener('click', () => this.switchCamera());
                document.getElementById('stopCamera').addEventListener('click', () => this.stopCamera());
                document.getElementById('requestPermissions').addEventListener('click', () => this.requestPermissions());
                document.getElementById('toggleDebugVideo').addEventListener('click', () => this.toggleDebugVideo());

                // Settings with live updates for labels
                const setupSliderWithValue = (sliderId, valueId, suffix = '', multiplier = 1, digits = 1) => {
                    const slider = document.getElementById(sliderId);
                    const valueLabel = document.getElementById(valueId);
                    const update = () => valueLabel.textContent = `${(parseFloat(slider.value) * multiplier).toFixed(digits)}${suffix}`;
                    slider.addEventListener('input', update);
                    update(); // Initial call
                };
                
                const setupDualInput = (rangeId, numberId, valueLabelId, suffix = '', digits = 1) => {
                    const rangeInput = document.getElementById(rangeId);
                    const numberInput = document.getElementById(numberId);
                    const valueLabel = document.getElementById(valueLabelId);

                    const updateFromRange = () => {
                        const val = parseFloat(rangeInput.value);
                        numberInput.value = val.toFixed(digits);
                        if (valueLabel) valueLabel.textContent = `${val.toFixed(digits)}${suffix}`;
                    };
                    const updateFromNumber = () => {
                        let val = parseFloat(numberInput.value);
                        val = Math.max(parseFloat(rangeInput.min), Math.min(parseFloat(rangeInput.max), val)); // Clamp
                        if (isNaN(val)) val = parseFloat(rangeInput.value); // Fallback if NaN
                        rangeInput.value = val;
                         if (valueLabel) valueLabel.textContent = `${val.toFixed(digits)}${suffix}`;
                    };
                    rangeInput.addEventListener('input', updateFromRange);
                    numberInput.addEventListener('change', updateFromNumber); // Use change to avoid rapid updates while typing
                    numberInput.addEventListener('input', () => { // Live update label from number input too
                         if (valueLabel) valueLabel.textContent = `${parseFloat(numberInput.value).toFixed(digits)}${suffix}`;
                    });
                    updateFromRange(); // Initial call
                };

                setupDualInput('haditTheta', 'haditThetaNumber', 'haditThetaValue', '¬∞', 1);
                setupDualInput('haditPhi', 'haditPhiNumber', 'haditPhiValue', '¬∞', 1);
                
                setupSliderWithValue('haditInfluence', 'haditInfluenceValue', '', 1, 2);
                setupSliderWithValue('focusFactor', 'focusFactorValue', 'x', 1, 1);
                setupSliderWithValue('separation', 'separationValue', 'px', 1, 0);
                setupSliderWithValue('depthIntensity', 'depthIntensityValue', 'x', 1, 1);
                setupSliderWithValue('sBounds', 'sBoundsValue', '', 1, 1);
                setupSliderWithValue('luminosityWeight', 'luminosityWeightValue', '', 1, 2);
                setupSliderWithValue('saturationWeight', 'saturationWeightValue', '', 1, 2);

                // Checkboxes - their state is read directly in getConfiguration()
                document.getElementById('showRawFeed').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        if (this.debugVideo && this.debugVideo.style.display === 'none') this.toggleDebugVideo();
                    } else {
                        if (this.debugVideo && this.debugVideo.style.display !== 'none') this.toggleDebugVideo();
                    }
                });
                
                // Preset buttons
                document.getElementById('setHaditPole').addEventListener('click', () => this.setHaditValue('haditPhi', 0.1));
                document.getElementById('setHaditEquator').addEventListener('click', () => this.setHaditValue('haditPhi', 90));
                document.getElementById('setHaditNear180').addEventListener('click', () => this.setHaditValue('haditPhi', 179.9));
                document.getElementById('animateTheta').addEventListener('click', () => this.animateHadit('haditTheta', 360, 2)); // Animate theta over 2 degrees/sec
                document.getElementById('animatePhi').addEventListener('click', () => this.animateHadit('haditPhi', 179.9, 1, true)); // Animate phi (ping-pong)
                document.getElementById('stopAnimation').addEventListener('click', () => this.stopHaditAnimation());
            }
            
            setHaditValue(param, value) {
                const rangeInput = document.getElementById(param);
                const numberInput = document.getElementById(param + 'Number'); // e.g., haditPhiNumber
                const valueLabel = document.getElementById(param + 'Value'); // e.g., haditPhiValue
                
                if (rangeInput) rangeInput.value = value;
                if (numberInput) numberInput.value = value.toFixed(1);
                if (valueLabel) valueLabel.textContent = `${value.toFixed(1)}¬∞`; // Assuming degrees for these params
            }

            animateHadit(param, range, speed, pingPong = false) {
                this.stopHaditAnimation(); // Stop any existing animation
                
                const input = document.getElementById(param);
                const numberInput = document.getElementById(param + 'Number');
                const valueLabel = document.getElementById(param + 'Value');
                
                let currentValue = parseFloat(input.value);
                const min = parseFloat(input.min);
                const max = parseFloat(input.max);
                let direction = 1;
                let lastTime = performance.now();

                const step = (currentTime) => {
                    const deltaTime = (currentTime - lastTime) / 1000; // Seconds
                    lastTime = currentTime;

                    currentValue += direction * speed * deltaTime;

                    if (pingPong) {
                        if (currentValue >= max) { currentValue = max; direction = -1; }
                        if (currentValue <= min) { currentValue = min; direction = 1; }
                    } else { // Loop
                        if (currentValue > max) currentValue = min;
                        if (currentValue < min) currentValue = max; // In case speed is negative
                    }
                    
                    input.value = currentValue.toFixed(1);
                    if (numberInput) numberInput.value = currentValue.toFixed(1);
                    if (valueLabel) valueLabel.textContent = `${currentValue.toFixed(1)}¬∞`;

                    this.animationId = requestAnimationFrame(step);
                };
                this.animationId = requestAnimationFrame(step);
            }

            stopHaditAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }
        }

        // Initialize the camera system when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.haditCamera = new LiveHaditCamera();
        });
    </script>
</body>
</html>
