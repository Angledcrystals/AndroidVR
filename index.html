<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Virtual spectrum based on S-values</title>
    <style>
        /* All your existing styles unchanged */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }

        /* Canvas container takes all available space */
        .container {
            flex: 1;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            width: 100vw;
            perspective: 1000px;
            overflow: hidden;
            padding-top: 10px; /* Space from top */
            position: relative; /* For absolute positioning in flicker mode */
        }

        /* Canvas will maintain camera aspect ratio */
        canvas {
            border: 2px solid white;
            border-radius: 10px;
            transform-origin: center;
            transition: transform 0.2s ease;
            margin: 0 4px;
            height: auto; /* Auto height based on container */
            position: relative; /* For flicker mode */
            will-change: transform, left, right; /* Hint for GPU acceleration */
        }

        /* Hardware acceleration hints */
        canvas, video {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
            will-change: transform;
        }

        /* Prevent unnecessary repaints */
        body, .container, .control-panel {
            will-change: transform;
        }

        /* Control panel at the bottom */
        .control-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            padding: 5px 5px;
            z-index: 1000;
        }

        /* Control rows */
        .control-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 3px; /* Reduced margin */
        }

        /* Control sections */
        .control-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 5px;
        }

        /* Control section headers */
        .section-header {
            font-size: 0.7rem; /* Smaller font */
            text-transform: uppercase;
            margin-bottom: 1px;
            color: #ccc;
        }

        /* Control elements */
        .control-item {
            display: flex;
            align-items: center;
            margin: 1px 0; /* Reduced margin */
        }

        label {
            font-size: 0.7rem; /* Smaller font */
            margin-right: 5px;
            min-width: 45px;
        }

        input[type="range"] {
            width: 70px;
            height: 12px; /* Thinner sliders */
        }

        select {
            width: 70px;
            font-size: 0.7rem;
            background: #333;
            color: white;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 1px;
        }

        button {
            margin: 2px; /* Reduced margin */
            padding: 5px 8px; /* Smaller padding */
            font-size: 0.75rem; /* Smaller font */
            border: none;
            border-radius: 5px;
            background-color: #444;
            color: white;
            cursor: pointer;
        }

        button:hover {
            background-color: #666;
        }

        .divider {
            width: 1px;
            height: 35px; /* Shorter divider */
            background-color: #444;
            margin: 0 2px;
        }

        /* Top controls container */
        .top-controls {
            position: fixed;
            top: 5px;
            right: 5px;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Toggle button to hide/show controls - REPOSITIONED */
        #toggleControls {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #333;
        }

        #toggleControls:hover {
            opacity: 1;
        }

        /* Quality selector */
        #qualitySelect {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 5px;
        }

        #qualitySelect:hover {
            opacity: 1;
        }

        /* Quality indicator */
        #qualityIndicator {
            position: fixed;
            top: 40px;
            right: 5px;
            font-size: 0.65rem;
            color: #aaa;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Flicker indicator */
        #flickerIndicator {
            position: fixed;
            top: 70px;
            right: 5px;
            font-size: 0.65rem;
            color: #f55;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Debug output */
        #debugOutput {
            position: fixed;
            top: 5px;
            left: 5px;
            font-size: 0.65rem;
            color: #aaa;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            max-width: 50%;
            max-height: 200px;
            overflow: auto;
        }

        /* Value display spans */
        .value-display {
            font-size: 0.6rem;
            color: #aaa;
            margin-left: 5px;
            min-width: 30px;
        }

        /* Portrait mode warning */
        @media (orientation: portrait) {
            body::before {
                content: "Please rotate your device to landscape mode.";
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-size: 1.5rem;
                text-align: center;
                z-index: 1000;
            }

            .container, .control-panel, .top-controls, #qualityIndicator {
                display: none;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            button {
                padding: 3px 6px;
                font-size: 0.65rem;
            }
            
            input[type="range"] {
                width: 60px;
            }
            
            label {
                font-size: 0.65rem;
                min-width: 40px;
            }
        }

        /* Firefox-specific CSS fixes */
        @-moz-document url-prefix() {
            video {
                transform-origin: center center;
                will-change: transform;
            }
            
            canvas {
                transform-origin: center center;
                will-change: transform;
            }
        }
        
        /* Flicker mode specific styles - for position swapping */
        .flicker-active .container {
            position: relative;
        }
        
        .flicker-active canvas {
            position: absolute;
            transition: none; /* Disable transitions for flicker mode */
        }
        
        .canvas-left {
            left: calc(25% - 50px);
        }
        
        .canvas-right {
            left: calc(75% - 50px);
        }
        
        /* Frozen frame styles */
        .frozen-canvas {
            border-color: #ff4040 !important;
            box-shadow: 0 0 10px rgba(255, 64, 64, 0.7);
        }

        /* Recording Controls */
        .recording-controls {
            display: flex;
            align-items: center;
            margin-right: 5px;
        }

        .record-button {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: #333;
            border: none;
            color: white;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .record-button:hover {
            opacity: 1;
            background-color: #444;
        }

        .record-icon {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ff4040;
            display: inline-block;
        }

        .stop-icon {
            width: 10px;
            height: 10px;
            background-color: white;
            display: inline-block;
        }

        .stop-record {
            background-color: #c00;
        }

        .stop-record:hover {
            background-color: #e00;
        }

        .recording-indicator {
            display: flex;
            align-items: center;
            margin-left: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ff4040;
            margin-right: 5px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.8);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(0.8);
                opacity: 0.8;
            }
        }

        #recordingTimer {
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas1"></canvas>
        <canvas id="canvas2"></canvas>
        <!-- Freeze countdown display -->
        <div id="freezeCountdown" style="display: none; position: absolute; background-color: rgba(255, 0, 0, 0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 1.2rem; font-weight: bold; top: 50%; left: 50%; transform: translate(-50%, -50%);">3</div>
    </div>
    
    <div class="top-controls">
        <div class="recording-controls">
            <button id="recordButton" class="record-button">
                <span class="record-icon"></span> Record
            </button>
            <button id="stopRecordButton" class="record-button stop-record" style="display:none">
                <span class="stop-icon"></span> Stop
            </button>
            <div id="recordingIndicator" class="recording-indicator" style="display:none">
                <span class="pulse-dot"></span>
                <span id="recordingTimer">00:00</span>
            </div>
        </div>
        <select id="qualitySelect">
            <option value="1.0">High Quality</option>
            <option value="0.5" selected>Medium Quality</option>
            <option value="0.25">Low Quality</option>
            <option value="0.1">Very Low Quality</option>
        </select>
        <button id="toggleControls">Hide Controls</button>
    </div>
    
    <div id="qualityIndicator">Processing at 50% resolution</div>
    <div id="flickerIndicator">3D Flicker Mode Active</div>
    <div id="debugOutput" style="display: none;"></div>
    
    <div class="control-panel" id="controlPanel">
        <div class="control-row">
            <div class="control-section">
                <div class="section-header">Camera</div>
                <div class="control-item">
                    <button id="startButton">Start Camera</button>
                    <button id="switchButton">Switch Camera</button>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">View</div>
                <div class="control-item">
                    <label for="tiltSlider">Tilt</label>
                    <input id="tiltSlider" type="range" min="0" max="0.7" step="0.01" value="0">
                </div>
                <div class="control-item">
                    <label for="sizeSlider">Size</label>
                    <input id="sizeSlider" type="range" min="0.2" max="1.8" step="0.05" value="1.0">
                </div>
                <div class="control-item">
                    <button id="toggleFlickerMode">Enable 3D Flicker</button>
                </div>
                <div class="control-item" id="flickerSpeedContainer" style="display: none;">
                    <label for="flickerSpeedSlider">Speed</label>
                    <input id="flickerSpeedSlider" type="range" min="8" max="60" step="1" value="16">
                </div>
                <div class="control-item">
                    <label for="freezeDelayToggle">Freeze Delay</label>
                    <input id="freezeDelayToggle" type="checkbox">
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Enhanced Nuit Depth</div>
                <div class="control-item">
                    <label for="depthMode">Mode</label>
                    <select id="depthMode">
                        <option value="nuit">Nuit Only</option>
                        <option value="radial">Radial Zones</option>
                        <option value="hybrid">Hybrid</option>
                        <option value="sum_xy" selected>Sum XY S-Coords</option>
                        <option value="vectorfield">Vector Field</option>
                        <option value="hadit">Hadit Mode</option>
                    </select>
                </div>
                <div class="control-item">
                    <label for="nuitRadius">Nuit Radius</label>
                    <input id="nuitRadius" type="range" min="0.5" max="15.0" step="0.1" value="7.0">
                    <span id="nuitRadiusValue" class="value-display">7.0</span>
                </div>
                <div class="control-item">
                    <label for="sBounds">S Bounds</label>
                    <input id="sBounds" type="range" min="1.0" max="30.0" step="0.1" value="5.0">
                    <span id="sBoundsValue" class="value-display">±5.0</span>
                </div>
                <div class="control-item">
                    <label for="depthIntensity">Intensity</label>
                    <input id="depthIntensity" type="range" min="0" max="50" step="1" value="15">
                </div>
                <div class="control-item">
                    <label for="baselineSeparation">Eye Sep</label>
                    <input id="baselineSeparation" type="range" min="0.5" max="8.0" step="0.1" value="3.0">
                    <span id="baselineSeparationValue" class="value-display">3.0%</span>
                </div>
                <div class="control-item">
                    <label for="blurRadius">Blur</label>
                    <input id="blurRadius" type="range" min="0" max="10" step="1" value="1">
                </div>
                <div class="control-item">
                    <label for="nuitFalloffFactor">Falloff</label>
                    <input id="nuitFalloffFactor" type="range" min="1" max="20" step="0.5" value="5.0">
                </div>
                <div class="control-item">
                    <label for="depthQuantize">Quantize</label>
                    <input id="depthQuantizeToggle" type="checkbox">
                </div>
                <div class="control-item">
                    <label for="depthLevels">Levels</label>
                    <input id="depthLevels" type="range" min="2" max="16" step="1" value="8">
                </div>
            </div>
        </div>
        
        <div class="control-row">
            <div class="control-section">
                <div class="section-header">S-Coordinate Mapping</div>
                <div class="control-item">
                    <label for="luminosityWeight">Luminosity</label>
                    <input id="luminosityWeight" type="range" min="0" max="1" step="0.05" value="0.7">
                </div>
                <div class="control-item">
                    <label for="saturationWeight">Saturation</label>
                    <input id="saturationWeight" type="range" min="0" max="1" step="0.05" value="0.3">
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Left Color</div>
                <div class="control-item">
                    <label for="redSlider1">Red</label>
                    <input id="redSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="greenSlider1">Green</label>
                    <input id="greenSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="blueSlider1">Blue</label>
                    <input id="blueSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Right Color</div>
                <div class="control-item">
                    <label for="redSlider2">Red</label>
                    <input id="redSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="greenSlider2">Green</label>
                    <input id="greenSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="blueSlider2">Blue</label>
                    <input id="blueSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Utility function for debugging
        function debugLog(message) {
            console.log(message);
            const debugOutput = document.getElementById('debugOutput');
            if (debugOutput && debugOutput.style.display !== 'none') {
                debugOutput.innerHTML += message + '<br>';
                debugOutput.scrollTop = debugOutput.scrollHeight;
            }
        }

        // Browser detection
        const isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isMobile = isAndroid || isIOS;
        
        // Log useful browser information
        debugLog("Browser Detection:");
        debugLog("- Firefox: " + isFirefox);
        debugLog("- Android: " + isAndroid);
        debugLog("- iOS: " + isIOS);
        debugLog("- Mobile: " + isMobile);
        debugLog("- User Agent: " + navigator.userAgent);
        debugLog("- Session: Angledcrystals - 2025-06-07 06:35:39 UTC");
        
        // Add a GPU acceleration hint specific for Android WebView
        if (isAndroid) {
            const meta = document.createElement('meta');
            meta.name = 'viewport';
            meta.content = 'width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, viewport-fit=cover, minimal-ui';
            document.getElementsByTagName('head')[0].appendChild(meta);
        }

        // App state variables
        let currentStream = null;
        let video = null;
        let useFrontCamera = false;
        let controlsHidden = false;
        let qualityFactor = 0.5; // Default medium quality
        let lastFrameTime = 0;
        const targetFPS = 30;
        const frameInterval = 1000 / targetFPS;
        
        // Dynamic Nuit Distance Method Parameters
        let currentNuitRadius = 7.0;
        let currentSBounds = 5.0;
        
        // Vector Field globals
        let vectorFieldTime = 0;
        let lastUpdateTime = 0;
        
        // HADIT MODE PARAMETERS - ONLY ADDITION
        let haditParams = {
            bandSizeMultiplier: 10.0,
            focusFactor: 4.0,
            theta: 0.0,
            phi: 0.1,
            influence: 1.0,
            sBounds: 20.0,
            luminosityWeight: 0.0,
            saturationWeight: 0.0,
            depthContrast: 0.2
        };
        
        // Improved camera tracking
        let detectedCameras = {
            front: null,
            back: null,
            current: null,
            all: []
        };
        
        // Window size variables
        let canvasSizeFactor = 1.0; // Default canvas size factor
        
        // Variables for flicker mode
        let flickerMode = false;
        let flickerFrame = 0; // 0 = normal, 1 = swapped
        let flickerInterval = null;
        let flickerSpeed = 16; // milliseconds (about 60fps)
        let originalCanvasPositions = {
            canvas1: { left: 0, margin: 0, transform: '' },
            canvas2: { left: 0, margin: 0, transform: '' }
        };
        
        // Method indicator - we'll determine the right method based on device capabilities
        let renderMethod = 'canvas2d'; // Start with standard canvas, will try to upgrade to WebGL
        
        // Canvas setup
        let processingCanvas = document.createElement('canvas');
        let processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });
        let depthMapCanvas = document.createElement('canvas');
        let depthMapCtx = depthMapCanvas.getContext('2d', { willReadFrequently: true });
        
        // Try to use OffscreenCanvas for better performance if available
        if (typeof OffscreenCanvas !== 'undefined') {
            try {
                processingCanvas = new OffscreenCanvas(1, 1);
                processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });
                depthMapCanvas = new OffscreenCanvas(1, 1);
                depthMapCtx = depthMapCanvas.getContext('2d', { willReadFrequently: true });
                debugLog("Using OffscreenCanvas for better performance");
            } catch (e) {
                debugLog("OffscreenCanvas failed: " + e.message);
                // Fall back to regular canvas (already defined)
            }
        }
        
        // HADIT FUNCTION - ONLY ADDITION
        function calculateHaditDepth(px, py, width, height, lum, sat) {
            // Simple Hadit calculation based on specified parameters
            const gTheta = (px / width) * 360 * (Math.PI / 180);
            const gPhi = (py / height) * 180 * (Math.PI / 180);
            
            // Hadit spherical coordinates  
            const haditTheta = haditParams.theta * (Math.PI / 180);
            const haditPhi = haditParams.phi * (Math.PI / 180);
            
            // Calculate distance in spherical space
            const distance = Math.abs(gTheta - haditTheta) + Math.abs(gPhi - haditPhi);
            
            // Define information band
            const bandCenter = haditParams.sBounds * 0.5;
            const bandWidth = haditParams.sBounds * haditParams.bandSizeMultiplier * 0.1;
            const distanceFromBand = Math.abs(distance - bandCenter);
            
            let depth = 0.1;
            if (distanceFromBand <= bandWidth) {
                const bandCenteredness = 1.0 - (distanceFromBand / bandWidth);
                depth = 0.3 + bandCenteredness * 0.6 * haditParams.focusFactor * 0.2;
            } else {
                depth = 0.1 + lum * 0.2;
            }
            
            // Apply depth contrast
            depth = Math.pow(depth, 1.0 / haditParams.depthContrast);
            
            return Math.max(0.05, Math.min(1.0, depth));
        }
        
        // S-coordinate mapping functions from Python script (with dynamic parameters)
        function pixelToSCoordinate(px, py, width, height, lum, sat, lumMapWeight, satMapWeight) {
            // Normalize pixel coordinates to -1 to 1 range, centered
            const normX = (px / (width - 1)) * 2 - 1;
            const normY = (py / (height - 1)) * 2 - 1;
            
            // Base S-coordinate range using current S_BOUNDS
            const sMinX = -currentSBounds;
            const sMaxX = currentSBounds;
            const sMinY = -currentSBounds;
            const sMaxY = currentSBounds;
            
            // Apply color mediation to influence the S-coordinate mapping
            const effectiveSMaxX = sMaxX * (1 + lum * lumMapWeight + sat * satMapWeight);
            const effectiveSMinX = sMinX * (1 + lum * lumMapWeight + sat * satMapWeight);
            const effectiveSMaxY = sMaxY * (1 + lum * lumMapWeight + sat * satMapWeight);
            const effectiveSMinY = sMinY * (1 + lum * lumMapWeight + sat * satMapWeight);
            
            const sX = (normX + 1) / 2 * (effectiveSMaxX - effectiveSMinX) + effectiveSMinX;
            const sY = (normY + 1) / 2 * (effectiveSMaxY - effectiveSMinY) + effectiveSMinY;
            
            // Clip to reasonable bounds
            const clipVal = currentSBounds * 5;
            return {
                x: Math.max(-clipVal, Math.min(clipVal, sX)),
                y: Math.max(-clipVal, Math.min(clipVal, sY))
            };
        }
        
        // Enhanced Nuit distance depth calculation with multiple modes and better depth distribution
        function calculateNuitDistanceDepth(sCoord, nuitRadius, falloffFactor) {
            const distanceFromOrigin = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
            const distanceFromNuit = Math.abs(distanceFromOrigin - nuitRadius);
            
            // Get depth mode from selector
            const depthMode = document.getElementById('depthMode').value;
            
            let finalDepth;
            
            switch (depthMode) {
                case 'nuit':
                    // Original Nuit distance method - max depth at boundary
                    const baseDepth = 1.0 / (1.0 + distanceFromNuit * falloffFactor);
                    const contrastedDepth = Math.pow(baseDepth, 0.7);
                    const minDepth = 0.1;
                    finalDepth = minDepth + (contrastedDepth * (1.0 - minDepth));
                    break;
                    
                case 'radial':
                    // Radial depth - center is closest, edges are farthest
                    const maxDistance = Math.max(currentSBounds * 2, 10);
                    const normalizedDistance = Math.min(distanceFromOrigin / maxDistance, 1.0);
                    // Invert so center (distance 0) = max depth (1.0), edges = min depth
                    finalDepth = 1.0 - (normalizedDistance * 1.0); // Range: 1.0 to 0.2
                    break;
                    
                case 'hybrid':
                    // Combination: radial base + Nuit boundary enhancement
                    const maxDist = Math.max(currentSBounds * 2, 10);
                    const normDist = Math.min(distanceFromOrigin / maxDist, 1.0);
                    const radialDepth = 1.0 - (normDist * 0.7); // Base radial depth
                    
                    // Add Nuit boundary enhancement
                    const nuitDepth = 1.0 / (1.0 + distanceFromNuit * falloffFactor * 0.5);
                    const nuitBoost = (nuitDepth - 0.5) * 0.3; // Boost around boundary
                    
                    finalDepth = radialDepth + nuitBoost;
                    break;
                    
                case 'sum_xy':
                    // Sum XY S-coordinates method - depth based on sum of absolute S-coordinate values
                    const sumXY = Math.abs(sCoord.x) + Math.abs(sCoord.y);
                    const maxSum = currentSBounds * 2; // Maximum possible sum
                    const normalizedSum = Math.min(sumXY / maxSum, 1.0);
                    
                    // Invert so that higher sums (edges/corners) = closer, lower sums (center) = farther
                    finalDepth = 0.2 + (normalizedSum * 0.8); // Range: 0.2 to 1.0
                    break;
                
                case 'vectorfield':
                    // Vector field depth calculation
                    finalDepth = calculateVectorFieldDepth(sCoord);
                    break;
                    
                default:
                    finalDepth = 0.5;
            }
            
            // Apply contrast enhancement
            const contrastedDepth = Math.pow(Math.max(0, finalDepth), 0.7);
            
            // Ensure reasonable bounds
            return Math.min(1.0, Math.max(0.05, contrastedDepth));
        }
        
        /**
         * Calculate depth based on vector field in S-coordinate space
         */
        function calculateVectorFieldDepth(sCoord) {
            // The pattern type - can be hardcoded or added as a UI option later
            const patternType = 'waves';  // Options: 'waves', 'spiral', 'vortex', 'checkerboard'
            
            // Get vector field from pattern
            const vector = getVectorFieldPattern(sCoord, patternType, vectorFieldTime);
            
            // Calculate magnitude of the vector field
            const fieldMagnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
            
            // Normalize to 0-1 range
            let depthValue = fieldMagnitude % 1.0;
            if (depthValue < 0) depthValue += 1.0;
            
            // Ensure minimum depth for better stereo effect
            return 0.1 + (depthValue * 0.9);
        }

        // Creates different vector field patterns
        function getVectorFieldPattern(sCoord, patternType, time) {
            switch (patternType) {
                case 'waves':
                    return {
                        x: Math.sin(sCoord.x * 0.5 + time) * Math.cos(sCoord.y * 0.3),
                        y: Math.cos(sCoord.x * 0.4) * Math.sin(sCoord.y * 0.6 + time)
                    };
                    
                case 'spiral':
                    const angle = Math.atan2(sCoord.y, sCoord.x) + time;
                    const radius = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                    return {
                        x: Math.cos(angle + radius * 0.5),
                        y: Math.sin(angle + radius * 0.5)
                    };
                    
                case 'vortex':
                    const dx = sCoord.x;
                    const dy = sCoord.y;
                    const dist = Math.sqrt(dx*dx + dy*dy) + 0.0001;
                    return {
                        x: -dy / dist + Math.sin(time),
                        y: dx / dist + Math.cos(time)
                    };
                    
                case 'checkerboard':
                    const gridSize = 0.5;
                    const xGrid = Math.floor((sCoord.x + time) / gridSize) % 2;
                    const yGrid = Math.floor(sCoord.y / gridSize) % 2;
                    return {
                        x: xGrid === 0 ? 0.5 : 1.5,
                        y: yGrid === 0 ? 0.5 : 1.5
                    };
                    
                default:
                    return {
                        x: Math.sin(sCoord.x * 0.5 + time),
                        y: Math.cos(sCoord.y * 0.6 + time)
                    };
            }
        }
        
        // Test function to create a simple test depth map
        function createTestDepthMap(width, height) {
            const testDepthData = new Uint8ClampedArray(width * height * 4);
            
            // Create a simple gradient: left side = far (dark), right side = close (bright)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Simple left-to-right gradient
                    const depth = Math.floor((x / width) * 255);
                    
                    testDepthData[idx] = depth;     // R
                    testDepthData[idx + 1] = depth; // G
                    testDepthData[idx + 2] = depth; // B
                    testDepthData[idx + 3] = 255;   // A
                }
            }
            
            return testDepthData;
        }
        
        // Add depth map visualization for debugging
        function showDepthMapDebug(depthImgData) {
            // Create or get debug canvas
            let debugCanvas = document.getElementById('depthMapDebug');
            if (!debugCanvas) {
                debugCanvas = document.createElement('canvas');
                debugCanvas.id = 'depthMapDebug';
                debugCanvas.style.position = 'fixed';
                debugCanvas.style.top = '100px';
                debugCanvas.style.left = '5px';
                debugCanvas.style.width = '150px';
                debugCanvas.style.height = '100px';
                debugCanvas.style.border = '1px solid white';
                debugCanvas.style.zIndex = '1002';
                debugCanvas.style.opacity = '0.8';
                debugCanvas.title = 'Depth Map Visualization (darker = closer)';
                document.body.appendChild(debugCanvas);
            }
            
            debugCanvas.width = depthImgData.width;
            debugCanvas.height = depthImgData.height;
            const debugCtx = debugCanvas.getContext('2d');
            debugCtx.putImageData(depthImgData, 0, 0);
            
            // Log depth statistics
            let minDepth = 255, maxDepth = 0, avgDepth = 0;
            for (let i = 0; i < depthImgData.data.length; i += 4) {
                const depth = depthImgData.data[i];
                minDepth = Math.min(minDepth, depth);
                maxDepth = Math.max(maxDepth, depth);
                avgDepth += depth;
            }
            avgDepth /= (depthImgData.data.length / 4);
            
            debugLog(`Depth map stats: min=${minDepth}, max=${maxDepth}, avg=${avgDepth.toFixed(1)}, range=${maxDepth-minDepth}`);
        }
        
        // Try to set up WebGL for GPU acceleration
        function setupWebGL() {
            try {
                // Create a test WebGL context
                const testCanvas = document.createElement('canvas');
                const gl = testCanvas.getContext('webgl', {
                    powerPreference: 'high-performance',
                    antialias: false,
                    alpha: false
                }) || testCanvas.getContext('experimental-webgl');
                
                if (!gl) {
                    debugLog("WebGL not supported on this device");
                    return false;
                }
                
                // Check for required capabilities
                const extensions = gl.getSupportedExtensions();
                if (!extensions.includes('OES_texture_float') && !extensions.includes('OES_texture_half_float')) {
                    debugLog("Required WebGL extensions not supported");
                    return false;
                }
                
                // Test if we can create basic textures and framebuffers
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                
                const framebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                
                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    debugLog("WebGL framebuffer creation failed");
                    return false;
                }
                
                // Clean up
                gl.deleteTexture(texture);
                gl.deleteFramebuffer(framebuffer);
                
                debugLog("WebGL acceleration available and working");
                return true;
            } catch (e) {
                debugLog("WebGL setup error: " + e.message);
                return false;
            }
        }
        
        // Improved camera enumeration
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                debugLog(`Found ${videoDevices.length} camera(s)`);
                
                detectedCameras.all = videoDevices;
                
                // Reset camera assignments for fresh detection
                detectedCameras.front = null;
                detectedCameras.back = null;
                
                // Try to identify front/back cameras by label
                videoDevices.forEach((device, index) => {
                    const label = (device.label || '').toLowerCase();
                    debugLog(`Camera ${index+1}: ${label || 'Unnamed'} (${device.deviceId.substring(0, 8)}...)`);
                    
                    // Look for keywords that typically indicate front/back cameras
                    if (/back|rear|environment|main/i.test(label)) {
                        detectedCameras.back = device.deviceId;
                        debugLog(`Identified back camera by label: ${label}`);
                    }
                    if (/front|user|face|selfie/i.test(label)) {
                        detectedCameras.front = device.deviceId;
                        debugLog(`Identified front camera by label: ${label}`);
                    }
                });
                
                // If we couldn't identify by keywords but have multiple cameras
                if (videoDevices.length > 1) {
                    // Different assumptions based on platform
                    if (isAndroid) {
                        // On Android, camera 0 is often back camera, camera 1 is front
                        if (!detectedCameras.back) {
                            detectedCameras.back = videoDevices[0]?.deviceId;
                            debugLog("Using Android assumption: first camera is back camera");
                        }
                        if (!detectedCameras.front) {
                            detectedCameras.front = videoDevices[1]?.deviceId;
                            debugLog("Using Android assumption: second camera is front camera");
                        }
                    } else {
                        // On iOS/others, camera 0 is often front, camera 1 is back
                        if (!detectedCameras.front) {
                            detectedCameras.front = videoDevices[0]?.deviceId;
                            debugLog("Using iOS/default assumption: first camera is front camera");
                        }
                        if (!detectedCameras.back) {
                            detectedCameras.back = videoDevices[1]?.deviceId;
                            debugLog("Using iOS/default assumption: second camera is back camera");
                        }
                    }
                } else if (videoDevices.length === 1) {
                    // If only one camera, use it for both
                    detectedCameras.front = detectedCameras.back = videoDevices[0].deviceId;
                    debugLog("Only one camera found, using it for both front and back");
                }
                
                debugLog(`Camera detection results - Front: ${detectedCameras.front ? 'Found' : 'Not found'}, Back: ${detectedCameras.back ? 'Found' : 'Not found'}`);
                
                return videoDevices.length > 0;
            } catch (error) {
                debugLog("Camera enumeration failed: " + error.message);
                return false;
            }
        }
        
        // Get the user's camera based on the desired facing mode
        async function getUserMedia(useFront = false) {
            // First, enumerate cameras to understand what's available
            await enumerateCameras();
            
            const targetCamera = useFront ? 
                (detectedCameras.front || detectedCameras.all[0]?.deviceId) :
                (detectedCameras.back || detectedCameras.all[0]?.deviceId);
            
            debugLog(`Requesting ${useFront ? 'front' : 'back'} camera: ${targetCamera?.substring(0, 8) || 'fallback'}...`);
            
            // First try with the specific camera ID
            if (targetCamera) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: targetCamera },
                            width: { ideal: 1280, max: 1920 },
                            height: { ideal: 720, max: 1080 },
                            frameRate: { ideal: 30, max: 60 }
                        }
                    });
                    
                    detectedCameras.current = targetCamera;
                    debugLog(`Successfully got specific camera: ${targetCamera.substring(0, 8)}...`);
                    return stream;
                } catch (error) {
                    debugLog(`Failed to get specific camera ${targetCamera.substring(0, 8)}...: ${error.message}`);
                }
            }
            
            // Fallback to facing mode constraint if specific camera fails
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: useFront ? 'user' : 'environment',
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 30, max: 60 }
                    }
                });
                
                debugLog(`Got camera using facingMode: ${useFront ? 'user' : 'environment'}`);
                return stream;
            } catch (error) {
                debugLog(`Failed to get camera with facingMode: ${error.message}`);
            }
            
            // Final fallback - any available camera
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 30, max: 60 }
                    }
                });
                
                debugLog("Got any available camera as final fallback");
                return stream;
            } catch (error) {
                debugLog(`All camera access methods failed: ${error.message}`);
                throw new Error('Could not access any camera: ' + error.message);
            }
        }

        // Start the camera and set up video
        async function startCamera() {
            try {
                debugLog("Starting camera...");
                
                // Stop existing stream if any
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                
                currentStream = await getUserMedia(useFrontCamera);
                
                // Create video element if it doesn't exist
                if (!video) {
                    video = document.createElement('video');
                    video.playsInline = true;
                    video.muted = true;
                    video.autoplay = true;
                    
                    // Set up video event handlers
                    video.addEventListener('loadedmetadata', () => {
                        debugLog(`Video loaded: ${video.videoWidth}x${video.videoHeight}`);
                        // Update canvas sizes when video metadata loads
                        updateCanvasSizes();
                    });
                    
                    video.addEventListener('loadeddata', () => {
                        debugLog("Video data loaded, starting render loop");
                        renderFrame(); // Start the render loop
                    });
                }
                
                video.srcObject = currentStream;
                
                // Update button text
                document.getElementById('startButton').textContent = 'Stop Camera';
                document.getElementById('switchButton').disabled = false;
                
                debugLog("Camera started successfully");
                
            } catch (error) {
                debugLog("Failed to start camera: " + error.message);
                alert("Camera access failed: " + error.message);
            }
        }

        // Stop the camera
        function stopCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            
            if (video) {
                video.srcObject = null;
            }
            
            // Update button text
            document.getElementById('startButton').textContent = 'Start Camera';
            document.getElementById('switchButton').disabled = true;
            
            debugLog("Camera stopped");
        }

        // Switch between front and back camera
        async function switchCamera() {
            useFrontCamera = !useFrontCamera;
            debugLog(`Switching to ${useFrontCamera ? 'front' : 'back'} camera`);
            await startCamera();
        }

        // Update canvas sizes based on video dimensions and quality factor
        function updateCanvasSizes() {
            if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
                return;
            }
            
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            // Calculate canvas dimensions based on quality factor and size factor
            const baseWidth = Math.floor(video.videoWidth * qualityFactor);
            const baseHeight = Math.floor(video.videoHeight * qualityFactor);
            
            // Set actual canvas resolution (affects processing)
            canvas1.width = baseWidth;
            canvas1.height = baseHeight;
            canvas2.width = baseWidth;
            canvas2.height = baseHeight;
            
            // Set display size based on size factor (affects visual size)
            const displayWidth = Math.floor(baseWidth * canvasSizeFactor);
            const displayHeight = Math.floor(baseHeight * canvasSizeFactor);
            
            canvas1.style.width = displayWidth + 'px';
            canvas1.style.height = displayHeight + 'px';
            canvas2.style.width = displayWidth + 'px';
            canvas2.style.height = displayHeight + 'px';
            
            // Update processing canvas sizes
            processingCanvas.width = baseWidth;
            processingCanvas.height = baseHeight;
            depthMapCanvas.width = baseWidth;
            depthMapCanvas.height = baseHeight;
            
            debugLog(`Canvas updated: ${baseWidth}x${baseHeight} (display: ${displayWidth}x${displayHeight})`);
        }

        // Apply Gaussian blur to ImageData
        function applyGaussianBlur(imageData, radius) {
            if (radius <= 0) return imageData;
            
            const width = imageData.width;
            const height = imageData.height;
            const data = new Uint8ClampedArray(imageData.data);
            const output = new Uint8ClampedArray(imageData.data.length);
            
            // Simple box blur approximation (3 passes for Gaussian-like effect)
            const boxSize = Math.ceil(radius * 2);
            
            for (let pass = 0; pass < 3; pass++) {
                // Horizontal pass
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const centerIdx = (y * width + x) * 4;
                        let r = 0, g = 0, b = 0, count = 0;
                        
                        for (let dx = -boxSize; dx <= boxSize; dx++) {
                            const sampleX = Math.max(0, Math.min(width - 1, x + dx));
                            const sampleIdx = (y * width + sampleX) * 4;
                            
                            r += data[sampleIdx];
                            g += data[sampleIdx + 1];
                            b += data[sampleIdx + 2];
                            count++;
                        }
                        
                        output[centerIdx] = r / count;
                        output[centerIdx + 1] = g / count;
                        output[centerIdx + 2] = b / count;
                        output[centerIdx + 3] = data[centerIdx + 3];
                    }
                }
                
                // Copy output back to data for next pass
                data.set(output);
            }
            
            return new ImageData(output, width, height);
        }

        // Create depth map from S-coordinates - MODIFIED TO ADD HADIT CASE
        function createDepthMapFromSCoordinates(imageData, width, height) {
            const depthData = new Uint8ClampedArray(width * height * 4);
            const data = imageData.data;
            
            // Get current control values
            const nuitRadius = currentNuitRadius;
            const falloffFactor = parseFloat(document.getElementById('nuitFalloffFactor').value);
            const luminosityWeight = parseFloat(document.getElementById('luminosityWeight').value);
            const saturationWeight = parseFloat(document.getElementById('saturationWeight').value);
            const depthMode = document.getElementById('depthMode').value;
            
            // Update vector field time if using vector field mode
            if (depthMode === 'vectorfield') {
                const currentTime = performance.now() / 1000;
                const deltaTime = currentTime - lastUpdateTime;
                if (deltaTime > 0.016) { // ~60fps
                    vectorFieldTime += deltaTime * 0.5; // Animation speed
                    lastUpdateTime = currentTime;
                }
            }
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Extract RGB values and calculate luminance and saturation
                    const r = data[idx] / 255;
                    const g = data[idx + 1] / 255;
                    const b = data[idx + 2] / 255;
                    
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b);
                    const minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    let depth;
                    
                    // HADIT CASE ADDED HERE
                    if (depthMode === 'hadit') {
                        depth = calculateHaditDepth(x, y, width, height, lum, sat);
                    } else {
                        const sCoord = pixelToSCoordinate(x, y, width, height, lum, sat, luminosityWeight, saturationWeight);
                        depth = calculateNuitDistanceDepth(sCoord, nuitRadius, falloffFactor);
                    }
                    
                    // Apply quantization if enabled
                    if (document.getElementById('depthQuantizeToggle').checked) {
                        const levels = parseInt(document.getElementById('depthLevels').value);
                        depth = Math.floor(depth * levels) / levels;
                    }
                    
                    // Convert depth to grayscale (inverted: darker = closer for proper depth maps)
                    const depthValue = Math.floor((1.0 - depth) * 255);
                    
                    depthData[idx] = depthValue;     // R
                    depthData[idx + 1] = depthValue; // G
                    depthData[idx + 2] = depthValue; // B
                    depthData[idx + 3] = 255;        // A
                }
            }
            
            return new ImageData(depthData, width, height);
        }

        // Create stereoscopic effect from depth map
        function createStereoscopicEffect(originalImageData, depthImageData, canvas1, canvas2) {
            const width = originalImageData.width;
            const height = originalImageData.height;
            
            const ctx1 = canvas1.getContext('2d');
            const ctx2 = canvas2.getContext('2d');
            
            // Get baseline separation and depth intensity from controls
            const baselineSeparation = parseFloat(document.getElementById('baselineSeparation').value);
            const depthIntensity = parseInt(document.getElementById('depthIntensity').value);
            const blurRadius = parseInt(document.getElementById('blurRadius').value);
            
            // Apply blur to original image if enabled
            let processedImageData = originalImageData;
            if (blurRadius > 0) {
                processedImageData = applyGaussianBlur(originalImageData, blurRadius);
            }
            
            // Create ImageData for left and right eye views
            const leftImageData = ctx1.createImageData(width, height);
            const rightImageData = ctx2.createImageData(width, height);
            
            const originalData = processedImageData.data;
            const depthData = depthImageData.data;
            const leftData = leftImageData.data;
            const rightData = rightImageData.data;
            
            // Calculate maximum displacement based on baseline separation
            const maxDisplacement = Math.floor(width * baselineSeparation * 0.01);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Get depth value (0-255, where 0 = closest, 255 = farthest)
                    const depth = depthData[idx] / 255.0;
                    
                    // Calculate displacement based on depth and intensity
                    const displacement = Math.floor((1.0 - depth) * maxDisplacement * (depthIntensity / 25.0));
                    
                    // Calculate source pixel positions for stereoscopic effect
                    const leftSrcX = Math.max(0, Math.min(width - 1, x + displacement));
                    const rightSrcX = Math.max(0, Math.min(width - 1, x - displacement));
                    
                    const leftSrcIdx = (y * width + leftSrcX) * 4;
                    const rightSrcIdx = (y * width + rightSrcX) * 4;
                    
                    // Copy pixels with displacement
                    leftData[idx] = originalData[leftSrcIdx];
                    leftData[idx + 1] = originalData[leftSrcIdx + 1];
                    leftData[idx + 2] = originalData[leftSrcIdx + 2];
                    leftData[idx + 3] = originalData[leftSrcIdx + 3];
                    
                    rightData[idx] = originalData[rightSrcIdx];
                    rightData[idx + 1] = originalData[rightSrcIdx + 1];
                    rightData[idx + 2] = originalData[rightSrcIdx + 2];
                    rightData[idx + 3] = originalData[rightSrcIdx + 3];
                }
            }
            
            // Apply color filters from controls
            const red1 = parseInt(document.getElementById('redSlider1').value);
            const green1 = parseInt(document.getElementById('greenSlider1').value);
            const blue1 = parseInt(document.getElementById('blueSlider1').value);
            
            const red2 = parseInt(document.getElementById('redSlider2').value);
            const green2 = parseInt(document.getElementById('greenSlider2').value);
            const blue2 = parseInt(document.getElementById('blueSlider2').value);
            
            // Apply color tinting
            for (let i = 0; i < leftData.length; i += 4) {
                leftData[i] = (leftData[i] * red1) / 255;
                leftData[i + 1] = (leftData[i + 1] * green1) / 255;
                leftData[i + 2] = (leftData[i + 2] * blue1) / 255;
                
                rightData[i] = (rightData[i] * red2) / 255;
                rightData[i + 1] = (rightData[i + 1] * green2) / 255;
                rightData[i + 2] = (rightData[i + 2] * blue2) / 255;
            }
            
            // Draw the processed images to canvases
            ctx1.putImageData(leftImageData, 0, 0);
            ctx2.putImageData(rightImageData, 0, 0);
        }

        // Main render loop
        function renderFrame() {
            if (!video || !currentStream || video.readyState < 2) {
                // Continue trying if video isn't ready
                requestAnimationFrame(renderFrame);
                return;
            }
            
            // Throttle to target FPS
            const currentTime = performance.now();
            if (currentTime - lastFrameTime < frameInterval) {
                requestAnimationFrame(renderFrame);
                return;
            }
            lastFrameTime = currentTime;
            
            try {
                // Update canvas sizes if needed
                updateCanvasSizes();
                
                const canvas1 = document.getElementById('canvas1');
                const canvas2 = document.getElementById('canvas2');
                const ctx1 = canvas1.getContext('2d');
                const ctx2 = canvas2.getContext('2d');
                
                // Draw video frame to processing canvas
                processingCtx.drawImage(video, 0, 0, processingCanvas.width, processingCanvas.height);
                const imageData = processingCtx.getImageData(0, 0, processingCanvas.width, processingCanvas.height);
                
                // Create depth map from S-coordinates
                const depthImageData = createDepthMapFromSCoordinates(imageData, processingCanvas.width, processingCanvas.height);
                
                // Show depth map debug if enabled
                if (document.getElementById('debugOutput').style.display !== 'none') {
                    showDepthMapDebug(depthImageData);
                }
                
                // Create stereoscopic effect
                createStereoscopicEffect(imageData, depthImageData, canvas1, canvas2);
                
                // Apply tilt effect if enabled
                const tilt = parseFloat(document.getElementById('tiltSlider').value);
                if (tilt > 0) {
                    canvas1.style.transform = `rotateY(${tilt}rad)`;
                    canvas2.style.transform = `rotateY(${-tilt}rad)`;
                } else {
                    canvas1.style.transform = '';
                    canvas2.style.transform = '';
                }
                
            } catch (error) {
                debugLog("Render error: " + error.message);
            }
            
            // Continue the render loop
            requestAnimationFrame(renderFrame);
        }

        // Flicker mode functions
        function enableFlickerMode() {
            if (flickerMode) return;
            
            flickerMode = true;
            const container = document.querySelector('.container');
            container.classList.add('flicker-active');
            
            // Store original positions
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            originalCanvasPositions.canvas1.left = canvas1.style.left;
            originalCanvasPositions.canvas1.margin = canvas1.style.margin;
            originalCanvasPositions.canvas1.transform = canvas1.style.transform;
            
            originalCanvasPositions.canvas2.left = canvas2.style.left;
            originalCanvasPositions.canvas2.margin = canvas2.style.margin;
            originalCanvasPositions.canvas2.transform = canvas2.style.transform;
            
            // Set initial positions
            positionCanvasesForFlicker();
            
            // Start flicker animation
            flickerInterval = setInterval(() => {
                flickerFrame = 1 - flickerFrame; // Toggle between 0 and 1
                positionCanvasesForFlicker();
            }, flickerSpeed);
            
            // Show flicker indicator
            document.getElementById('flickerIndicator').style.opacity = '1';
            document.getElementById('toggleFlickerMode').textContent = 'Disable 3D Flicker';
            document.getElementById('flickerSpeedContainer').style.display = 'flex';
            
            debugLog("3D Flicker mode enabled");
        }

        function disableFlickerMode() {
            if (!flickerMode) return;
            
            flickerMode = false;
            const container = document.querySelector('.container');
            container.classList.remove('flicker-active');
            
            // Stop flicker animation
            if (flickerInterval) {
                clearInterval(flickerInterval);
                flickerInterval = null;
            }
            
            // Restore original positions
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            canvas1.style.left = originalCanvasPositions.canvas1.left;
            canvas1.style.margin = originalCanvasPositions.canvas1.margin;
            canvas1.style.transform = originalCanvasPositions.canvas1.transform;
            canvas1.classList.remove('canvas-left', 'canvas-right');
            
            canvas2.style.left = originalCanvasPositions.canvas2.left;
            canvas2.style.margin = originalCanvasPositions.canvas2.margin;
            canvas2.style.transform = originalCanvasPositions.canvas2.transform;
            canvas2.classList.remove('canvas-left', 'canvas-right');
            
            // Hide flicker indicator
            document.getElementById('flickerIndicator').style.opacity = '0';
            document.getElementById('toggleFlickerMode').textContent = 'Enable 3D Flicker';
            document.getElementById('flickerSpeedContainer').style.display = 'none';
            
            debugLog("3D Flicker mode disabled");
        }

        function positionCanvasesForFlicker() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            if (flickerFrame === 0) {
                // Normal position: canvas1 left, canvas2 right
                canvas1.className = 'canvas-left';
                canvas2.className = 'canvas-right';
            } else {
                // Swapped position: canvas2 left, canvas1 right
                canvas1.className = 'canvas-right';
                canvas2.className = 'canvas-left';
            }
        }

        // Freeze delay functionality
        let freezeTimeout = null;
        let freezeCountdownInterval = null;

        function triggerFreezeDelay() {
            if (!document.getElementById('freezeDelayToggle').checked) return;
            
            let countdown = 3;
            const countdownDiv = document.getElementById('freezeCountdown');
            countdownDiv.textContent = countdown;
            countdownDiv.style.display = 'block';
            
            freezeCountdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownDiv.textContent = countdown;
                } else {
                    clearInterval(freezeCountdownInterval);
                    countdownDiv.style.display = 'none';
                    
                    // Freeze the canvases
                    const canvas1 = document.getElementById('canvas1');
                    const canvas2 = document.getElementById('canvas2');
                    canvas1.classList.add('frozen-canvas');
                    canvas2.classList.add('frozen-canvas');
                    
                    // Unfreeze after 2 seconds
                    freezeTimeout = setTimeout(() => {
                        canvas1.classList.remove('frozen-canvas');
                        canvas2.classList.remove('frozen-canvas');
                        freezeTimeout = null;
                    }, 2000);
                }
            }, 1000);
        }

        // Recording functionality
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = null;
        let recordingTimer = null;

        function startRecording() {
            try {
                // Create a composite canvas for recording
                const recordCanvas = document.createElement('canvas');
                const canvas1 = document.getElementById('canvas1');
                const canvas2 = document.getElementById('canvas2');
                
                recordCanvas.width = (canvas1.width + canvas2.width);
                recordCanvas.height = canvas1.height;
                
                const recordCtx = recordCanvas.getContext('2d');
                
                // Function to draw both canvases side by side
                function drawComposite() {
                    recordCtx.clearRect(0, 0, recordCanvas.width, recordCanvas.height);
                    recordCtx.drawImage(canvas1, 0, 0);
                    recordCtx.drawImage(canvas2, canvas1.width, 0);
                }
                
                // Initial draw
                drawComposite();
                
                // Get canvas stream
                const stream = recordCanvas.captureStream(30);
                
                // Set up periodic composite updates
                const updateInterval = setInterval(drawComposite, 33); // ~30fps
                
                // Set up MediaRecorder
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9'
                });
                
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = function() {
                    clearInterval(updateInterval);
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    // Create download link
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `AndroidVR_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    URL.revokeObjectURL(url);
                    debugLog("Recording saved");
                };
                
                // Start recording
                mediaRecorder.start();
                recordingStartTime = Date.now();
                
                // Update UI
                document.getElementById('recordButton').style.display = 'none';
                document.getElementById('stopRecordButton').style.display = 'flex';
                document.getElementById('recordingIndicator').style.display = 'flex';
                
                // Start timer
                recordingTimer = setInterval(updateRecordingTimer, 1000);
                
                debugLog("Recording started");
                
            } catch (error) {
                debugLog("Recording failed: " + error.message);
                alert("Recording failed: " + error.message);
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            
            // Update UI
            document.getElementById('recordButton').style.display = 'flex';
            document.getElementById('stopRecordButton').style.display = 'none';
            document.getElementById('recordingIndicator').style.display = 'none';
            
            recordingStartTime = null;
            mediaRecorder = null;
            
            debugLog("Recording stopped");
        }

        function updateRecordingTimer() {
            if (!recordingStartTime) return;
            
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            document.getElementById('recordingTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Control panel toggle
        function toggleControls() {
            const controlPanel = document.getElementById('controlPanel');
            const toggleButton = document.getElementById('toggleControls');
            
            controlsHidden = !controlsHidden;
            
            if (controlsHidden) {
                controlPanel.style.display = 'none';
                toggleButton.textContent = 'Show Controls';
            } else {
                controlPanel.style.display = 'flex';
                toggleButton.textContent = 'Hide Controls';
            }
        }

        // Quality change handler
        function changeQuality() {
            const newQuality = parseFloat(document.getElementById('qualitySelect').value);
            qualityFactor = newQuality;
            
            // Update quality indicator
            const indicator = document.getElementById('qualityIndicator');
            const percentage = Math.round(newQuality * 100);
            indicator.textContent = `Processing at ${percentage}% resolution`;
            indicator.style.opacity = '1';
            
            // Hide indicator after 2 seconds
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
            
            // Update canvas sizes
            updateCanvasSizes();
            
            debugLog(`Quality changed to ${percentage}%`);
        }

        // Update value displays
        function updateValueDisplays() {
            // Update Nuit Radius value display
            const nuitRadius = document.getElementById('nuitRadius');
            const nuitRadiusValue = document.getElementById('nuitRadiusValue');
            if (nuitRadius && nuitRadiusValue) {
                currentNuitRadius = parseFloat(nuitRadius.value);
                nuitRadiusValue.textContent = currentNuitRadius.toFixed(1);
            }
            
            // Update S Bounds value display
            const sBounds = document.getElementById('sBounds');
            const sBoundsValue = document.getElementById('sBoundsValue');
            if (sBounds && sBoundsValue) {
                currentSBounds = parseFloat(sBounds.value);
                sBoundsValue.textContent = `±${currentSBounds.toFixed(1)}`;
            }
            
            // Update Baseline Separation value display
            const baselineSeparation = document.getElementById('baselineSeparation');
            const baselineSeparationValue = document.getElementById('baselineSeparationValue');
            if (baselineSeparation && baselineSeparationValue) {
                baselineSeparationValue.textContent = `${parseFloat(baselineSeparation.value).toFixed(1)}%`;
            }
        }

        // HADIT MODE INITIALIZATION FUNCTION - ONLY ADDITION
        function initializeHaditMode() {
            if (document.getElementById('depthMode').value === 'hadit') {
                // Set S bounds to Hadit-specific value
                currentSBounds = haditParams.sBounds;
                document.getElementById('sBounds').value = haditParams.sBounds;
                document.getElementById('sBoundsValue').textContent = `±${haditParams.sBounds}`;
                
                // Set luminosity and saturation weights to Hadit values
                document.getElementById('luminosityWeight').value = haditParams.luminosityWeight;
                document.getElementById('saturationWeight').value = haditParams.saturationWeight;
                
                debugLog(`Hadit mode initialized: θ=${haditParams.theta}°, φ=${haditParams.phi}°, S-bounds=±${haditParams.sBounds}`);
            }
        }

        // Initialize application
        function initializeApp() {
            debugLog("Initializing AndroidVR application...");
            
            // Try to detect WebGL support
            const webglSupported = setupWebGL();
            if (webglSupported) {
                renderMethod = 'webgl';
                debugLog("Using WebGL acceleration");
            } else {
                debugLog("Using Canvas 2D rendering");
            }
            
            // Set up event listeners
            
            // Camera controls
            document.getElementById('startButton').addEventListener('click', () => {
                if (currentStream) {
                    stopCamera();
                } else {
                    startCamera();
                }
            });
            
            document.getElementById('switchButton').addEventListener('click', switchCamera);
            
            // View controls
            document.getElementById('tiltSlider').addEventListener('input', triggerFreezeDelay);
            
            document.getElementById('sizeSlider').addEventListener('input', (e) => {
                canvasSizeFactor = parseFloat(e.target.value);
                updateCanvasSizes();
            });
            
            document.getElementById('toggleFlickerMode').addEventListener('click', () => {
                if (flickerMode) {
                    disableFlickerMode();
                } else {
                    enableFlickerMode();
                }
            });
            
            document.getElementById('flickerSpeedSlider').addEventListener('input', (e) => {
                flickerSpeed = parseInt(e.target.value);
                if (flickerMode) {
                    disableFlickerMode();
                    enableFlickerMode();
                }
            });
            
            // Depth mode controls
            document.getElementById('nuitRadius').addEventListener('input', updateValueDisplays);
            document.getElementById('sBounds').addEventListener('input', updateValueDisplays);
            document.getElementById('baselineSeparation').addEventListener('input', updateValueDisplays);
            
            // Quality control
            document.getElementById('qualitySelect').addEventListener('change', changeQuality);
            
            // Controls toggle
            document.getElementById('toggleControls').addEventListener('click', toggleControls);
            
            // Recording controls
            document.getElementById('recordButton').addEventListener('click', startRecording);
            document.getElementById('stopRecordButton').addEventListener('click', stopRecording);
            
            // HADIT MODE EVENT LISTENER - ONLY ADDITION
            const depthModeSelect = document.getElementById('depthMode');
            if (depthModeSelect) {
                depthModeSelect.addEventListener('change', function() {
                    if (this.value === 'hadit') {
                        initializeHaditMode();
                        debugLog("Switched to Hadit mode with configured parameters");
                    }
                });
            }
            
            // Initialize value displays
            updateValueDisplays();
            
            // Set initial quality indicator
            changeQuality();
            
            debugLog("AndroidVR application initialized successfully");
            debugLog("Hadit mode integration complete - ready for enhanced depth processing");
        }

        // Start the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', initializeApp);

        // Handle page visibility changes to pause/resume
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                debugLog("Page hidden - pausing processing");
            } else {
                debugLog("Page visible - resuming processing");
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            setTimeout(updateCanvasSizes, 100);
        });

        // Global error handler
        window.addEventListener('error', (event) => {
            debugLog(`Global error: ${event.error?.message || event.message}`);
        });

        // Expose some functions globally for debugging
        window.debugApp = {
            showDebug: () => {
                document.getElementById('debugOutput').style.display = 'block';
            },
            hideDebug: () => {
                document.getElementById('debugOutput').style.display = 'none';
            },
            clearDebug: () => {
                document.getElementById('debugOutput').innerHTML = '';
            },
            getState: () => ({
                currentStream: !!currentStream,
                video: !!video,
                useFrontCamera,
                flickerMode,
                qualityFactor,
                currentNuitRadius,
                currentSBounds,
                renderMethod,
                haditParams
            })
        };

        debugLog("AndroidVR script loaded - ready to initialize");
    </script>
</body>
</html>
