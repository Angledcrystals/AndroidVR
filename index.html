<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AndroidVR - Live Hadit Camera</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 5px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-bottom: 15px;
        }

        .camera-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stereo-view {
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .camera-feed {
            position: relative;
        }

        canvas {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            max-width: 100%;
            height: auto;
        }

        .left-eye { border-color: #ff4444 !important; }
        .right-eye { border-color: #4444ff !important; }
        .depth-map { border-color: #ff8800 !important; }

        .camera-label {
            text-align: center;
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .left-label { color: #ff4444; }
        .right-label { color: #4444ff; }
        .depth-label { color: #ff8800; }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #00ff88;
            margin-bottom: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 3px;
            font-size: 10px;
            width: 60px;
        }

        select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            cursor: pointer;
            font-size: 10px;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .camera-control {
            background: rgba(0, 255, 136, 0.2) !important;
            border-color: #00ff88 !important;
        }

        .hadit-control {
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: #ff00ff !important;
        }

        .stereo-control {
            background: rgba(255, 68, 136, 0.2) !important;
            border-color: #ff4488 !important;
        }

        .depth-control {
            background: rgba(255, 136, 0, 0.2) !important;
            border-color: #ff8800 !important;
        }

        .dual-input {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dual-input input[type="range"] {
            flex: 1;
            margin-bottom: 0;
        }

        .dual-input input[type="number"] {
            flex: 0 0 auto;
        }

        .info-panel {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .hadit-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .analysis-panel {
            background: rgba(136, 255, 0, 0.1);
            border: 1px solid #88ff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .processing {
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5) !important;
            animation: processing 1s ease-in-out infinite;
        }

        @keyframes processing {
            0% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
        }

        .fps-counter {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
        }

        .camera-status {
            text-align: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .status-connecting { color: #ffff00; }
        .status-active { color: #00ff88; }
        .status-error { color: #ff4444; }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .stereo-view {
                flex-direction: column;
                align-items: center;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            
            canvas {
                max-width: 90vw;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AndroidVR - Live Hadit Camera</h1>
        <div class="subtitle">Real-time Fine Hadit Control: 0.1¬∞ Precision | Current Date and Time (UTC): 2025-06-07 07:09:50 | User: Angledcrystals</div>

        <div class="hadit-info">
            <div style="color: #ff00ff; font-weight: bold;">‚ö° Live Hadit Processing:</div>
            <div>‚Ä¢ Real-time camera feed with Hadit depth generation</div>
            <div>‚Ä¢ Œ∏ (Theta): 0¬∞ to 360¬∞ in 0.1¬∞ increments for live adjustment</div>
            <div>‚Ä¢ œÜ (Phi): 0.1¬∞ to 179.9¬∞ in 0.1¬∞ increments for extreme precision</div>
            <div>‚Ä¢ Parallel stereo view with pixel-perfect offset based on Hadit depth</div>
            <div>‚Ä¢ Optimized for mobile VR viewing</div>
        </div>

        <div class="camera-status" id="cameraStatus">
            <span class="status-connecting">üìπ Initializing camera...</span>
        </div>

        <div class="camera-container">
            <div class="stereo-view">
                <div class="camera-feed">
                    <div class="camera-label left-label">Left Eye (Red)</div>
                    <canvas id="leftCanvas" width="640" height="480" class="left-eye"></canvas>
                    <div class="fps-counter" id="leftFps">0 FPS</div>
                </div>
                <div class="camera-feed">
                    <div class="camera-label right-label">Right Eye (Blue)</div>
                    <canvas id="rightCanvas" width="640" height="480" class="right-eye"></canvas>
                    <div class="fps-counter" id="rightFps">0 FPS</div>
                </div>
                <div class="camera-feed">
                    <div class="camera-label depth-label">Hadit Depth</div>
                    <canvas id="depthCanvas" width="320" height="240" class="depth-map"></canvas>
                    <div class="fps-counter" id="depthFps">0 FPS</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>üìπ Camera Control</label>
                <button id="startCamera" class="camera-control">‚ñ∂Ô∏è Start Camera</button>
                <button id="switchCamera" class="camera-control">üîÑ Switch Camera</button>
                <button id="stopCamera" class="camera-control">‚èπÔ∏è Stop Camera</button>
            </div>
            
            <div class="control-group">
                <label>üìê Camera Resolution</label>
                <select id="resolutionSelect" class="camera-control">
                    <option value="640x480" selected>640x480 (VGA)</option>
                    <option value="1280x720">1280x720 (HD)</option>
                    <option value="1920x1080">1920x1080 (FHD)</option>
                    <option value="320x240">320x240 (Low)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit Œ∏ (Theta): <span id="haditThetaValue">45.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditTheta" min="0" max="360" value="45" step="0.1" class="hadit-control">
                    <input type="number" id="haditThetaNumber" min="0" max="360" step="0.1" value="45" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit œÜ (Phi): <span id="haditPhiValue">60.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditPhi" min="0.1" max="179.9" value="60" step="0.1" class="hadit-control">
                    <input type="number" id="haditPhiNumber" min="0.1" max="179.9" step="0.1" value="60" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>üåä Hadit Influence: <span id="haditInfluenceValue">1.0</span></label>
                <input type="range" id="haditInfluence" min="0" max="2" value="1.0" step="0.1" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üéØ Focus Factor: <span id="focusFactorValue">2.0x</span></label>
                <input type="range" id="focusFactor" min="1.0" max="5.0" step="0.1" value="2.0" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üëÅÔ∏è Stereo Separation: <span id="separationValue">8px</span></label>
                <input type="range" id="separation" min="0" max="50" value="8" step="1" class="stereo-control">
            </div>
            
            <div class="control-group">
                <label>üó∫Ô∏è Depth Intensity: <span id="depthIntensityValue">1.5x</span></label>
                <input type="range" id="depthIntensity" min="0.1" max="5.0" value="1.5" step="0.1" class="depth-control">
            </div>
            
            <div class="control-group">
                <label>üìê S Bounds: <span id="sBoundsValue">¬±10.0</span></label>
                <input type="range" id="sBounds" min="1.0" max="20.0" step="0.1" value="10.0" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üí° Luminosity Weight: <span id="luminosityWeightValue">0.7</span></label>
                <input type="range" id="luminosityWeight" min="0" max="1" step="0.05" value="0.7">
            </div>
            
            <div class="control-group">
                <label>üåà Saturation Weight: <span id="saturationWeightValue">0.3</span></label>
                <input type="range" id="saturationWeight" min="0" max="1" step="0.05" value="0.3">
            </div>
            
            <div class="control-group">
                <label>‚öôÔ∏è Processing Quality</label>
                <select id="qualitySelect" class="depth-control">
                    <option value="1.0">Full Quality</option>
                    <option value="0.75" selected>High Quality</option>
                    <option value="0.5">Medium Quality</option>
                    <option value="0.25">Low Quality</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>üîÑ Update Rate</label>
                <select id="updateRate" class="depth-control">
                    <option value="60">60 FPS</option>
                    <option value="30" selected>30 FPS</option>
                    <option value="15">15 FPS</option>
                    <option value="10">10 FPS</option>
                </select>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <div>Status: Live Hadit camera system ready... Angledcrystals | 2025-06-07 07:09:50 UTC</div>
        </div>

        <div class="analysis-grid">
            <div>
                <div class="control-group">
                    <label>Quick Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHaditPole" class="hadit-control">œÜ=0.1¬∞ (Pole)</button>
                        <button id="setHaditEquator" class="hadit-control">œÜ=90¬∞ (Equator)</button>
                        <button id="setHaditNear180" class="hadit-control">œÜ=179.9¬∞ (Anti-pole)</button>
                        <button id="animateTheta" class="hadit-control">üåÄ Animate Œ∏</button>
                        <button id="animatePhi" class="hadit-control">üåä Animate œÜ</button>
                        <button id="stopAnimation" class="hadit-control">‚èπÔ∏è Stop All</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Options</label>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label><input type="checkbox" id="enableStereo" checked> Enable Stereo</label>
                        <label><input type="checkbox" id="showDepthMap" checked> Show Depth</label>
                        <label><input type="checkbox" id="mirrorCamera"> Mirror Camera</label>
                        <label><input type="checkbox" id="showFPS" checked> Show FPS</label>
                        <label><input type="checkbox" id="debugMode"> Debug Mode</label>
                    </div>
                </div>
            </div>
            
            <div class="analysis-panel" id="analysisPanel">
                <div style="color: #88ff00; font-weight: bold;">‚ö° Live Hadit Analysis</div>
                <div>Ready for live camera processing...</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== HADIT MATHEMATICS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function calculateHaditModulatedSCoordinate(px, py, width, height, lum, sat, config) {
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            const contentModulation = (1 + lum * config.luminosityWeight + sat * config.saturationWeight);
            
            return {
                x: S_hadit.x * contentModulation * config.haditInfluence,
                y: S_hadit.y * contentModulation * config.haditInfluence
            };
        }

        // ==================== LIVE CAMERA PROCESSING ====================
        
        class LiveHaditCamera {
            constructor() {
                this.video = null;
                this.stream = null;
                this.isRunning = false;
                this.useFrontCamera = false;
                this.animationFrameId = null;
                this.animationId = null;
                
                // Performance tracking
                this.frameCount = 0;
                this.lastFpsTime = 0;
                this.currentFps = 0;
                
                // Processing canvases
                this.processingCanvas = document.createElement('canvas');
                this.processingCtx = this.processingCanvas.getContext('2d');
                
                this.initializeControls();
                this.setupCanvases();
                this.updateInfoPanel('Live Hadit camera system ready! | Angledcrystals | 2025-06-07 07:09:50 UTC');
                
                console.log('‚úÖ Live Hadit Camera System initialized!');
                console.log('Œ∏ (Theta) range: 0¬∞ to 360¬∞ in 0.1¬∞ increments');
                console.log('œÜ (Phi) range: 0.1¬∞ to 179.9¬∞ in 0.1¬∞ increments');
            }

            setupCanvases() {
                this.leftCanvas = document.getElementById('leftCanvas');
                this.rightCanvas = document.getElementById('rightCanvas');
                this.depthCanvas = document.getElementById('depthCanvas');
                
                this.leftCtx = this.leftCanvas.getContext('2d');
                this.rightCtx = this.rightCanvas.getContext('2d');
                this.depthCtx = this.depthCanvas.getContext('2d');
            }

            getConfiguration() {
                return {
                    haditTheta: parseFloat(document.getElementById('haditTheta')?.value || 45),
                    haditPhi: parseFloat(document.getElementById('haditPhi')?.value || 60),
                    haditInfluence: parseFloat(document.getElementById('haditInfluence')?.value || 1.0),
                    focusFactor: parseFloat(document.getElementById('focusFactor')?.value || 2.0),
                    separation: parseFloat(document.getElementById('separation')?.value || 8),
                    depthIntensity: parseFloat(document.getElementById('depthIntensity')?.value || 1.5),
                    sBounds: parseFloat(document.getElementById('sBounds')?.value || 10.0),
                    luminosityWeight: parseFloat(document.getElementById('luminosityWeight')?.value || 0.7),
                    saturationWeight: parseFloat(document.getElementById('saturationWeight')?.value || 0.3),
                    quality: parseFloat(document.getElementById('qualitySelect')?.value || 0.75),
                    updateRate: parseInt(document.getElementById('updateRate')?.value || 30),
                    enableStereo: document.getElementById('enableStereo')?.checked ?? true,
                    showDepthMap: document.getElementById('showDepthMap')?.checked ?? true,
                    mirrorCamera: document.getElementById('mirrorCamera')?.checked ?? false,
                    showFPS: document.getElementById('showFPS')?.checked ?? true,
                    debugMode: document.getElementById('debugMode')?.checked ?? false
                };
            }

            async startCamera() {
                try {
                    this.updateCameraStatus('üìπ Connecting to camera...', 'connecting');
                    
                    const resolution = document.getElementById('resolutionSelect').value.split('x');
                    const width = parseInt(resolution[0]);
                    const height = parseInt(resolution[1]);
                    
                    const constraints = {
                        video: {
                            width: { ideal: width },
                            height: { ideal: height },
                            frameRate: { ideal: 30 },
                            facingMode: this.useFrontCamera ? 'user' : 'environment'
                        }
                    };

                    if (this.stream) {
                        this.stream.getTracks().forEach(track => track.stop());
                    }

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    if (!this.video) {
                        this.video = document.createElement('video');
                        this.video.autoplay = true;
                        this.video.playsInline = true;
                        this.video.muted = true;
                    }
                    
                    this.video.srcObject = this.stream;
                    
                    await new Promise((resolve) => {
                        this.video.addEventListener('loadedmetadata', resolve, { once: true });
                    });
                    
                    this.isRunning = true;
                    this.updateCameraStatus('üìπ Camera active - Live Hadit processing', 'active');
                    this.updateInfoPanel(`Camera started: ${this.video.videoWidth}x${this.video.videoHeight} | Live Hadit processing active`);
                    
                    this.startProcessingLoop();
                    
                    document.getElementById('startCamera').style.display = 'none';
                    document.getElementById('stopCamera').style.display = 'inline-block';
                    
                } catch (error) {
                    console.error('Camera start error:', error);
                    this.updateCameraStatus('‚ùå Camera access failed', 'error');
                    this.updateInfoPanel('Camera access failed: ' + error.message);
                }
            }

            stopCamera() {
                this.isRunning = false;
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                if (this.video) {
                    this.video.srcObject = null;
                }
                
                this.updateCameraStatus('üìπ Camera stopped', 'connecting');
                this.updateInfoPanel('Camera stopped. Click Start Camera to resume live Hadit processing.');
                
                document.getElementById('startCamera').style.display = 'inline-block';
                document.getElementById('stopCamera').style.display = 'none';
                
                // Clear canvases
                [this.leftCtx, this.rightCtx, this.depthCtx].forEach(ctx => {
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                });
            }

            async switchCamera() {
                if (this.isRunning) {
                    this.useFrontCamera = !this.useFrontCamera;
                    this.updateInfoPanel(`Switching to ${this.useFrontCamera ? 'front' : 'back'} camera...`);
                    await this.startCamera();
                }
            }

            startProcessingLoop() {
                const config = this.getConfiguration();
                const targetInterval = 1000 / config.updateRate;
                let lastTime = 0;
                
                const processFrame = (currentTime) => {
                    if (!this.isRunning) return;
                    
                    if (currentTime - lastTime >= targetInterval) {
                        this.processVideoFrame();
                        lastTime = currentTime;
                        
                        // Update FPS
                        this.frameCount++;
                        if (currentTime - this.lastFpsTime >= 1000) {
                            this.currentFps = this.frameCount;
                            this.frameCount = 0;
                            this.lastFpsTime = currentTime;
                            this.updateFpsDisplay();
                        }
                    }
                    
                    this.animationFrameId = requestAnimationFrame(processFrame);
                };
                
                this.animationFrameId = requestAnimationFrame(processFrame);
            }

            processVideoFrame() {
                if (!this.video || this.video.readyState < this.video.HAVE_CURRENT_DATA) return;
                
                const config = this.getConfiguration();
                const startTime = performance.now();
                
                // Setup processing canvas with quality scaling
                const sourceWidth = this.video.videoWidth;
                const sourceHeight = this.video.videoHeight;
                const processWidth = Math.floor(sourceWidth * config.quality);
                const processHeight = Math.floor(sourceHeight * config.quality);
                
                this.processingCanvas.width = processWidth;
                this.processingCanvas.height = processHeight;
                
                // Draw video frame to processing canvas
                this.processingCtx.save();
                if (config.mirrorCamera) {
                    this.processingCtx.scale(-1, 1);
                    this.processingCtx.translate(-processWidth, 0);
                }
                this.processingCtx.drawImage(this.video, 0, 0, processWidth, processHeight);
                this.processingCtx.restore();
                
                // Get image data for processing
                const imageData = this.processingCtx.getImageData(0, 0, processWidth, processHeight);
                
                // Generate Hadit depth map and stereo views
                this.generateHaditStereoViews(imageData, config);
                
                const processingTime = performance.now() - startTime;
                
                if (config.debugMode) {
                    this.updateAnalysisPanel(processingTime, config);
                }
            }

            generateHaditStereoViews(imageData, config) {
                const { width, height, data } = imageData;
                
                // Setup output canvases
                this.leftCanvas.width = width;
                this.leftCanvas.height = height;
                this.rightCanvas.width = width;
                this.rightCanvas.height = height;
                this.depthCanvas.width = width;
                this.depthCanvas.height = height;
                
                // Create output image data
                const leftImageData = this.leftCtx.createImageData(width, height);
                const rightImageData = this.rightCtx.createImageData(width, height);
                const depthImageData = this.depthCtx.createImageData(width, height);
                
                const leftData = leftImageData.data;
                const rightData = rightImageData.data;
                const depthData = depthImageData.data;
                
                let totalDepth = 0;
                let pixelCount = 0;
                let minDepth = 1;
                let maxDepth = 0;
                
                // Process each pixel
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Get pixel color
                        const r = data[idx] / 255;
                        const g = data[idx + 1] / 255;
                        const b = data[idx + 2] / 255;
                        
                        // Calculate luminosity and saturation
                        const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                        const maxCol = Math.max(r, g, b);
                        const minCol = Math.min(r, g, b);
                        const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                        
                        // Calculate Hadit-modulated S-coordinate
                        const sCoord = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                        const sMagnitude = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                        
                        // Calculate depth based on Hadit S-magnitude
                        const normalizedDepth = Math.min(sMagnitude / (config.sBounds * 2), 1.0);
                        let depth = 0.2 + (normalizedDepth * 0.8);
                        
                        // Apply focus factor
                        depth = 0.5 + (depth - 0.5) * config.focusFactor;
                        
                        // Apply content modulation
                        const contentWeight = lum * 0.5 + sat * 0.3;
                        depth *= (1 + contentWeight * 0.3);
                        
                        // Clamp depth
                        depth = Math.max(0.05, Math.min(1.0, depth));
                        
                        // Update statistics
                        totalDepth += depth;
                        pixelCount++;
                        minDepth = Math.min(minDepth, depth);
                        maxDepth = Math.max(maxDepth, depth);
                        
                        // Calculate stereo displacement
                        const normalizedDepthDisplacement = (depth - 0.5) * 2;
                        const displacement = Math.round(normalizedDepthDisplacement * config.separation * config.depthIntensity);
                        
                        // Original pixel values
                        const originalR = data[idx];
                        const originalG = data[idx + 1];
                        const originalB = data[idx + 2];
                        
                        if (config.enableStereo) {
                            // Left eye: sample from right-shifted position
                            const leftSampleX = Math.max(0, Math.min(width - 1, x + displacement));
                            const leftSampleIdx = (y * width + leftSampleX) * 4;
                            
                            leftData[idx] = data[leftSampleIdx];
                            leftData[idx + 1] = data[leftSampleIdx + 1];
                            leftData[idx + 2] = data[leftSampleIdx + 2];
                            leftData[idx + 3] = 255;
                            
                            // Right eye: sample from left-shifted position
                            const rightSampleX = Math.max(0, Math.min(width - 1, x - displacement));
                            const rightSampleIdx = (y * width + rightSampleX) * 4;
                            
                            rightData[idx] = data[rightSampleIdx];
                            rightData[idx + 1] = data[rightSampleIdx + 1];
                            rightData[idx + 2] = data[rightSampleIdx + 2];
                            rightData[idx + 3] = 255;
                        } else {
                            // No stereo - copy original
                            leftData[idx] = originalR;
                            leftData[idx + 1] = originalG;
                            leftData[idx + 2] = originalB;
                            leftData[idx + 3] = 255;
                            
                            rightData[idx] = originalR;
                            rightData[idx + 1] = originalG;
                            rightData[idx + 2] = originalB;
                            rightData[idx + 3] = 255;
                        }
                        
                        // Depth visualization
                        if (config.showDepthMap) {
                            const depthGray = Math.round(depth * 255);
                            depthData[idx] = depthGray;
                            depthData[idx + 1] = depthGray;
                            depthData[idx + 2] = depthGray;
                            depthData[idx + 3] = 255;
                        } else {
                            depthData[idx] = originalR;
                            depthData[idx + 1] = originalG;
                            depthData[idx + 2] = originalB;
                            depthData[idx + 3] = 255;
                        }
                    }
                }
                
                // Draw processed images
                this.leftCtx.putImageData(leftImageData, 0, 0);
                this.rightCtx.putImageData(rightImageData, 0, 0);
                this.depthCtx.putImageData(depthImageData, 0, 0);
                
                // Store stats for analysis
                this.lastProcessingStats = {
                    avgDepth: totalDepth / pixelCount,
                    minDepth,
                    maxDepth,
                    pixelCount,
                    depthRange: maxDepth - minDepth
                };
            }

            updateCameraStatus(message, status) {
                const statusElement = document.getElementById('cameraStatus');
                if (statusElement) {
                    statusElement.innerHTML = `<span class="status-${status}">${message}</span>`;
                }
            }

            updateFpsDisplay() {
                const config = this.getConfiguration();
                if (config.showFPS) {
                    document.getElementById('leftFps').textContent = `${this.currentFps} FPS`;
                    document.getElementById('rightFps').textContent = `${this.currentFps} FPS`;
                    document.getElementById('depthFps').textContent = `${this.currentFps} FPS`;
                }
            }

            updateAnalysisPanel(processingTime, config) {
                if (this.lastProcessingStats) {
                    const stats = this.lastProcessingStats;
                    const analysisPanel = document.getElementById('analysisPanel');
                    
                    if (analysisPanel) {
                        analysisPanel.innerHTML = `
                            <div style="color: #88ff00; font-weight: bold;">‚ö° Live Hadit Analysis</div>
                            <div>FPS: ${this.currentFps} | Process: ${processingTime.toFixed(1)}ms</div>
                            <div>Œ∏ (Theta): ${config.haditTheta.toFixed(1)}¬∞</div>
                            <div>œÜ (Phi): ${config.haditPhi.toFixed(1)}¬∞</div>
                            <div>Influence: ${config.haditInfluence.toFixed(2)}</div>
                            <div>Focus Factor: ${config.focusFactor.toFixed(1)}x</div>
                            <div>Separation: ${config.separation}px</div>
                            <div>Depth Intensity: ${config.depthIntensity.toFixed(1)}x</div>
                            <div>S Bounds: ¬±${config.sBounds.toFixed(1)}</div>
                            <div>Quality: ${(config.quality * 100).toFixed(0)}%</div>
                            <div>Avg Depth: ${stats.avgDepth.toFixed(3)}</div>
                            <div>Depth Range: ${stats.depthRange.toFixed(3)}</div>
                            <div>Resolution: ${this.video ? this.video.videoWidth + 'x' + this.video.videoHeight : 'N/A'}</div>
                        `;
                    }
                }
            }

            updateInfoPanel(message) {
                const infoPanel = document.getElementById('infoPanel');
                if (infoPanel) {
                    const timestamp = new Date().toLocaleTimeString();
                    infoPanel.innerHTML = `<div>${timestamp}: ${message}</div>`;
                }
            }

            initializeControls() {
                // Camera controls
                document.getElementById('startCamera')?.addEventListener('click', () => {
                    this.startCamera();
                });
                
                document.getElementById('stopCamera')?.addEventListener('click', () => {
                    this.stopCamera();
                });
                
                document.getElementById('switchCamera')?.addEventListener('click', () => {
                    this.switchCamera();
                });

                // Synchronized dual inputs for theta
                const thetaSlider = document.getElementById('haditTheta');
                const thetaNumber = document.getElementById('haditThetaNumber');
                
                thetaSlider?.addEventListener('input', () => {
                    thetaNumber.value = thetaSlider.value;
                    this.updateControlValues();
                });
                
                thetaNumber?.addEventListener('input', () => {
                    const value = Math.max(0, Math.min(360, parseFloat(thetaNumber.value) || 0));
                    thetaSlider.value = value;
                    thetaNumber.value = value;
                    this.updateControlValues();
                });

                // Synchronized dual inputs for phi
                const phiSlider = document.getElementById('haditPhi');
                const phiNumber = document.getElementById('haditPhiNumber');
                
                phiSlider?.addEventListener('input', () => {
                    phiNumber.value = phiSlider.value;
                    this.updateControlValues();
                });
                
                phiNumber?.addEventListener('input', () => {
                    const value = Math.max(0.1, Math.min(179.9, parseFloat(phiNumber.value) || 0.1));
                    phiSlider.value = value;
                    phiNumber.value = value;
                    this.updateControlValues();
                });

                // Preset buttons
                document.getElementById('setHaditPole')?.addEventListener('click', () => {
                    phiSlider.value = 0.1;
                    phiNumber.value = 0.1;
                    this.updateControlValues();
                    this.updateInfoPanel('Set œÜ to 0.1¬∞ (near pole) - extreme Hadit geometry!');
                });

                document.getElementById('setHaditEquator')?.addEventListener('click', () => {
                    phiSlider.value = 90.0;
                    phiNumber.value = 90.0;
                    this.updateControlValues();
                    this.updateInfoPanel('Set œÜ to 90¬∞ (equator) - balanced Hadit geometry.');
                });

                document.getElementById('setHaditNear180')?.addEventListener('click', () => {
                    phiSlider.value = 179.9;
                    phiNumber.value = 179.9;
                    this.updateControlValues();
                    this.updateInfoPanel('Set œÜ to 179.9¬∞ (near anti-pole) - inverted Hadit geometry!');
                });

                // Animation controls
                document.getElementById('animateTheta')?.addEventListener('click', () => {
                    this.startThetaAnimation();
                });

                document.getElementById('animatePhi')?.addEventListener('click', () => {
                    this.startPhiAnimation();
                });

                document.getElementById('stopAnimation')?.addEventListener('click', () => {
                    this.stopAllAnimations();
                });

                // Other controls
                const controls = [
                    'haditInfluence', 'focusFactor', 'separation', 'depthIntensity',
                    'sBounds', 'luminosityWeight', 'saturationWeight'
                ];
                
                controls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => {
                            this.updateControlValues();
                        });
                    }
                });

                this.updateControlValues();
            }

            updateControlValues() {
                const controls = [
                    { id: 'haditTheta', suffix: '¬∞', precision: 1 },
                    { id: 'haditPhi', suffix: '¬∞', precision: 1 },
                    { id: 'haditInfluence', suffix: '', precision: 1 },
                    { id: 'focusFactor', suffix: 'x', precision: 1 },
                    { id: 'separation', suffix: 'px' },
                    { id: 'depthIntensity', suffix: 'x', precision: 1 },
                    { id: 'sBounds', suffix: '', prefix: '¬±', precision: 1 },
                    { id: 'luminosityWeight', suffix: '', precision: 2 },
                    { id: 'saturationWeight', suffix: '', precision: 2 }
                ];

                controls.forEach(({ id, suffix, prefix, precision }) => {
                    const element = document.getElementById(id);
                    const valueElement = document.getElementById(id + 'Value');
                    if (element && valueElement) {
                        const prefixText = prefix || '';
                        const value = precision ? parseFloat(element.value).toFixed(precision) : element.value;
                        valueElement.textContent = prefixText + value + suffix;
                    }
                });
            }

            startThetaAnimation() {
                this.stopAllAnimations();
                this.updateInfoPanel('Started Œ∏ animation - 0.1¬∞ precision live updates!');
                
                let animationTime = 0;
                const animate = () => {
                    animationTime += 0.5; // 0.5 degree steps for smooth animation
                    const newTheta = (animationTime % 360);
                    
                    document.getElementById('haditTheta').value = newTheta.toFixed(1);
                    document.getElementById('haditThetaNumber').value = newTheta.toFixed(1);
                    this.updateControlValues();
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                this.animationId = requestAnimationFrame(animate);
            }

            startPhiAnimation() {
                this.stopAllAnimations();
                this.updateInfoPanel('Started œÜ animation - 0.1¬∞ precision through full range!');
                
                let animationTime = 0;
                const animate = () => {
                    animationTime += 0.02; // Slower animation for phi
                    const newPhi = 0.1 + (Math.sin(animationTime) * 0.5 + 0.5) * (179.9 - 0.1);
                    
                    document.getElementById('haditPhi').value = newPhi.toFixed(1);
                    document.getElementById('haditPhiNumber').value = newPhi.toFixed(1);
                    this.updateControlValues();
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                this.animationId = requestAnimationFrame(animate);
            }

            stopAllAnimations() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                    this.updateInfoPanel('All animations stopped. Manual control restored.');
                }
            }
        }

        // ==================== INITIALIZATION ====================
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('‚ö° Initializing Live Hadit Camera System...');
            console.log('Current Date and Time (UTC): 2025-06-07 07:09:50');
            console.log('Current User Login: Angledcrystals');
            console.log('Live camera processing with 0.1¬∞ Hadit precision');
            
            try {
                window.haditCamera = new LiveHaditCamera();
                console.log('‚úÖ Live Hadit Camera system ready!');
                console.log('üìπ Click "Start Camera" to begin live processing');
            } catch (error) {
                console.error('‚ùå Initialization failed:', error);
            }
        });

    </script>
</body>
</html>
