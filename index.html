<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>AndroidVR - Hadit S-Coordinate Depth Detection</title>
    <style>
        /* All your existing styles unchanged */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }

        /* Canvas container takes all available space */
        .container {
            flex: 1;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            width: 100vw;
            perspective: 1000px;
            overflow: hidden;
            padding-top: 10px; /* Space from top */
            position: relative; /* For absolute positioning in flicker mode */
        }

        /* Canvas will maintain camera aspect ratio */
        canvas {
            border: 2px solid white;
            border-radius: 10px;
            transform-origin: center;
            transition: transform 0.2s ease;
            margin: 0 4px;
            height: auto; /* Auto height based on container */
            position: relative; /* For flicker mode */
            will-change: transform, left, right; /* Hint for GPU acceleration */
        }

        /* Hardware acceleration hints */
        canvas, video {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
            will-change: transform;
        }

        /* Prevent unnecessary repaints */
        body, .container, .control-panel {
            will-change: transform;
        }

        /* Control panel at the bottom */
        .control-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            padding: 5px 5px;
            z-index: 1000;
        }

        /* Control rows */
        .control-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 3px; /* Reduced margin */
        }

        /* Control sections */
        .control-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 5px;
        }

        /* Control section headers */
        .section-header {
            font-size: 0.7rem; /* Smaller font */
            text-transform: uppercase;
            margin-bottom: 1px;
            color: #ccc;
        }

        /* Control elements */
        .control-item {
            display: flex;
            align-items: center;
            margin: 1px 0; /* Reduced margin */
        }

        label {
            font-size: 0.7rem; /* Smaller font */
            margin-right: 5px;
            min-width: 45px;
        }

        input[type="range"] {
            width: 70px;
            height: 12px; /* Thinner sliders */
        }

        select {
            width: 70px;
            font-size: 0.7rem;
            background: #333;
            color: white;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 1px;
        }

        button {
            margin: 2px; /* Reduced margin */
            padding: 5px 8px; /* Smaller padding */
            font-size: 0.75rem; /* Smaller font */
            border: none;
            border-radius: 5px;
            background-color: #444;
            color: white;
            cursor: pointer;
        }

        button:hover {
            background-color: #666;
        }

        .divider {
            width: 1px;
            height: 35px; /* Shorter divider */
            background-color: #444;
            margin: 0 2px;
        }

        /* Top controls container */
        .top-controls {
            position: fixed;
            top: 5px;
            right: 5px;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Toggle button to hide/show controls - REPOSITIONED */
        #toggleControls {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #333;
        }

        #toggleControls:hover {
            opacity: 1;
        }

        /* Quality selector */
        #qualitySelect {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 5px;
        }

        #qualitySelect:hover {
            opacity: 1;
        }

        /* Quality indicator */
        #qualityIndicator {
            position: fixed;
            top: 40px;
            right: 5px;
            font-size: 0.65rem;
            color: #aaa;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Flicker indicator */
        #flickerIndicator {
            position: fixed;
            top: 70px;
            right: 5px;
            font-size: 0.65rem;
            color: #f55;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Hadit indicator */
        #haditIndicator {
            position: fixed;
            top: 100px;
            right: 5px;
            font-size: 0.65rem;
            color: #ff00ff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 1;
            transition: opacity 0.3s;
        }

        /* Debug output */
        #debugOutput {
            position: fixed;
            top: 5px;
            left: 5px;
            font-size: 0.65rem;
            color: #aaa;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
            max-width: 50%;
            max-height: 200px;
            overflow: auto;
        }

        /* Value display spans */
        .value-display {
            font-size: 0.6rem;
            color: #aaa;
            margin-left: 5px;
            min-width: 30px;
        }

        /* Hadit controls */
        .hadit-control {
            background-color: #2a0a2a !important;
            border: 1px solid #ff00ff !important;
        }

        /* Depth map display */
        #depthMapDisplay {
            position: fixed;
            top: 150px;
            left: 5px;
            width: 200px;
            height: 133px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            z-index: 1002;
            opacity: 0.9;
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
        }

        #depthMapDisplay canvas {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 3px;
        }

        #depthMapLabel {
            position: absolute;
            top: -20px;
            left: 0;
            font-size: 0.6rem;
            color: #00ff00;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1px 5px;
            border-radius: 3px;
        }

        /* Toggle depth map button */
        #toggleDepthMap {
            opacity: 0.7;
            font-size: 0.7rem;
            padding: 3px 6px;
            background-color: #003300;
            border: 1px solid #00ff00;
            color: #00ff00;
            border-radius: 5px;
        }

        #toggleDepthMap:hover {
            opacity: 1;
            background-color: #005500;
        }

        #toggleDepthMap.active {
            background-color: #007700;
            opacity: 1;
        }

        /* Portrait mode warning */
        @media (orientation: portrait) {
            body::before {
                content: "Please rotate your device to landscape mode.";
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-size: 1.5rem;
                text-align: center;
                z-index: 1000;
            }

            .container, .control-panel, .top-controls, #qualityIndicator {
                display: none;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            button {
                padding: 3px 6px;
                font-size: 0.65rem;
            }
            
            input[type="range"] {
                width: 60px;
            }
            
            label {
                font-size: 0.65rem;
                min-width: 40px;
            }
        }

        /* Firefox-specific CSS fixes */
        @-moz-document url-prefix() {
            video {
                transform-origin: center center;
                will-change: transform;
            }
            
            canvas {
                transform-origin: center center;
                will-change: transform;
            }
        }
        
        /* Flicker mode specific styles - for position swapping */
        .flicker-active .container {
            position: relative;
        }
        
        .flicker-active canvas {
            position: absolute !important; /* Added !important */
            transition: none !important; /* Disable transitions for flicker mode, added !important */
        }
        
        .canvas-left {
            left: calc(25% - 50px); /* Original positioning for flicker */
        }
        
        .canvas-right {
            left: calc(75% - 50px); /* Original positioning for flicker */
        }
        
        /* Frozen frame styles */
        .frozen-canvas {
            border-color: #ff4040 !important;
            box-shadow: 0 0 10px rgba(255, 64, 64, 0.7);
        }

        /* Recording Controls */
        .recording-controls {
            display: flex;
            align-items: center;
            margin-right: 5px;
        }

        .record-button {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: #333;
            border: none;
            color: white;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .record-button:hover {
            opacity: 1;
            background-color: #444;
        }

        .record-icon {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ff4040;
            display: inline-block;
        }

        .stop-icon {
            width: 10px;
            height: 10px;
            background-color: white;
            display: inline-block;
        }

        .stop-record {
            background-color: #c00;
        }

        .stop-record:hover {
            background-color: #e00;
        }

        .recording-indicator {
            display: flex;
            align-items: center;
            margin-left: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ff4040;
            margin-right: 5px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.8);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(0.8);
                opacity: 0.8;
            }
        }

        #recordingTimer {
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas1"></canvas>
        <canvas id="canvas2"></canvas>
        <div id="freezeCountdown" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255, 0, 0, 0.7); color: white; padding: 20px 30px; border-radius: 10px; font-size: 2rem; font-weight: bold; z-index: 1000;">
            Freezing in <span id="countdownValue">3</span>
        </div>
    </div>
    
    <div id="depthMapDisplay">
        <div id="depthMapLabel">Hadit Depth Map</div>
        <canvas id="depthMapCanvas"></canvas>
    </div>
    
    <div class="top-controls">
        <div class="recording-controls">
            <button id="recordButton" class="record-button">
                <span class="record-icon"></span> Record
            </button>
            <button id="stopRecordButton" class="record-button stop-record" style="display:none">
                <span class="stop-icon"></span> Stop
            </button>
            <div id="recordingIndicator" class="recording-indicator" style="display:none">
                <span class="pulse-dot"></span>
                <span id="recordingTimer">00:00</span>
            </div>
        </div>
        <button id="toggleDepthMap">Show Depth</button>
        <select id="qualitySelect">
            <option value="1.0">High Quality</option>
            <option value="0.5" selected>Medium Quality</option>
            <option value="0.25">Low Quality</option>
            <option value="0.1">Very Low Quality</option>
        </select>
        <button id="toggleControls">Hide Controls</button>
    </div>
    
    <div id="qualityIndicator">Processing at 50% resolution</div>
    <div id="flickerIndicator">3D Flicker Mode Active</div>
    <div id="haditIndicator">Hadit: φ=0.1° θ=0.0° Focus=4.0x</div>
    <div id="debugOutput" style="display: none;"></div>
    
    <div class="control-panel" id="controlPanel">
        <div class="control-row">
            <div class="control-section">
                <div class="section-header">Camera</div>
                <div class="control-item">
                    <button id="startButton">Start Camera</button>
                    <button id="switchButton" disabled>Switch Camera</button>
                </div>
                 <div class="control-item">
                    <button id="freezeButton">Freeze Frame</button>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">View</div>
                <div class="control-item">
                    <label for="tiltSlider">Tilt</label>
                    <input id="tiltSlider" type="range" min="0" max="0.7" step="0.01" value="0">
                </div>
                <div class="control-item">
                    <label for="sizeSlider">Size</label>
                    <input id="sizeSlider" type="range" min="0.2" max="1.8" step="0.05" value="1.0">
                </div>
                <div class="control-item">
                    <button id="toggleFlickerMode">Enable 3D Flicker</button>
                </div>
                <div class="control-item" id="flickerSpeedContainer" style="display: none;">
                    <label for="flickerSpeedSlider">Speed</label>
                    <input id="flickerSpeedSlider" type="range" min="8" max="60" step="1" value="16">
                </div>
                <div class="control-item">
                    <label for="freezeDelayToggle">Freeze Delay</label>
                    <input id="freezeDelayToggle" type="checkbox">
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">⚡ Hadit S-Coordinate Depth</div>
                <div class="control-item">
                    <label for="haditTheta">θ (Theta)</label>
                    <input id="haditTheta" type="range" min="0" max="360" step="0.1" value="0.0" class="hadit-control">
                    <span id="haditThetaValue" class="value-display">0.0°</span>
                </div>
                <div class="control-item">
                    <label for="haditPhi">φ (Phi)</label>
                    <input id="haditPhi" type="range" min="0.1" max="179.9" step="0.1" value="0.1" class="hadit-control">
                    <span id="haditPhiValue" class="value-display">0.1°</span>
                </div>
                <div class="control-item">
                    <label for="haditInfluence">Influence</label>
                    <input id="haditInfluence" type="range" min="0" max="2" step="0.1" value="1.0" class="hadit-control">
                    <span id="haditInfluenceValue" class="value-display">1.0</span>
                </div>
                <div class="control-item">
                    <label for="focusFactor">Focus</label>
                    <input id="focusFactor" type="range" min="1.0" max="10.0" step="0.1" value="4.0" class="hadit-control">
                    <span id="focusFactorValue" class="value-display">4.0x</span>
                </div>
                <div class="control-item">
                    <label for="bandSizeMultiplier">Band Size</label>
                    <input id="bandSizeMultiplier" type="range" min="0.1" max="10.0" step="0.1" value="10.0" class="hadit-control">
                    <span id="bandSizeMultiplierValue" class="value-display">10.0x</span>
                </div>
                <div class="control-item">
                    <label for="bandMode">Band Mode</label>
                    <select id="bandMode" class="hadit-control">
                        <option value="full_image" selected>Full Image</option>
                        <option value="auto_detect">Auto Detect</option>
                        <option value="content_analysis">Content Analysis</option>
                        <option value="manual_range">Manual Range</option>
                    </select>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Enhanced Nuit Depth</div>
                <div class="control-item">
                    <label for="depthMode">Mode</label>
                    <select id="depthMode">
                        <option value="hadit_scoord" selected>Hadit S-Coord</option>
                        <option value="nuit">Nuit Only</option>
                        <option value="radial">Radial Zones</option>
                        <option value="hybrid">Hybrid</option>
                        <option value="sum_xy">Sum XY S-Coords</option>
                        <option value="vectorfield">Vector Field</option>
                    </select>
                </div>
                <div class="control-item">
                    <label for="nuitRadius">Nuit Radius</label>
                    <input id="nuitRadius" type="range" min="0.5" max="15.0" step="0.1" value="7.0">
                    <span id="nuitRadiusValue" class="value-display">7.0</span>
                </div>
                <div class="control-item">
                    <label for="sBounds">S Bounds</label>
                    <input id="sBounds" type="range" min="1.0" max="50.0" step="0.1" value="20.0">
                    <span id="sBoundsValue" class="value-display">±20.0</span>
                </div>
                <div class="control-item">
                    <label for="depthIntensity">Intensity</label>
                    <input id="depthIntensity" type="range" min="0" max="50" step="1" value="15">
                </div>
                <div class="control-item">
                    <label for="baselineSeparation">Eye Sep</label>
                    <input id="baselineSeparation" type="range" min="0.5" max="8.0" step="0.1" value="3.0">
                    <span id="baselineSeparationValue" class="value-display">3.0%</span>
                </div>
                <div class="control-item">
                    <label for="blurRadius">Blur</label>
                    <input id="blurRadius" type="range" min="0" max="10" step="1" value="1">
                </div>
                <div class="control-item">
                    <label for="nuitFalloffFactor">Falloff</label>
                    <input id="nuitFalloffFactor" type="range" min="1" max="20" step="0.5" value="5.0">
                </div>
                <div class="control-item">
                    <label for="depthQuantize">Quantize</label>
                    <input id="depthQuantizeToggle" type="checkbox">
                </div>
                <div class="control-item">
                    <label for="depthLevels">Levels</label>
                    <input id="depthLevels" type="range" min="2" max="16" step="1" value="8">
                </div>
            </div>
        </div>
        
        <div class="control-row">
            <div class="control-section">
                <div class="section-header">S-Coordinate Mapping</div>
                <div class="control-item">
                    <label for="luminosityWeight">Luminosity</label>
                    <input id="luminosityWeight" type="range" min="0" max="1" step="0.05" value="0.0">
                    <span id="luminosityWeightValue" class="value-display">0.0</span>
                </div>
                <div class="control-item">
                    <label for="saturationWeight">Saturation</label>
                    <input id="saturationWeight" type="range" min="0" max="1" step="0.05" value="0.0">
                    <span id="saturationWeightValue" class="value-display">0.0</span>
                </div>
                <div class="control-item">
                    <label for="depthContrast">Contrast</label>
                    <input id="depthContrast" type="range" min="0.1" max="3.0" step="0.1" value="0.2">
                    <span id="depthContrastValue" class="value-display">0.2x</span>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Left Color</div>
                <div class="control-item">
                    <label for="redSlider1">Red</label>
                    <input id="redSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="greenSlider1">Green</label>
                    <input id="greenSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="blueSlider1">Blue</label>
                    <input id="blueSlider1" type="range" min="0" max="255" step="1" value="255">
                </div>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-section">
                <div class="section-header">Right Color</div>
                <div class="control-item">
                    <label for="redSlider2">Red</label>
                    <input id="redSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="greenSlider2">Green</label>
                    <input id="greenSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
                <div class="control-item">
                    <label for="blueSlider2">Blue</label>
                    <input id="blueSlider2" type="range" min="0" max="255" step="1" value="255">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Current Date and Time (UTC - YYYY-MM-DD HH:MM:SS formatted): 2025-06-07 04:53:34
        // Current User's Login: Angledcrystals

        // ==================== HADIT MATHEMATICS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) return { x: 0, y: 0 };
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function calculateHaditSCoordinate(px, py, width, height, lum, sat, config) {
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            const contentModulation = (1 + lum * config.luminosityWeight + sat * config.saturationWeight);
            const S_modulated = {
                x: S_hadit.x * contentModulation * config.haditInfluence,
                y: S_hadit.y * contentModulation * config.haditInfluence
            };
            const sMagnitude = Math.sqrt(S_modulated.x * S_modulated.x + S_modulated.y * S_modulated.y);
            return { sCoord: S_modulated, sMagnitude: sMagnitude };
        }

        let detectedBand = null; // Global detected band for Hadit

        function detectHaditInformationBand(imageData, config) {
            const { width, height } = imageData; // data property not used directly here
            const bandMode = config.bandMode || 'full_image';
            const bandSizeMultiplier = config.bandSizeMultiplier || 1.0; // Default to 1 if not in config
            
            if (bandMode === 'full_image') {
                const bandWidth = config.sBounds * 10 * bandSizeMultiplier;
                return { min: 0, max: bandWidth, center: bandWidth / 2, width: bandWidth, confidence: 1.0 };
            }
            
            // Simplified auto-detection for now, can be expanded later
            const sMagnitudeHistogram = new Array(100).fill(0);
            const maxSMagnitude = config.sBounds * 2;
            const sampleStep = Math.max(1, Math.floor(Math.min(width, height) / 50));
            
            // This part needs imageData.data, assuming it's available if not full_image
            // For brevity, this example will assume full_image or a pre-set band if not full_image
            // In a full implementation, you'd process imageData.data for other modes here.

            // Fallback for non-full_image modes if data processing is omitted for brevity:
            const fallbackCenterS = maxSMagnitude / 2;
            const fallbackBandWidth = maxSMagnitude * 0.5 * bandSizeMultiplier;

            return {
                min: Math.max(0, fallbackCenterS - fallbackBandWidth / 2),
                max: fallbackCenterS + fallbackBandWidth / 2,
                center: fallbackCenterS,
                width: fallbackBandWidth,
                confidence: 0.5 // Lower confidence for fallback
            };
        }

        function calculateHaditDepth(sResult, currentDetectedBand, focusFactor, depthContrastVal) {
            const { sMagnitude } = sResult;
            let depth;

            if (currentDetectedBand && currentDetectedBand.width > 0) {
                const bandPosition = Math.max(0, Math.min(1, (sMagnitude - currentDetectedBand.min) / currentDetectedBand.width));
                depth = 0.2 + bandPosition * 0.8; // Base depth within band: 0.2 (far edge) to 1.0 (near edge)
                
                // Apply focus factor for in-band pixels
                if (sMagnitude >= currentDetectedBand.min && sMagnitude <= currentDetectedBand.max && focusFactor > 1.0) {
                    depth = 0.5 + (depth - 0.5) * focusFactor; // Focus around mid-point (0.5)
                }
            } else {
                // Fallback if no valid band (e.g. width is 0) or band not provided
                const maxS = parseFloat(document.getElementById('sBounds').value) * 2 || 40.0; // Use sBounds from UI
                depth = 0.2 + Math.min(1.0, sMagnitude / maxS) * 0.8;
            }
            
            // Apply depth contrast
            depth = Math.pow(Math.max(0.01, depth), 1.0 / Math.max(0.1, depthContrastVal));
            return { depth: Math.min(1.0, Math.max(0.01, depth)) };
        }
        
        // Convert depth value to color
        function depthToColor(depth) {
            depth = Math.max(0, Math.min(1, depth));
            if (depth < 0.2) { const t = depth / 0.2; return { r: 0, g: 0, b: Math.floor(128 + 127 * t) }; }
            else if (depth < 0.4) { const t = (depth - 0.2) / 0.2; return { r: 0, g: Math.floor(255 * t), b: 255 }; }
            else if (depth < 0.6) { const t = (depth - 0.4) / 0.2; return { r: 0, g: 255, b: Math.floor(255 * (1 - t)) }; }
            else if (depth < 0.8) { const t = (depth - 0.6) / 0.2; return { r: Math.floor(255 * t), g: 255, b: 0 }; }
            else { const t = (depth - 0.8) / 0.2; return { r: 255, g: Math.floor(255 * (1 - t)), b: 0 }; }
        }

        // Generate depth map for visual display
        function generateDepthMapFromCurrentFrame() {
            if (!depthMapVisible || !video || video.readyState < 2) return;

            const tempCanvas = document.createElement('canvas');
            const tempWidth = Math.round(video.videoWidth * 0.25); // Smaller for performance
            const tempHeight = Math.round(video.videoHeight * 0.25);
            tempCanvas.width = tempWidth; tempCanvas.height = tempHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0, tempWidth, tempHeight);
            const imageData = tempCtx.getImageData(0, 0, tempWidth, tempHeight);

            const depthMapDisplayCanvas = document.getElementById('depthMapCanvas');
            depthMapDisplayCanvas.width = tempWidth; depthMapDisplayCanvas.height = tempHeight;
            const depthCtx = depthMapDisplayCanvas.getContext('2d');
            const depthImageData = depthCtx.createImageData(tempWidth, tempHeight);

            const currentHaditConfig = getHaditConfigFromUI(); // Get current settings

            // Ensure detectedBand is up-to-date for this frame's config, or recalculate
            // For visual map, a fresh band detection might be good if config changed
            const currentFrameBand = detectHaditInformationBand(imageData, currentHaditConfig);

            let minVisDepth = 1.0, maxVisDepth = 0.0;
            const visDepthValues = new Float32Array(tempWidth * tempHeight);

            for (let y = 0; y < tempHeight; y++) {
                for (let x = 0; x < tempWidth; x++) {
                    const pixelIdx = (y * tempWidth + x) * 4;
                    const r = imageData.data[pixelIdx] / 255, g = imageData.data[pixelIdx + 1] / 255, b = imageData.data[pixelIdx + 2] / 255;
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b), minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    const sResult = calculateHaditSCoordinate(x, y, tempWidth, tempHeight, lum, sat, currentHaditConfig);
                    const depthResult = calculateHaditDepth(sResult, currentFrameBand, currentHaditConfig.focusFactor, currentHaditConfig.depthContrast);
                    
                    visDepthValues[y * tempWidth + x] = depthResult.depth;
                    minVisDepth = Math.min(minVisDepth, depthResult.depth);
                    maxVisDepth = Math.max(maxVisDepth, depthResult.depth);
                }
            }

            const visDepthRange = maxVisDepth - minVisDepth;
            for (let i = 0; i < visDepthValues.length; i++) {
                let normalizedDepth = 0.5;
                if (visDepthRange > 0.001) {
                    normalizedDepth = (visDepthValues[i] - minVisDepth) / visDepthRange;
                }
                const color = depthToColor(normalizedDepth);
                const pixelIdx = i * 4;
                depthImageData.data[pixelIdx] = color.r;
                depthImageData.data[pixelIdx + 1] = color.g;
                depthImageData.data[pixelIdx + 2] = color.b;
                depthImageData.data[pixelIdx + 3] = 255;
            }
            depthCtx.putImageData(depthImageData, 0, 0);
            latestDepthMap = depthImageData; // Store for other uses if needed
        }
        
        // Utility function for debugging
        function debugLog(message) {
            console.log(message);
            const debugOutput = document.getElementById('debugOutput');
            if (debugOutput && debugOutput.style.display !== 'none') {
                debugOutput.innerHTML += message + '<br>';
                debugOutput.scrollTop = debugOutput.scrollHeight;
            }
        }

        // Browser detection
        const isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isMobile = isAndroid || isIOS;
        
        // App state variables
        let currentStream = null;
        let video = null;
        let useFrontCamera = false;
        let controlsHidden = false;
        let qualityFactor = 0.5; // Default medium quality
        let lastFrameTime = 0;
        const targetFPS = 30;
        const frameInterval = 1000 / targetFPS;
        let isFrozen = false; // Added for freeze frame functionality
        
        let haditConfig = { // Global config, will be updated by UI and defaults
            haditTheta: 0.0,
            haditPhi: 0.1,
            haditInfluence: 1.0,
            focusFactor: 4.0,
            bandMode: 'full_image',
            bandSizeMultiplier: 10.0,
            luminosityWeight: 0.0,
            saturationWeight: 0.0,
            depthContrast: 0.2,
            sBounds: 20.0
        };
        
        let currentNuitRadius = 7.0;
        let currentSBounds = 20.0; 
        
        let detectedCameras = { front: null, back: null, current: null, all: [] };
        
        let flickerMode = false;
        let flickerFrame = 0; 
        let flickerInterval = null;
        let flickerSpeed = 16; 
        let originalCanvasPositions = {
            canvas1: { left: '', margin: '', transform: '' }, // Ensure properties are strings
            canvas2: { left: '', margin: '', transform: '' }
        };
        
        let processingCanvas = document.createElement('canvas');
        let processingCtx = processingCanvas.getContext('2d', { willReadFrequently: true });
        
        // Function to get current Hadit configuration from UI or defaults
        function getHaditConfigFromUI() {
            return {
                haditTheta: parseFloat(document.getElementById('haditTheta').value) || haditConfig.haditTheta,
                haditPhi: parseFloat(document.getElementById('haditPhi').value) || haditConfig.haditPhi,
                haditInfluence: parseFloat(document.getElementById('haditInfluence').value) || haditConfig.haditInfluence,
                focusFactor: parseFloat(document.getElementById('focusFactor').value) || haditConfig.focusFactor,
                bandMode: document.getElementById('bandMode').value || haditConfig.bandMode,
                bandSizeMultiplier: parseFloat(document.getElementById('bandSizeMultiplier').value) || haditConfig.bandSizeMultiplier,
                luminosityWeight: parseFloat(document.getElementById('luminosityWeight').value) || haditConfig.luminosityWeight,
                saturationWeight: parseFloat(document.getElementById('saturationWeight').value) || haditConfig.saturationWeight,
                depthContrast: parseFloat(document.getElementById('depthContrast').value) || haditConfig.depthContrast,
                sBounds: parseFloat(document.getElementById('sBounds').value) || haditConfig.sBounds
            };
        }

        // Apply stereo effect to frames - REVISED FOR HADIT OFFSETS
        function applyStereoEffect(processingCtx, leftCtx, rightCtx, leftColor, rightColor, separation, intensity, depthMode) {
            const width = processingCanvas.width;
            const height = processingCanvas.height;
            
            const originalFrameImageData = processingCtx.getImageData(0, 0, width, height);
            const leftOutputImageData = leftCtx.createImageData(leftCtx.canvas.width, leftCtx.canvas.height);
            const rightOutputImageData = rightCtx.createImageData(rightCtx.canvas.width, rightCtx.canvas.height);
            
            const scaleX = leftCtx.canvas.width / width;
            const scaleY = leftCtx.canvas.height / height;
            
            const currentHaditConfig = getHaditConfigFromUI(); // Get current settings for Hadit
            
            // Ensure detectedBand is up-to-date for the current frame and config
            // For performance, only recalculate if essential (e.g. config change or not yet detected)
            // Simplified: assume detectedBand is either globally fresh or we use a new one for this frame
            const currentFrameBand = detectHaditInformationBand(originalFrameImageData, currentHaditConfig);

            const depthMap = new Float32Array(width * height);
            let minFrameDepth = 1.0;
            let maxFrameDepth = 0.0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const pixelIdx = (y * width + x) * 4;
                    const r = originalFrameImageData.data[pixelIdx] / 255;
                    const g = originalFrameImageData.data[pixelIdx + 1] / 255;
                    const b = originalFrameImageData.data[pixelIdx + 2] / 255;
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    const maxCol = Math.max(r, g, b), minCol = Math.min(r, g, b);
                    const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                    
                    let currentPixelDepth = 0.5; // Default
                    if (depthMode === 'hadit_scoord') {
                        const sResult = calculateHaditSCoordinate(x, y, width, height, lum, sat, currentHaditConfig);
                        const depthResultObj = calculateHaditDepth(sResult, currentFrameBand, currentHaditConfig.focusFactor, currentHaditConfig.depthContrast);
                        currentPixelDepth = depthResultObj.depth;
                    } else { 
                        currentPixelDepth = 0.2 + lum * 0.8; 
                    }
                    
                    depthMap[y * width + x] = currentPixelDepth;
                    minFrameDepth = Math.min(minFrameDepth, currentPixelDepth);
                    maxFrameDepth = Math.max(maxFrameDepth, currentPixelDepth);
                }
            }
            
            const frameDepthRange = maxFrameDepth - minFrameDepth;
            for (let i = 0; i < depthMap.length; i++) {
                if (frameDepthRange > 0.001) {
                    depthMap[i] = (depthMap[i] - minFrameDepth) / frameDepthRange; // Normalized 0-1
                } else {
                    depthMap[i] = 0.5; 
                }
            }
            
            const separationAmount = separation * leftCtx.canvas.width / 100; // Use output canvas width for separation %
            let actualMaxOffset = Math.round(separationAmount * (intensity / 50.0)); // Intensity 0-50, map to 0-1 multiplier for offset

            if (depthMode === 'hadit_scoord') {
                 actualMaxOffset = Math.max(1, Math.round(actualMaxOffset * 1.2)); // Boost Hadit offset
            }
             if (actualMaxOffset === 0 && intensity > 0) actualMaxOffset = 1;


            function getPixelSafe(imgData, xPos, yPos, w, h) {
                xPos = Math.max(0, Math.min(w - 1, Math.round(xPos)));
                yPos = Math.max(0, Math.min(h - 1, Math.round(yPos)));
                const idx = (yPos * w + xPos) * 4;
                return [ imgData.data[idx], imgData.data[idx+1], imgData.data[idx+2], imgData.data[idx+3] ];
            }
            
            for (let yOut = 0; yOut < leftCtx.canvas.height; yOut++) {
                for (let xOut = 0; xOut < leftCtx.canvas.width; xOut++) {
                    const srcX = xOut / scaleX;
                    const srcY = yOut / scaleY;
                    
                    const depthMapIndex = Math.round(srcY) * width + Math.round(srcX);
                    const normalizedDepth = depthMap[depthMapIndex] || 0.5; // Should be 0 (far) to 1 (near)
                    
                    // Map normalizedDepth (0=far, 1=near) to displacement. 
                    // Near objects (depth=1) shift more. Far objects (depth=0) shift less or none.
                    const displacement = Math.round(normalizedDepth * actualMaxOffset);
                    
                    const outIdx = (yOut * leftCtx.canvas.width + xOut) * 4;
                    
                    // Left eye: near objects (positive displacement) shift source to their right
                    const leftSamplePixel = getPixelSafe(originalFrameImageData, srcX + displacement, srcY, width, height);
                    leftOutputImageData.data[outIdx]     = leftSamplePixel[0] * leftColor.r;
                    leftOutputImageData.data[outIdx + 1] = leftSamplePixel[1] * leftColor.g;
                    leftOutputImageData.data[outIdx + 2] = leftSamplePixel[2] * leftColor.b;
                    leftOutputImageData.data[outIdx + 3] = 255;
                    
                    // Right eye: near objects (positive displacement) shift source to their left
                    const rightSamplePixel = getPixelSafe(originalFrameImageData, srcX - displacement, srcY, width, height);
                    rightOutputImageData.data[outIdx]     = rightSamplePixel[0] * rightColor.r;
                    rightOutputImageData.data[outIdx + 1] = rightSamplePixel[1] * rightColor.g;
                    rightOutputImageData.data[outIdx + 2] = rightSamplePixel[2] * rightColor.b;
                    rightOutputImageData.data[outIdx + 3] = 255;
                }
            }
            
            leftCtx.putImageData(leftOutputImageData, 0, 0);
            rightCtx.putImageData(rightOutputImageData, 0, 0);
        }

        // Initialize the video element
        function initVideo() {
            video = document.createElement('video');
            video.setAttribute('playsinline', '');
            video.setAttribute('autoplay', '');
            video.setAttribute('muted', '');
            video.style.width = 'auto'; // Changed for aspect ratio
            video.style.height = '100%'; // Changed for aspect ratio
            video.style.display = 'none'; // Hide video element
            document.body.appendChild(video); // Append to body to allow playback
        }
        
        // Main render frame function
        function renderFrame() {
            if (video && video.readyState >= 2) { // video.HAVE_CURRENT_DATA
                const currentTime = performance.now();
                const elapsed = currentTime - lastFrameTime;
                
                if (elapsed >= frameInterval) {
                    lastFrameTime = currentTime - (elapsed % frameInterval);
                    
                    if (!isFrozen) {
                        const canvas1 = document.getElementById('canvas1');
                        const canvas2 = document.getElementById('canvas2');
                        
                        if (canvas1 && canvas2) {
                            const ctx1 = canvas1.getContext('2d');
                            const ctx2 = canvas2.getContext('2d');
                            
                            processingCtx.drawImage(video, 0, 0, processingCanvas.width, processingCanvas.height);
                            
                            const baselineSeparation = parseFloat(document.getElementById('baselineSeparation').value);
                            const depthIntensity = parseFloat(document.getElementById('depthIntensity').value);
                            const depthMode = document.getElementById('depthMode').value;
                            
                            const leftEyeColor = {
                                r: parseInt(document.getElementById('redSlider1').value) / 255,
                                g: parseInt(document.getElementById('greenSlider1').value) / 255,
                                b: parseInt(document.getElementById('blueSlider1').value) / 255
                            };
                            const rightEyeColor = {
                                r: parseInt(document.getElementById('redSlider2').value) / 255,
                                g: parseInt(document.getElementById('greenSlider2').value) / 255,
                                b: parseInt(document.getElementById('blueSlider2').value) / 255
                            };
                            
                            applyStereoEffect(processingCtx, ctx1, ctx2, leftEyeColor, rightEyeColor, 
                                baselineSeparation, depthIntensity, depthMode);
                            updateCanvasTransforms();
                        }
                    }
                    if (depthMapVisible) {
                        generateDepthMapFromCurrentFrame();
                    }
                }
            }
            requestAnimationFrame(renderFrame);
        }

        // Set up rendering dimensions
        function setupRendering() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            if (!canvas1 || !canvas2 || !video || !video.videoWidth || !video.videoHeight) return;

            const videoAspect = video.videoWidth / video.videoHeight;
            const container = document.querySelector('.container');
            let targetCanvasHeight = container.clientHeight * 0.9; // Use 90% of container height
            let targetCanvasWidth = targetCanvasHeight * videoAspect;

            // If calculated width exceeds container width (e.g. very wide video), scale by width instead
            if (targetCanvasWidth > container.clientWidth * 0.45) { // Each canvas takes up to 45%
                targetCanvasWidth = container.clientWidth * 0.45;
                targetCanvasHeight = targetCanvasWidth / videoAspect;
            }
            
            canvas1.width = canvas2.width = Math.round(targetCanvasWidth);
            canvas1.height = canvas2.height = Math.round(targetCanvasHeight);
            
            processingCanvas.width = Math.round(video.videoWidth * qualityFactor);
            processingCanvas.height = Math.round(video.videoHeight * qualityFactor);
            
            // Ensure flicker mode canvases are positioned correctly after size change
            if (flickerMode) {
                positionFlickerCanvases();
            }

            debugLog(`Canvases resized: ${canvas1.width}x${canvas1.height}. Processing at: ${processingCanvas.width}x${processingCanvas.height}`);
            requestAnimationFrame(renderFrame); // Start if not already running
        }
        
        // Start camera
        async function startCamera() {
            const startButton = document.getElementById('startButton');
            startButton.disabled = true;
            startButton.textContent = "Starting...";
            
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("Camera API not supported");
                }
                if (!video) initVideo();
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                detectedCameras.all = devices.filter(device => device.kind === 'videoinput');
                debugLog(`Found ${detectedCameras.all.length} camera(s)`);

                if (isMobile && detectedCameras.all.length > 1) {
                    detectedCameras.front = detectedCameras.all.find(c => c.label.toLowerCase().includes('front'))?.deviceId;
                    detectedCameras.back = detectedCameras.all.find(c => c.label.toLowerCase().includes('back') || c.label.toLowerCase().includes('rear'))?.deviceId;
                    if (!detectedCameras.front && !detectedCameras.back && detectedCameras.all.length >=2) { // Fallback
                         detectedCameras.front = detectedCameras.all[0].deviceId; // often front
                         detectedCameras.back = detectedCameras.all[1].deviceId; // often back
                    }
                }
                
                const preferredCameraId = useFrontCamera ? 
                    (detectedCameras.front || detectedCameras.all[0]?.deviceId) : 
                    (detectedCameras.back || detectedCameras.all[0]?.deviceId);
                detectedCameras.current = preferredCameraId;
                
                const constraints = {
                    video: {
                        deviceId: preferredCameraId ? { exact: preferredCameraId } : undefined,
                        width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 }
                    }, audio: false
                };
                
                if (currentStream) currentStream.getTracks().forEach(track => track.stop());
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;
                
                await new Promise(resolve => {
                    video.onloadedmetadata = () => video.play().then(resolve).catch(e => {debugLog(`Play error: ${e}`); resolve();});
                });
                
                startButton.textContent = "Camera Active";
                document.getElementById('switchButton').disabled = detectedCameras.all.length < 2;
                isFrozen = false; // Unfreeze when camera starts
                document.getElementById('canvas1').classList.remove('frozen-canvas');
                document.getElementById('canvas2').classList.remove('frozen-canvas');
                document.getElementById('freezeButton').textContent = "Freeze Frame";


                setupRendering(); // Setup rendering after video metadata is loaded
                initializeDepthMap(); // Also initialize depth map settings
                
            } catch (error) {
                debugLog(`Camera error: ${error.message}`);
                startButton.textContent = "Start Camera";
                startButton.disabled = false;
            }
        }
        
        // Switch camera
        async function switchCamera() {
            if (detectedCameras.all.length < 2) {
                debugLog("Not enough cameras to switch.");
                return;
            }
            useFrontCamera = !useFrontCamera;
            debugLog(`Switching to ${useFrontCamera ? 'front' : 'back'} camera.`);
            await startCamera(); // Restart camera with new preference
            document.getElementById('switchButton').textContent = useFrontCamera ? "Back Cam" : "Front Cam";
        }

        function positionFlickerCanvases() {
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            const container = document.querySelector('.container');
            if (!canvas1 || !canvas2 || !container) return;

            const canvasWidth = canvas1.width; // Assuming both are same width
            const containerWidth = container.clientWidth;
            
            // Center the canvases for flicker mode
            const commonLeft = (containerWidth - canvasWidth) / 2;

            if (flickerFrame === 0) { // canvas1 visible
                canvas1.style.left = `${commonLeft}px`;
                canvas1.style.visibility = 'visible';
                canvas2.style.visibility = 'hidden';
            } else { // canvas2 visible
                canvas2.style.left = `${commonLeft}px`;
                canvas2.style.visibility = 'visible';
                canvas1.style.visibility = 'hidden';
            }
        }
        
        // Toggle flicker mode
        function toggleFlickerMode() {
            flickerMode = !flickerMode;
            const container = document.querySelector('.container');
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            const flickerSpeedContainer = document.getElementById('flickerSpeedContainer');
            const flickerIndicator = document.getElementById('flickerIndicator');
            const toggleBtn = document.getElementById('toggleFlickerMode');

            if (flickerMode) {
                originalCanvasPositions.canvas1 = { left: canvas1.style.left, margin: canvas1.style.margin, transform: canvas1.style.transform, position: canvas1.style.position };
                originalCanvasPositions.canvas2 = { left: canvas2.style.left, margin: canvas2.style.margin, transform: canvas2.style.transform, position: canvas2.style.position };
                
                container.classList.add('flicker-active');
                canvas1.style.position = 'absolute'; // Ensure absolute for flicker
                canvas2.style.position = 'absolute';
                
                flickerSpeedContainer.style.display = 'flex';
                flickerIndicator.style.opacity = '1';
                toggleBtn.textContent = 'Disable 3D Flicker';
                startFlicker();
            } else {
                if (flickerInterval) clearInterval(flickerInterval);
                flickerInterval = null;
                
                container.classList.remove('flicker-active');
                canvas1.style.left = originalCanvasPositions.canvas1.left;
                canvas1.style.margin = originalCanvasPositions.canvas1.margin;
                canvas1.style.transform = originalCanvasPositions.canvas1.transform;
                canvas1.style.position = originalCanvasPositions.canvas1.position;
                canvas1.style.visibility = 'visible';


                canvas2.style.left = originalCanvasPositions.canvas2.left;
                canvas2.style.margin = originalCanvasPositions.canvas2.margin;
                canvas2.style.transform = originalCanvasPositions.canvas2.transform;
                canvas2.style.position = originalCanvasPositions.canvas2.position;
                canvas2.style.visibility = 'visible';
                
                flickerSpeedContainer.style.display = 'none';
                flickerIndicator.style.opacity = '0';
                toggleBtn.textContent = 'Enable 3D Flicker';
                setupRendering(); // Re-adjust non-flicker layout
            }
        }

        // Start flicker animation
        function startFlicker() {
            if (flickerInterval) clearInterval(flickerInterval);
            flickerSpeed = parseInt(document.getElementById('flickerSpeedSlider').value);
            
            flickerFrame = 0; // Start with canvas1
            positionFlickerCanvases(); // Initial positioning

            flickerInterval = setInterval(() => {
                flickerFrame = 1 - flickerFrame; // Toggle between 0 and 1
                positionFlickerCanvases();
            }, flickerSpeed);
        }
        
        // Toggle controls visibility
        function toggleControls() {
            controlsHidden = !controlsHidden;
            document.getElementById('controlPanel').style.display = controlsHidden ? 'none' : 'flex';
            document.getElementById('toggleControls').textContent = controlsHidden ? 'Show Controls' : 'Hide Controls';
        }
        
        // Handle quality selection
        function handleQualityChange() {
            qualityFactor = parseFloat(document.getElementById('qualitySelect').value);
            const qualityIndicator = document.getElementById('qualityIndicator');
            qualityIndicator.textContent = `Processing at ${(qualityFactor * 100)}% resolution`;
            qualityIndicator.style.opacity = 1;
            setTimeout(() => { qualityIndicator.style.opacity = 0; }, 3000);
            if (currentStream) setupRendering(); // Re-setup with new quality
        }
        
        // Initialize slider display updates
        function initSliderDisplays() {
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                const valueSpan = document.getElementById(slider.id + 'Value');
                if (valueSpan) {
                    const updateValue = () => {
                        let value = slider.value;
                        let suffix = slider.dataset.suffix || '';
                        let prefix = slider.dataset.prefix || '';
                        if (slider.id === 'haditTheta' || slider.id === 'haditPhi') suffix = '°';
                        else if (['focusFactor', 'bandSizeMultiplier', 'depthContrast'].includes(slider.id)) suffix = 'x';
                        else if (slider.id === 'baselineSeparation') suffix = '%';
                        else if (slider.id === 'sBounds') prefix = '±';
                        
                        valueSpan.textContent = prefix + parseFloat(value).toFixed(1) + suffix;
                    };
                    slider.addEventListener('input', updateValue);
                    updateValue(); 
                }
            });
        }
        
        // Freeze frame with countdown
        function freezeFrameWithDelay() {
            if (!document.getElementById('freezeDelayToggle').checked) {
                freezeFrame(); return;
            }
            const countdownDisplay = document.getElementById('freezeCountdown');
            const countdownValueEl = document.getElementById('countdownValue');
            countdownDisplay.style.display = 'block';
            let count = 3;
            countdownValueEl.textContent = count;
            const interval = setInterval(() => {
                count--;
                countdownValueEl.textContent = count;
                if (count <= 0) {
                    clearInterval(interval);
                    countdownDisplay.style.display = 'none';
                    freezeFrame();
                }
            }, 1000);
        }
        
        // Freeze frame logic
        function freezeFrame() {
            isFrozen = !isFrozen;
            document.getElementById('freezeButton').textContent = isFrozen ? "Unfreeze" : "Freeze Frame";
            document.getElementById('canvas1').classList.toggle('frozen-canvas', isFrozen);
            document.getElementById('canvas2').classList.toggle('frozen-canvas', isFrozen);
            if (depthMapVisible && isFrozen) generateDepthMapFromCurrentFrame(); // Update depth map on freeze
        }
        
        // Initialize depth map display functionality
        function initializeDepthMap() {
            // Set Hadit UI elements to default values from haditConfig
            document.getElementById('haditTheta').value = haditConfig.haditTheta;
            document.getElementById('haditPhi').value = haditConfig.haditPhi;
            document.getElementById('haditInfluence').value = haditConfig.haditInfluence;
            document.getElementById('focusFactor').value = haditConfig.focusFactor;
            document.getElementById('bandSizeMultiplier').value = haditConfig.bandSizeMultiplier;
            document.getElementById('bandMode').value = haditConfig.bandMode;
            document.getElementById('luminosityWeight').value = haditConfig.luminosityWeight;
            document.getElementById('saturationWeight').value = haditConfig.saturationWeight;
            document.getElementById('depthContrast').value = haditConfig.depthContrast;
            document.getElementById('sBounds').value = haditConfig.sBounds;

            initSliderDisplays(); // Update all span values after setting defaults

            document.getElementById('haditIndicator').textContent = `Hadit: φ=${haditConfig.haditPhi.toFixed(1)}° θ=${haditConfig.haditTheta.toFixed(1)}° Focus=${haditConfig.focusFactor.toFixed(1)}x`;
            
            document.getElementById('toggleDepthMap').addEventListener('click', function() {
                depthMapVisible = !depthMapVisible;
                document.getElementById('depthMapDisplay').style.display = depthMapVisible ? 'block' : 'none';
                this.classList.toggle('active', depthMapVisible);
                if (depthMapVisible && video && video.readyState >=2) generateDepthMapFromCurrentFrame();
                document.getElementById('depthMapLabel').textContent = depthMapVisible ? "Hadit Depth Map (Active)" : "Hadit Depth Map";
            });
        }
        
        // Recording functionality (simplified)
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = 0;
        let recordingTimerInterval = null;

        function startRecording() {
            if (!currentStream || !document.getElementById('canvas1').captureStream) {
                alert("Recording requires an active camera and browser support for canvas.captureStream().");
                return;
            }
            const canvas1 = document.getElementById('canvas1');
            const stream = canvas1.captureStream(30); // 30 FPS
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            recordedChunks = [];
            mediaRecorder.ondataavailable = event => { if (event.data.size > 0) recordedChunks.push(event.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none'; a.href = url; a.download = `androidvr-${new Date().toISOString()}.webm`;
                document.body.appendChild(a); a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
                stopRecordingUI();
            };
            mediaRecorder.start(1000);
            recordingStartTime = Date.now();
            document.getElementById('recordButton').style.display = 'none';
            document.getElementById('stopRecordButton').style.display = 'flex';
            document.getElementById('recordingIndicator').style.display = 'flex';
            recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        }

        function updateRecordingTimer() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('recordingTimer').textContent = `${minutes}:${seconds}`;
        }

        function stopRecordingUI() {
            if (recordingTimerInterval) clearInterval(recordingTimerInterval);
            recordingTimerInterval = null;
            document.getElementById('recordButton').style.display = 'flex';
            document.getElementById('stopRecordButton').style.display = 'none';
            document.getElementById('recordingIndicator').style.display = 'none';
        }
        
        // DOMContentLoaded setup
        document.addEventListener('DOMContentLoaded', () => {
            debugLog("DOM Loaded. Initializing AndroidVR...");
            debugLog(`Initial Hadit Config: θ=${haditConfig.haditTheta}, φ=${haditConfig.haditPhi}, Focus=${haditConfig.focusFactor}x, BandSizeX=${haditConfig.bandSizeMultiplier}, Contrast=${haditConfig.depthContrast}`);

            initializeDepthMap(); // This will set UI from haditConfig and then initSliderDisplays

            document.getElementById('startButton').addEventListener('click', startCamera);
            document.getElementById('switchButton').addEventListener('click', switchCamera);
            document.getElementById('toggleControls').addEventListener('click', toggleControls);
            document.getElementById('toggleFlickerMode').addEventListener('click', toggleFlickerMode);
            document.getElementById('flickerSpeedSlider').addEventListener('input', () => {
                if (flickerMode) startFlicker(); // Restart flicker with new speed
            });
            document.getElementById('qualitySelect').addEventListener('change', handleQualityChange);
            document.getElementById('freezeButton').addEventListener('click', freezeFrameWithDelay);
            document.getElementById('recordButton').addEventListener('click', startRecording);
            document.getElementById('stopRecordButton').addEventListener('click', stopRecording);

            // Add event listeners for all Hadit and S-Coord sliders to update global haditConfig and indicator
            const haditControlIds = ['haditTheta', 'haditPhi', 'haditInfluence', 'focusFactor', 'bandSizeMultiplier', 'luminosityWeight', 'saturationWeight', 'depthContrast', 'sBounds', 'bandMode'];
            haditControlIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => {
                        haditConfig = getHaditConfigFromUI(); // Update global config from UI
                        document.getElementById('haditIndicator').textContent = `Hadit: φ=${haditConfig.haditPhi.toFixed(1)}° θ=${haditConfig.haditTheta.toFixed(1)}° Focus=${haditConfig.focusFactor.toFixed(1)}x`;
                        // No automatic re-render on slider input unless realTimeUpdate is checked (handled in renderFrame)
                    });
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (currentStream) { // Only resize if camera is active
                    setupRendering();
                }
            });

            console.log("AndroidVR initialized with Hadit depth settings:");
            console.log(`- Phi: ${haditConfig.haditPhi.toFixed(1)}°, Theta: ${haditConfig.haditTheta.toFixed(1)}°`);
            console.log(`- Focus: ${haditConfig.focusFactor.toFixed(1)}x, Band Multiplier: ${haditConfig.bandSizeMultiplier.toFixed(1)}x`);
            console.log(`- Luminosity: ${haditConfig.luminosityWeight}, Saturation: ${haditConfig.saturationWeight}`);
            console.log(`- S Bounds: ${haditConfig.sBounds}, Depth Contrast: ${haditConfig.depthContrast}`);
            console.log(`- Band Mode: ${haditConfig.bandMode}`);
            console.log("Current Date and Time (UTC): 2025-06-07 04:53:34");
            console.log("Current User Login: Angledcrystals");
        });
    </script>
</body>
</html>
