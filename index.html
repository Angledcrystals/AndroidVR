<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AndroidVR - Live Hadit Camera</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 5px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-bottom: 15px;
        }

        .camera-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stereo-view {
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .camera-feed {
            position: relative;
        }

        canvas, video {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            max-width: 100%;
            height: auto;
        }

        .left-eye { border-color: #ff4444 !important; }
        .right-eye { border-color: #4444ff !important; }
        .depth-map { border-color: #ff8800 !important; }
        .raw-video { border-color: #00ff88 !important; }

        .camera-label {
            text-align: center;
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .left-label { color: #ff4444; }
        .right-label { color: #4444ff; }
        .depth-label { color: #ff8800; }
        .raw-label { color: #00ff88; }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #00ff88;
            margin-bottom: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 3px;
            font-size: 10px;
            width: 60px;
        }

        select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            cursor: pointer;
            font-size: 10px;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .camera-control {
            background: rgba(0, 255, 136, 0.2) !important;
            border-color: #00ff88 !important;
        }

        .hadit-control {
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: #ff00ff !important;
        }

        .stereo-control {
            background: rgba(255, 68, 136, 0.2) !important;
            border-color: #ff4488 !important;
        }

        .depth-control {
            background: rgba(255, 136, 0, 0.2) !important;
            border-color: #ff8800 !important;
        }

        .dual-input {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dual-input input[type="range"] {
            flex: 1;
            margin-bottom: 0;
        }

        .dual-input input[type="number"] {
            flex: 0 0 auto;
        }

        .info-panel {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .hadit-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .analysis-panel {
            background: rgba(136, 255, 0, 0.1);
            border: 1px solid #88ff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .processing {
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5) !important;
            animation: processing 1s ease-in-out infinite;
        }

        @keyframes processing {
            0% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.3); }
        }

        .fps-counter {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
        }

        .camera-status {
            text-align: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .status-connecting { color: #ffff00; }
        .status-active { color: #00ff88; }
        .status-error { color: #ff4444; }

        .error-message {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #ff4444;
        }

        /* Debug video (visible) */
        #debugVideo {
            max-width: 200px;
            border: 1px solid #ffff00;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .stereo-view {
                flex-direction: column;
                align-items: center;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            
            canvas {
                max-width: 90vw;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AndroidVR - Live Hadit Camera</h1>
        <div class="subtitle">Real-time Fine Hadit Control: 0.1¬∞ Precision | 2025-06-07 07:21:07 UTC | User: Angledcrystals</div>

        <div class="hadit-info">
            <div style="color: #ff00ff; font-weight: bold;">‚ö° Live Hadit Processing:</div>
            <div>‚Ä¢ Real-time camera feed with Hadit depth generation</div>
            <div>‚Ä¢ Œ∏ (Theta): 0¬∞ to 360¬∞ in 0.1¬∞ increments for live adjustment</div>
            <div>‚Ä¢ œÜ (Phi): 0.1¬∞ to 179.9¬∞ in 0.1¬∞ increments for extreme precision</div>
            <div>‚Ä¢ Parallel stereo view with pixel-perfect offset based on Hadit depth</div>
            <div>‚Ä¢ Enhanced debugging for camera feed issues</div>
        </div>

        <div class="camera-status" id="cameraStatus">
            <span class="status-connecting">üìπ Camera system ready - click Start Camera</span>
        </div>

        <div id="errorPanel" class="error-message" style="display: none;">
            <div style="font-weight: bold;">‚ùå Camera Error:</div>
            <div id="errorMessage">Unknown error occurred</div>
            <div style="margin-top: 5px; font-size: 10px;">
                ‚Ä¢ Make sure you allow camera permissions<br>
                ‚Ä¢ Try switching between front/back camera<br>
                ‚Ä¢ Check if another app is using the camera<br>
                ‚Ä¢ Refresh the page and try again
            </div>
        </div>

        <!-- Debug video element (visible for troubleshooting) -->
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="font-size: 11px; color: #ffff00; margin-bottom: 5px;">üîç DEBUG: Raw Camera Feed</div>
            <video id="debugVideo" autoplay playsinline muted class="raw-video" style="display: none;"></video>
        </div>

        <div class="camera-container">
            <div class="stereo-view">
                <div class="camera-feed">
                    <div class="camera-label left-label">Left Eye (Red)</div>
                    <canvas id="leftCanvas" width="640" height="480" class="left-eye"></canvas>
                    <div class="fps-counter" id="leftFps">0 FPS</div>
                </div>
                <div class="camera-feed">
                    <div class="camera-label right-label">Right Eye (Blue)</div>
                    <canvas id="rightCanvas" width="640" height="480" class="right-eye"></canvas>
                    <div class="fps-counter" id="rightFps">0 FPS</div>
                </div>
                <div class="camera-feed">
                    <div class="camera-label depth-label">Hadit Depth</div>
                    <canvas id="depthCanvas" width="320" height="240" class="depth-map"></canvas>
                    <div class="fps-counter" id="depthFps">0 FPS</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>üìπ Camera Control</label>
                <button id="startCamera" class="camera-control">‚ñ∂Ô∏è Start Camera</button>
                <button id="switchCamera" class="camera-control" style="display: none;">üîÑ Switch Camera</button>
                <button id="stopCamera" class="camera-control" style="display: none;">‚èπÔ∏è Stop Camera</button>
                <button id="requestPermissions" class="camera-control">üîë Request Permissions</button>
                <button id="toggleDebugVideo" class="camera-control">üëÅÔ∏è Toggle Debug Video</button>
            </div>
            
            <div class="control-group">
                <label>üìê Camera Settings</label>
                <select id="resolutionSelect" class="camera-control">
                    <option value="320x240">320x240 (Low)</option>
                    <option value="640x480" selected>640x480 (VGA)</option>
                    <option value="1280x720">1280x720 (HD)</option>
                    <option value="1920x1080">1920x1080 (FHD)</option>
                </select>
                <select id="facingMode" class="camera-control">
                    <option value="environment" selected>Back Camera</option>
                    <option value="user">Front Camera</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit Œ∏ (Theta): <span id="haditThetaValue">45.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditTheta" min="0" max="360" value="45" step="0.1" class="hadit-control">
                    <input type="number" id="haditThetaNumber" min="0" max="360" step="0.1" value="45" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>‚ö° Hadit œÜ (Phi): <span id="haditPhiValue">60.0¬∞</span></label>
                <div class="dual-input">
                    <input type="range" id="haditPhi" min="0.1" max="179.9" value="60" step="0.1" class="hadit-control">
                    <input type="number" id="haditPhiNumber" min="0.1" max="179.9" step="0.1" value="60" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>üåä Hadit Influence: <span id="haditInfluenceValue">1.0</span></label>
                <input type="range" id="haditInfluence" min="0" max="2" value="1.0" step="0.1" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üéØ Focus Factor: <span id="focusFactorValue">2.0x</span></label>
                <input type="range" id="focusFactor" min="1.0" max="5.0" step="0.1" value="2.0" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üëÅÔ∏è Stereo Separation: <span id="separationValue">8px</span></label>
                <input type="range" id="separation" min="0" max="50" value="8" step="1" class="stereo-control">
            </div>
            
            <div class="control-group">
                <label>üó∫Ô∏è Depth Intensity: <span id="depthIntensityValue">1.5x</span></label>
                <input type="range" id="depthIntensity" min="0.1" max="5.0" value="1.5" step="0.1" class="depth-control">
            </div>
            
            <div class="control-group">
                <label>üìê S Bounds: <span id="sBoundsValue">¬±10.0</span></label>
                <input type="range" id="sBounds" min="1.0" max="20.0" step="0.1" value="10.0" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>üí° Luminosity Weight: <span id="luminosityWeightValue">0.7</span></label>
                <input type="range" id="luminosityWeight" min="0" max="1" step="0.05" value="0.7">
            </div>
            
            <div class="control-group">
                <label>üåà Saturation Weight: <span id="saturationWeightValue">0.3</span></label>
                <input type="range" id="saturationWeight" min="0" max="1" step="0.05" value="0.3">
            </div>
            
            <div class="control-group">
                <label>‚öôÔ∏è Processing Quality</label>
                <select id="qualitySelect" class="depth-control">
                    <option value="1.0">Full Quality</option>
                    <option value="0.75" selected>High Quality</option>
                    <option value="0.5">Medium Quality</option>
                    <option value="0.25">Low Quality</option>
                </select>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <div>Status: Live Hadit camera system ready... Angledcrystals | 2025-06-07 07:21:07 UTC</div>
        </div>

        <div class="analysis-grid">
            <div>
                <div class="control-group">
                    <label>Quick Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHaditPole" class="hadit-control">œÜ=0.1¬∞ (Pole)</button>
                        <button id="setHaditEquator" class="hadit-control">œÜ=90¬∞ (Equator)</button>
                        <button id="setHaditNear180" class="hadit-control">œÜ=179.9¬∞ (Anti-pole)</button>
                        <button id="animateTheta" class="hadit-control">üåÄ Animate Œ∏</button>
                        <button id="animatePhi" class="hadit-control">üåä Animate œÜ</button>
                        <button id="stopAnimation" class="hadit-control">‚èπÔ∏è Stop All</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Options & Debug</label>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label><input type="checkbox" id="enableStereo" checked> Enable Stereo</label>
                        <label><input type="checkbox" id="showDepthMap" checked> Show Depth</label>
                        <label><input type="checkbox" id="mirrorCamera"> Mirror Camera</label>
                        <label><input type="checkbox" id="showFPS" checked> Show FPS</label>
                        <label><input type="checkbox" id="debugMode" checked> Debug Mode</label>
                        <label><input type="checkbox" id="showRawFeed"> Show Raw Feed</label>
                    </div>
                </div>
            </div>
            
            <div class="analysis-panel" id="analysisPanel">
                <div style="color: #88ff00; font-weight: bold;">‚ö° Live Hadit Analysis</div>
                <div>Ready for live camera processing...</div>
                <div>Camera permissions status: checking...</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== HADIT MATHEMATICS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        function sphericalToCartesian(theta, phi) {
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function calculateHaditModulatedSCoordinate(px, py, width, height, lum, sat, config) {
            const gTheta = (px / width) * 360;
            const gPhi = (py / height) * 180;
            const G_3d = sphericalToCartesian(gTheta, gPhi);
            
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            const S_hadit = stereographicProjection(G_reflected);
            
            const contentModulation = (1 + lum * config.luminosityWeight + sat * config.saturationWeight);
            
            return {
                x: S_hadit.x * contentModulation * config.haditInfluence,
                y: S_hadit.y * contentModulation * config.haditInfluence
            };
        }

        // ==================== ENHANCED CAMERA SYSTEM WITH DEBUGGING ====================
        
        class LiveHaditCamera {
            constructor() {
                this.video = null;
                this.debugVideo = null;
                this.stream = null;
                this.isRunning = false;
                this.animationFrameId = null;
                this.animationId = null;
                this.availableCameras = [];
                this.currentCameraIndex = 0;
                
                // Performance tracking
                this.frameCount = 0;
                this.lastFpsTime = 0;
                this.currentFps = 0;
                
                // Processing canvases
                this.processingCanvas = document.createElement('canvas');
                this.processingCtx = this.processingCanvas.getContext('2d');
                
                this.initializeControls();
                this.setupCanvases();
                this.setupDebugVideo();
                this.checkCameraPermissions();
                this.updateInfoPanel('Live Hadit camera system ready! | Angledcrystals | 2025-06-07 07:21:07 UTC');
                
                console.log('‚úÖ Live Hadit Camera System initialized!');
                console.log('üêõ Debug mode enabled - raw video feed available');
                console.log('Œ∏ (Theta) range: 0¬∞ to 360¬∞ in 0.1¬∞ increments');
                console.log('œÜ (Phi) range: 0.1¬∞ to 179.9¬∞ in 0.1¬∞ increments');
            }

            setupDebugVideo() {
                this.debugVideo = document.getElementById('debugVideo');
                if (this.debugVideo) {
                    this.debugVideo.autoplay = true;
                    this.debugVideo.playsInline = true;
                    this.debugVideo.muted = true;
                }
            }

            async checkCameraPermissions() {
                try {
                    const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                    this.updateAnalysisInfo(`Camera permission: ${permissionStatus.state}`);
                    
                    if (permissionStatus.state === 'granted') {
                        await this.enumerateCameras();
                    } else if (permissionStatus.state === 'prompt') {
                        this.updateAnalysisInfo('Camera permission: will prompt when starting');
                    } else {
                        this.showError('Camera permission denied. Please enable camera access.');
                    }
                    
                    permissionStatus.addEventListener('change', () => {
                        this.updateAnalysisInfo(`Camera permission changed: ${permissionStatus.state}`);
                    });
                    
                } catch (error) {
                    console.log('Permission query not supported, will try direct access');
                    this.updateAnalysisInfo('Camera permission: checking on start');
                }
            }

            async enumerateCameras() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.availableCameras = devices.filter(device => device.kind === 'videoinput');
                    
                    this.updateAnalysisInfo(`Found ${this.availableCameras.length} camera(s)`);
                    
                    this.availableCameras.forEach((camera, index) => {
                        console.log(`Camera ${index}: ${camera.label || 'Unknown'}`);
                    });
                    
                } catch (error) {
                    console.error('Camera enumeration error:', error);
                    this.updateAnalysisInfo('Camera enumeration failed');
                }
            }

            setupCanvases() {
                this.leftCanvas = document.getElementById('leftCanvas');
                this.rightCanvas = document.getElementById('rightCanvas');
                this.depthCanvas = document.getElementById('depthCanvas');
                
                this.leftCtx = this.leftCanvas.getContext('2d');
                this.rightCtx = this.rightCanvas.getContext('2d');
                this.depthCtx = this.depthCanvas.getContext('2d');
            }

            getConfiguration() {
                return {
                    haditTheta: parseFloat(document.getElementById('haditTheta')?.value || 45),
                    haditPhi: parseFloat(document.getElementById('haditPhi')?.value || 60),
                    haditInfluence: parseFloat(document.getElementById('haditInfluence')?.value || 1.0),
                    focusFactor: parseFloat(document.getElementById('focusFactor')?.value || 2.0),
                    separation: parseFloat(document.getElementById('separation')?.value || 8),
                    depthIntensity: parseFloat(document.getElementById('depthIntensity')?.value || 1.5),
                    sBounds: parseFloat(document.getElementById('sBounds')?.value || 10.0),
                    luminosityWeight: parseFloat(document.getElementById('luminosityWeight')?.value || 0.7),
                    saturationWeight: parseFloat(document.getElementById('saturationWeight')?.value || 0.3),
                    quality: parseFloat(document.getElementById('qualitySelect')?.value || 0.75),
                    enableStereo: document.getElementById('enableStereo')?.checked ?? true,
                    showDepthMap: document.getElementById('showDepthMap')?.checked ?? true,
                    mirrorCamera: document.getElementById('mirrorCamera')?.checked ?? false,
                    showFPS: document.getElementById('showFPS')?.checked ?? true,
                    debugMode: document.getElementById('debugMode')?.checked ?? false,
                    showRawFeed: document.getElementById('showRawFeed')?.checked ?? false
                };
            }

            async requestPermissions() {
                try {
                    this.updateCameraStatus('üìπ Requesting camera permissions...', 'connecting');
                    
                    // Request basic camera access to trigger permission prompt
                    const testStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: 320, height: 240 } 
                    });
                    
                    // Stop the test stream immediately
                    testStream.getTracks().forEach(track => track.stop());
                    
                    this.updateCameraStatus('‚úÖ Camera permissions granted', 'active');
                    await this.enumerateCameras();
                    
                } catch (error) {
                    this.showError('Failed to get camera permissions: ' + error.message);
                    this.updateCameraStatus('‚ùå Camera permissions denied', 'error');
                }
            }

            async startCamera() {
                try {
                    this.hideError();
                    this.updateCameraStatus('üìπ Starting camera...', 'connecting');
                    
                    const resolution = document.getElementById('resolutionSelect').value.split('x');
                    const width = parseInt(resolution[0]);
                    const height = parseInt(resolution[1]);
                    const facingMode = document.getElementById('facingMode').value;
                    
                    // Simplified constraints for better compatibility
                    const constraints = {
                        video: {
                            width: { ideal: width, min: 320 },
                            height: { ideal: height, min: 240 },
                            frameRate: { ideal: 30, min: 15 }
                        }
                    };

                    // Add facing mode or device ID
                    if (this.availableCameras.length > 0) {
                        const camera = this.availableCameras[this.currentCameraIndex];
                        if (camera && camera.deviceId) {
                            constraints.video.deviceId = { exact: camera.deviceId };
                        }
                    } else {
                        constraints.video.facingMode = { ideal: facingMode };
                    }

                    console.log('üé• Camera constraints:', constraints);

                    // Stop any existing stream
                    if (this.stream) {
                        this.stream.getTracks().forEach(track => track.stop());
                    }

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('‚úÖ Camera stream obtained');
                    
                    // Setup both video elements
                    if (!this.video) {
                        this.video = document.createElement('video');
                        this.video.autoplay = true;
                        this.video.playsInline = true;
                        this.video.muted = true;
                        this.video.style.display = 'none';
                        document.body.appendChild(this.video);
}
                    }
                    
                    this.video.srcObject = this.stream;
                    this.debugVideo.srcObject = this.stream;
                    
                    // Wait for video to be ready
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Video load timeout'));
                        }, 10000);
                        
                        const handleLoad = () => {
                            clearTimeout(timeout);
                            console.log(`üì∫ Video ready: ${this.video.videoWidth}x${this.video.videoHeight}`);
                            resolve();
                        };
                        
                        this.video.addEventListener('loadedmetadata', handleLoad, { once: true });
                        this.video.addEventListener('error', (e) => {
                            clearTimeout(timeout);
                            reject(new Error('Video load error: ' + e.message));
                        }, { once: true });
                    });
                    
                    this.isRunning = true;
                    this.updateCameraStatus('üìπ Camera active - Live Hadit processing', 'active');
                    this.updateInfoPanel(`Camera started: ${this.video.videoWidth}x${this.video.videoHeight} | Live Hadit processing active`);
                    
                    this.startProcessingLoop();
                    
                    document.getElementById('startCamera').style.display = 'none';
                    document.getElementById('switchCamera').style.display = 'inline-block';
                    document.getElementById('stopCamera').style.display = 'inline-block';
                    
                } catch (error) {
                    console.error('üö´ Camera start error:', error);
                    this.showError('Camera start failed: ' + error.message);
                    this.updateCameraStatus('‚ùå Camera start failed', 'error');
                    
                    // Show suggestions based on error type
                    if (error.name === 'NotAllowedError') {
                        this.showError('Camera permission denied. Please allow camera access and try again.');
                    } else if (error.name === 'NotFoundError') {
                        this.showError('No camera found. Please connect a camera and try again.');
                    } else if (error.name === 'NotReadableError') {
                        this.showError('Camera is busy. Close other apps using the camera and try again.');
                    } else {
                        this.showError('Camera error: ' + error.message);
                    }
                }
            }

            stopCamera() {
                this.isRunning = false;
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                if (this.video) {
                    this.video.srcObject = null;
                }
                
                if (this.debugVideo) {
                    this.debugVideo.srcObject = null;
                }
                
                this.updateCameraStatus('üìπ Camera stopped', 'connecting');
                this.updateInfoPanel('Camera stopped. Click Start Camera to resume live Hadit processing.');
                
                document.getElementById('startCamera').style.display = 'inline-block';
                document.getElementById('switchCamera').style.display = 'none';
                document.getElementById('stopCamera').style.display = 'none';
                
                // Clear canvases
                [this.leftCtx, this.rightCtx, this.depthCtx].forEach(ctx => {
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                });
            }

            async switchCamera() {
                if (this.availableCameras.length > 1) {
                    this.currentCameraIndex = (this.currentCameraIndex + 1) % this.availableCameras.length;
                    this.updateInfoPanel(`Switching to camera ${this.currentCameraIndex + 1}/${this.availableCameras.length}...`);
                    await this.startCamera();
                } else {
                    // Fallback: toggle facing mode
                    const facingModeSelect = document.getElementById('facingMode');
                    facingModeSelect.value = facingModeSelect.value === 'user' ? 'environment' : 'user';
                    this.updateInfoPanel(`Switching to ${facingModeSelect.value} camera...`);
                    await this.startCamera();
                }
            }

            toggleDebugVideo() {
                const debugVideo = document.getElementById('debugVideo');
                const showRawFeed = document.getElementById('showRawFeed');
                
                if (debugVideo.style.display === 'none') {
                    debugVideo.style.display = 'block';
                    showRawFeed.checked = true;
                    this.updateInfoPanel('Debug video enabled - you should see the raw camera feed above.');
                } else {
                    debugVideo.style.display = 'none';
                    showRawFeed.checked = false;
                    this.updateInfoPanel('Debug video hidden.');
                }
            }

            startProcessingLoop() {
                const targetFPS = 30;
                const targetInterval = 1000 / targetFPS;
                let lastTime = 0;
                
                console.log('üîÑ Starting processing loop...');
                
                const processFrame = (currentTime) => {
                    if (!this.isRunning) {
                        console.log('‚èπÔ∏è Processing loop stopped');
                        return;
                    }
                    
                    if (currentTime - lastTime >= targetInterval) {
                        this.processVideoFrame();
                        lastTime = currentTime;
                        
                        // Update FPS
                        this.frameCount++;
                        if (currentTime - this.lastFpsTime >= 1000) {
                            this.currentFps = this.frameCount;
                            this.frameCount = 0;
                            this.lastFpsTime = currentTime;
                            this.updateFpsDisplay();
                        }
                    }
                    
                    this.animationFrameId = requestAnimationFrame(processFrame);
                };
                
                this.animationFrameId = requestAnimationFrame(processFrame);
            }

            processVideoFrame() {
                if (!this.video || this.video.readyState < this.video.HAVE_CURRENT_DATA) {
                    console.log('‚ö†Ô∏è Video not ready yet...');
                    return;
                }
                
                const config = this.getConfiguration();
                const startTime = performance.now();
                
                try {
                    // Setup processing canvas with quality scaling
                    const sourceWidth = this.video.videoWidth;
                    const sourceHeight = this.video.videoHeight;
                    const processWidth = Math.floor(sourceWidth * config.quality);
                    const processHeight = Math.floor(sourceHeight * config.quality);
                    
                    this.processingCanvas.width = processWidth;
                    this.processingCanvas.height = processHeight;
                    
                    // Draw video frame to processing canvas
                    this.processingCtx.save();
                    if (config.mirrorCamera) {
                        this.processingCtx.scale(-1, 1);
                        this.processingCtx.translate(-processWidth, 0);
                    }
                    
                    // üîß KEY FIX: Ensure we're drawing the video properly
                    this.processingCtx.clearRect(0, 0, processWidth, processHeight);
                    this.processingCtx.drawImage(this.video, 0, 0, processWidth, processHeight);
                    this.processingCtx.restore();
                    
                    // Get image data for processing
                    const imageData = this.processingCtx.getImageData(0, 0, processWidth, processHeight);
                    
                    // Check if we actually got data
                    if (imageData.data.length === 0) {
                        console.warn('‚ö†Ô∏è No image data received');
                        return;
                    }
                    
                    // Generate Hadit depth map and stereo views
                    this.generateHaditStereoViews(imageData, config);
                    
                    const processingTime = performance.now() - startTime;
                    
                    if (config.debugMode) {
                        this.updateAnalysisPanel(processingTime, config);
                    }
                    
                } catch (error) {
                    console.error('üö´ Frame processing error:', error);
                    this.updateInfoPanel('Frame processing error: ' + error.message);
                }
            }

            generateHaditStereoViews(imageData, config) {
                const { width, height, data } = imageData;
                
                // Check if we have valid data
                if (width === 0 || height === 0 || data.length === 0) {
                    console.warn('‚ö†Ô∏è Invalid image data for processing');
                    return;
                }
                
                // Setup output canvases
                this.leftCanvas.width = width;
                this.leftCanvas.height = height;
                this.rightCanvas.width = width;
                this.rightCanvas.height = height;
                this.depthCanvas.width = width;
                this.depthCanvas.height = height;
                
                // Create output image data
                const leftImageData = this.leftCtx.createImageData(width, height);
                const rightImageData = this.rightCtx.createImageData(width, height);
                const depthImageData = this.depthCtx.createImageData(width, height);
                
                const leftData = leftImageData.data;
                const rightData = rightImageData.data;
                const depthData = depthImageData.data;
                
                let totalDepth = 0;
                let pixelCount = 0;
                let minDepth = 1;
                let maxDepth = 0;
                
                // Process each pixel
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Get pixel color
                        const r = data[idx] / 255;
                        const g = data[idx + 1] / 255;
                        const b = data[idx + 2] / 255;
                        
                        // Calculate luminosity and saturation
                        const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                        const maxCol = Math.max(r, g, b);
                        const minCol = Math.min(r, g, b);
                        const sat = maxCol > 0 ? (maxCol - minCol) / maxCol : 0;
                        
                        // Calculate Hadit-modulated S-coordinate
                        const sCoord = calculateHaditModulatedSCoordinate(x, y, width, height, lum, sat, config);
                        const sMagnitude = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                        
                        // Calculate depth based on Hadit S-magnitude
                        const normalizedDepth = Math.min(sMagnitude / (config.sBounds * 2), 1.0);
                        let depth = 0.2 + (normalizedDepth * 0.8);
                        
                        // Apply focus factor
                        depth = 0.5 + (depth - 0.5) * config.focusFactor;
                        
                        // Apply content modulation
                        const contentWeight = lum * 0.5 + sat * 0.3;
                        depth *= (1 + contentWeight * 0.3);
                        
                        // Clamp depth
                        depth = Math.max(0.05, Math.min(1.0, depth));
                        
                        // Update statistics
                        totalDepth += depth;
                        pixelCount++;
                        minDepth = Math.min(minDepth, depth);
                        maxDepth = Math.max(maxDepth, depth);
                        
                        // Calculate stereo displacement
                        const normalizedDepthDisplacement = (depth - 0.5) * 2;
                        const displacement = Math.round(normalizedDepthDisplacement * config.separation * config.depthIntensity);
                        
                        // Original pixel values
                        const originalR = data[idx];
                        const originalG = data[idx + 1];
                        const originalB = data[idx + 2];
                        
                        if (config.enableStereo) {
                            // Left eye: sample from right-shifted position
                            const leftSampleX = Math.max(0, Math.min(width - 1, x + displacement));
                            const leftSampleIdx = (y * width + leftSampleX) * 4;
                            
                            leftData[idx] = data[leftSampleIdx];
                            leftData[idx + 1] = data[leftSampleIdx + 1];
                            leftData[idx + 2] = data[leftSampleIdx + 2];
                            leftData[idx + 3] = 255;
                            
                            // Right eye: sample from left-shifted position
                            const rightSampleX = Math.max(0, Math.min(width - 1, x - displacement));
                            const rightSampleIdx = (y * width + rightSampleX) * 4;
                            
                            rightData[idx] = data[rightSampleIdx];
                            rightData[idx + 1] = data[rightSampleIdx + 1];
                            rightData[idx + 2] = data[rightSampleIdx + 2];
                            rightData[idx + 3] = 255;
                        } else {
                            // No stereo - copy original
                            leftData[idx] = originalR;
                            leftData[idx + 1] = originalG;
                            leftData[idx + 2] = originalB;
                            leftData[idx + 3] = 255;
                            
                            rightData[idx] = originalR;
                            rightData[idx + 1] = originalG;
                            rightData[idx + 2] = originalB;
                            rightData[idx + 3] = 255;
                        }
                        
                        // Depth visualization
                        if (config.showDepthMap) {
                            const depthGray = Math.round(depth * 255);
                            depthData[idx] = depthGray;
                            depthData[idx + 1] = depthGray;
                            depthData[idx + 2] = depthGray;
                            depthData[idx + 3] = 255;
                        } else {
                            depthData[idx] = originalR;
                            depthData[idx + 1] = originalG;
                            depthData[idx + 2] = originalB;
                            depthData[idx + 3] = 255;
                        }
                    }
                }
                
                // Draw processed images
                this.leftCtx.putImageData(leftImageData, 0, 0);
                this.rightCtx.putImageData(rightImageData, 0, 0);
                this.depthCtx.putImageData(depthImageData, 0, 0);
                
                // Store stats for analysis
                this.lastProcessingStats = {
                    avgDepth: totalDepth / pixelCount,
                    minDepth,
                    maxDepth,
                    pixelCount,
                    depthRange: maxDepth - minDepth
                };
            }

            showError(message) {
                const errorPanel = document.getElementById('errorPanel');
                const errorMessage = document.getElementById('errorMessage');
                if (errorPanel && errorMessage) {
                    errorMessage.textContent = message;
                    errorPanel.style.display = 'block';
                }
            }

            hideError() {
                const errorPanel = document.getElementById('errorPanel');
                if (errorPanel) {
                    errorPanel.style.display = 'none';
                }
            }

            updateCameraStatus(message, status) {
                const statusElement = document.getElementById('cameraStatus');
                if (statusElement) {
                    statusElement.innerHTML = `<span class="status-${status}">${message}</span>`;
                }
            }

            updateFpsDisplay() {
                const config = this.getConfiguration();
                if (config.showFPS) {
                    document.getElementById('leftFps').textContent = `${this.currentFps} FPS`;
                    document.getElementById('rightFps').textContent = `${this.currentFps} FPS`;
                    document.getElementById('depthFps').textContent = `${this.currentFps} FPS`;
                } else {
                    document.getElementById('leftFps').textContent = '';
                    document.getElementById('rightFps').textContent = '';
                    document.getElementById('depthFps').textContent = '';
                }
            }

            updateAnalysisPanel(processingTime, config) {
                if (this.lastProcessingStats) {
                    const stats = this.lastProcessingStats;
                    this.updateAnalysisInfo(`
FPS: ${this.currentFps} | Process: ${processingTime.toFixed(1)}ms
Video: ${this.video ? this.video.videoWidth + 'x' + this.video.videoHeight : 'N/A'}
Ready State: ${this.video ? this.video.readyState : 'N/A'}
Œ∏ (Theta): ${config.haditTheta.toFixed(1)}¬∞
œÜ (Phi): ${config.haditPhi.toFixed(1)}¬∞
Influence: ${config.haditInfluence.toFixed(2)}
Focus Factor: ${config.focusFactor.toFixed(1)}x
Separation: ${config.separation}px
Depth Intensity: ${config.depthIntensity.toFixed(1)}x
S Bounds: ¬±${config.sBounds.toFixed(1)}
Quality: ${(config.quality * 100).toFixed(0)}%
Avg Depth: ${stats.avgDepth.toFixed(3)}
Depth Range: ${stats.depthRange.toFixed(3)}
Cameras: ${this.availableCameras.length}
Stream Active: ${this.stream ? 'Yes' : 'No'}
                    `.trim());
                }
            }

            updateAnalysisInfo(text) {
                const analysisPanel = document.getElementById('analysisPanel');
                if (analysisPanel) {
                    analysisPanel.innerHTML = `
                        <div style="color: #88ff00; font-weight: bold;">‚ö° Live Hadit Analysis</div>
                        <div style="white-space: pre-line; font-family: monospace; font-size: 9px;">${text}</div>
                    `;
                }
            }

            updateInfoPanel(message) {
                const infoPanel = document.getElementById('infoPanel');
                if (infoPanel) {
                    const timestamp = new Date().toLocaleTimeString();
                    infoPanel.innerHTML = `<div>${timestamp}: ${message}</div>`;
                }
            }

            initializeControls() {
                // Camera controls
                document.getElementById('startCamera')?.addEventListener('click', () => {
                    this.startCamera();
                });
                
                document.getElementById('stopCamera')?.addEventListener('click', () => {
                    this.stopCamera();
                });
                
                document.getElementById('switchCamera')?.addEventListener('click', () => {
                    this.switchCamera();
                });

                document.getElementById('requestPermissions')?.addEventListener('click', () => {
                    this.requestPermissions();
                });

                document.getElementById('toggleDebugVideo')?.addEventListener('click', () => {
                    this.toggleDebugVideo();
                });

                // Show raw feed checkbox
                document.getElementById('showRawFeed')?.addEventListener('change', (e) => {
                    const debugVideo = document.getElementById('debugVideo');
                    debugVideo.style.display = e.target.checked ? 'block' : 'none';
                });

                // Synchronized dual inputs for theta
                const thetaSlider = document.getElementById('haditTheta');
                const thetaNumber = document.getElementById('haditThetaNumber');
                
                thetaSlider?.addEventListener('input', () => {
                    thetaNumber.value = thetaSlider.value;
                    this.updateControlValues();
                });
                
                thetaNumber?.addEventListener('input', () => {
                    const value = Math.max(0, Math.min(360, parseFloat(thetaNumber.value) || 0));
                    thetaSlider.value = value;
                    thetaNumber.value = value;
                    this.updateControlValues();
                });

                // Synchronized dual inputs for phi
                const phiSlider = document.getElementById('haditPhi');
                const phiNumber = document.getElementById('haditPhiNumber');
                
                phiSlider?.addEventListener('input', () => {
                    phiNumber.value = phiSlider.value;
                    this.updateControlValues();
                });
                
                phiNumber?.addEventListener('input', () => {
                    const value = Math.max(0.1, Math.min(179.9, parseFloat(phiNumber.value) || 0.1));
                    phiSlider.value = value;
                    phiNumber.value = value;
                    this.updateControlValues();
                });

                // Preset buttons
                document.getElementById('setHaditPole')?.addEventListener('click', () => {
                    phiSlider.value = 0.1;
                    phiNumber.value = 0.1;
                    this.updateControlValues();
                    this.updateInfoPanel('Set œÜ to 0.1¬∞ (near pole) - extreme Hadit geometry!');
                });

                document.getElementById('setHaditEquator')?.addEventListener('click', () => {
                    phiSlider.value = 90.0;
                    phiNumber.value = 90.0;
                    this.updateControlValues();
                    this.updateInfoPanel('Set œÜ to 90¬∞ (equator) - balanced Hadit geometry.');
                });

                document.getElementById('setHaditNear180')?.addEventListener('click', () => {
                    phiSlider.value = 179.9;
                    phiNumber.value = 179.9;
                    this.updateControlValues();
                    this.updateInfoPanel('Set œÜ to 179.9¬∞ (near anti-pole) - inverted Hadit geometry!');
                });

                // Animation controls
                document.getElementById('animateTheta')?.addEventListener('click', () => {
                    this.startThetaAnimation();
                });

                document.getElementById('animatePhi')?.addEventListener('click', () => {
                    this.startPhiAnimation();
                });

                document.getElementById('stopAnimation')?.addEventListener('click', () => {
                    this.stopAllAnimations();
                });

                // Other controls
                const controls = [
                    'haditInfluence', 'focusFactor', 'separation', 'depthIntensity',
                    'sBounds', 'luminosityWeight', 'saturationWeight'
                ];
                
                controls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => {
                            this.updateControlValues();
                        });
                    }
                });

                this.updateControlValues();
            }

            updateControlValues() {
                const controls = [
                    { id: 'haditTheta', suffix: '¬∞', precision: 1 },
                    { id: 'haditPhi', suffix: '¬∞', precision: 1 },
                    { id: 'haditInfluence', suffix: '', precision: 1 },
                    { id: 'focusFactor', suffix: 'x', precision: 1 },
                    { id: 'separation', suffix: 'px' },
                    { id: 'depthIntensity', suffix: 'x', precision: 1 },
                    { id: 'sBounds', suffix: '', prefix: '¬±', precision: 1 },
                    { id: 'luminosityWeight', suffix: '', precision: 2 },
                    { id: 'saturationWeight', suffix: '', precision: 2 }
                ];

                controls.forEach(({ id, suffix, prefix, precision }) => {
                    const element = document.getElementById(id);
                    const valueElement = document.getElementById(id + 'Value');
                    if (element && valueElement) {
                        const prefixText = prefix || '';
                        const value = precision ? parseFloat(element.value).toFixed(precision) : element.value;
                        valueElement.textContent = prefixText + value + suffix;
                    }
                });
            }

            startThetaAnimation() {
                this.stopAllAnimations();
                this.updateInfoPanel('Started Œ∏ animation - 0.1¬∞ precision live updates!');
                
                let animationTime = 0;
                const animate = () => {
                    animationTime += 0.5; // 0.5 degree steps for smooth animation
                    const newTheta = (animationTime % 360);
                    
                    document.getElementById('haditTheta').value = newTheta.toFixed(1);
                    document.getElementById('haditThetaNumber').value = newTheta.toFixed(1);
                    this.updateControlValues();
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                this.animationId = requestAnimationFrame(animate);
            }

            startPhiAnimation() {
                this.stopAllAnimations();
                this.updateInfoPanel('Started œÜ animation - 0.1¬∞ precision through full range!');
                
                let animationTime = 0;
                const animate = () => {
                    animationTime += 0.02; // Slower animation for phi
                    const newPhi = 0.1 + (Math.sin(animationTime) * 0.5 + 0.5) * (179.9 - 0.1);
                    
                    document.getElementById('haditPhi').value = newPhi.toFixed(1);
                    document.getElementById('haditPhiNumber').value = newPhi.toFixed(1);
                    this.updateControlValues();
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                this.animationId = requestAnimationFrame(animate);
            }

            stopAllAnimations() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                    this.updateInfoPanel('All animations stopped. Manual control restored.');
                }
            }
        }

        // ==================== INITIALIZATION ====================
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('‚ö° Initializing Live Hadit Camera System...');
            console.log('Current Date and Time (UTC): 2025-06-07 07:21:07');
            console.log('Current User Login: Angledcrystals');
            console.log('üêõ Enhanced debugging enabled');
            
            try {
                window.haditCamera = new LiveHaditCamera();
                console.log('‚úÖ Live Hadit Camera system ready!');
                console.log('üìπ Click "Start Camera" to begin live processing');
                console.log('üëÅÔ∏è Click "Toggle Debug Video" to see raw camera feed');
            } catch (error) {
                console.error('‚ùå Initialization failed:', error);
            }
        });

    </script>
</body>
</html>
