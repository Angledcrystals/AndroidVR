<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AndroidVR - Asymmetric S-Coordinate Stereogram</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 5px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-bottom: 15px;
        }

        .camera-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .stereo-view {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 95vw;
            box-sizing: border-box;
        }

        .depth-view {
            display: flex;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 600px;
        }

        .camera-feed {
            position: relative;
            overflow: hidden;
        }

        .stereo-frame {
            flex: 1;
            max-width: calc(50% - 10px);
            min-width: 300px;
            width: 100%;
        }

        .stereo-frame canvas {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            display: block;
        }

        .depth-frame {
            width: 100%;
            max-width: 400px;
        }

        .depth-frame canvas {
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            max-height: 40vh;
            object-fit: contain;
            display: block;
        }

        canvas, video {
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: #000;
            box-sizing: border-box;
        }

        .left-eye { border-color: #ff4444 !important; }
        .right-eye { border-color: #4444ff !important; }
        .depth-map { border-color: #ff8800 !important; }
        .raw-video { border-color: #00ff88 !important; }

        .camera-label {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .left-label { color: #ff4444; }
        .right-label { color: #4444ff; }
        .depth-label { color: #ff8800; }
        .raw-label { color: #00ff88; }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #00ff88;
            margin-bottom: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 3px;
            font-size: 10px;
            width: 60px;
        }

        select, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #fff;
            padding: 5px;
            cursor: pointer;
            font-size: 10px;
        }

        button:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .camera-control {
            background: rgba(0, 255, 136, 0.2) !important;
            border-color: #00ff88 !important;
        }

        .hadit-control {
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: #ff00ff !important;
        }

        .stereo-control {
            background: rgba(255, 68, 136, 0.2) !important;
            border-color: #ff4488 !important;
        }

        .depth-control {
            background: rgba(255, 136, 0, 0.2) !important;
            border-color: #ff8800 !important;
        }

        .color-control {
            background: rgba(136, 255, 0, 0.2) !important;
            border-color: #88ff00 !important;
        }

        .projection-control {
            background: rgba(0, 255, 255, 0.2) !important;
            border-color: #00ffff !important;
        }

        .asymmetry-control {
            background: rgba(255, 165, 0, 0.2) !important;
            border-color: #ffa500 !important;
        }

        .dual-input {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dual-input input[type="range"] {
            flex: 1;
            margin-bottom: 0;
        }

        .dual-input input[type="number"] {
            flex: 0 0 auto;
        }

        .info-panel {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .hadit-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .asymmetry-info {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid #ffa500;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .analysis-panel {
            background: rgba(136, 255, 0, 0.1);
            border: 1px solid #88ff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .fps-counter {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
        }

        .camera-status {
            text-align: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .status-connecting { color: #ffff00; }
        .status-active { color: #00ff88; }
        .status-error { color: #ff4444; }

        .error-message {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #ff4444;
        }

        .separation-notice {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ffff00;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 11px;
            text-align: center;
        }

        .fixed-notice {
            background: rgba(255, 165, 0, 0.2);
            border: 2px solid #ffa500;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            text-align: center;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 10px #ffa500; }
            50% { box-shadow: 0 0 20px #ffa500; }
            100% { box-shadow: 0 0 10px #ffa500; }
        }

        #debugVideo {
            max-width: 200px;
            border: 1px solid #ffff00;
        }

        @media (orientation: landscape) and (min-width: 768px) {
            .stereo-view { padding: 25px; gap: 20px; max-width: 98vw; }
            .stereo-frame { max-width: calc(50% - 15px); min-width: 350px; }
            .stereo-frame canvas { max-height: 75vh; }
            .depth-view { max-width: 500px; }
            .camera-label { font-size: 14px; margin-bottom: 10px; }
        }

        @media (max-width: 768px), (orientation: portrait) {
            .stereo-view { flex-direction: column; align-items: center; gap: 15px; max-width: 95vw; }
            .stereo-frame { min-width: 280px; max-width: 90vw; width: 100%; }
            .stereo-frame canvas { max-height: 50vh; }
            .depth-view { max-width: 90vw; }
            .controls { grid-template-columns: 1fr; }
            .analysis-grid { grid-template-columns: 1fr; }
        }

        canvas { max-width: 100% !important; height: auto !important; object-fit: contain; }
    </style>
</head>
<body>
    <div class="container">
        <h1>AndroidVR - Asymmetric S-Coordinate Stereogram</h1>
        <div class="subtitle">FIXED: Bilateral Symmetry with Asymmetric Controls | 2025-06-08 11:50:07 UTC | User: Angledcrystals</div>

        <div class="fixed-notice">
            <div style="color: #ffa500; font-weight: bold; font-size: 18px;">🔧 FIXED: BILATERAL SYMMETRY ISSUE</div>
            <div>SOLVED: No more middle division - asymmetric transformation controls added</div>
            <div>NEW: Rotation, offset, and perturbation controls break Householder reflection symmetry</div>
            <div>ENHANCED: Multiple asymmetry modes for varied S-coordinate patterns</div>
            <div>RESULT: Full-image transformations without bilateral division</div>
        </div>

        <div class="asymmetry-info">
            <div style="color: #ffa500; font-weight: bold;">🌪️ Asymmetry Breaking System:</div>
            <div>• <strong>Coordinate Rotation</strong>: Rotates input coordinates before Hadit transformation</div>
            <div>• <strong>Spatial Offset</strong>: Shifts coordinate origin to break central symmetry</div>
            <div>• <strong>Perturbation</strong>: Adds controlled noise to eliminate perfect reflection</div>
            <div>• <strong>Spiral Mode</strong>: Creates spiral coordinate mapping for organic patterns</div>
            <div>• <strong>Wave Distortion</strong>: Applies sinusoidal distortion to coordinate space</div>
            <div>• All modes preserve Hadit mathematics while breaking bilateral symmetry</div>
        </div>

        <div class="separation-notice">
            <div style="color: #ffff00; font-weight: bold;">⚡ COMPLETE SEPARATION OF CONCERNS</div>
            <div>H-Band: ONLY used for brightness-based color leveling (when enabled)</div>
            <div>S-Coordinates: Applied to EVERY pixel globally - NO band restrictions</div>
        </div>

        <div class="hadit-info">
            <div style="color: #ff00ff; font-weight: bold;">🌍 Asymmetric S-Coordinate System:</div>
            <div>• S-coordinates calculated for EVERY PIXEL across entire image</div>
            <div>• NO H-band logic interfering with S-coordinate calculations</div>
            <div>• Asymmetry controls break Householder reflection symmetry</div>
            <div>• Multiple coordinate transformation modes available</div>
            <div>• θ (Theta): Changes global S-coordinate pattern direction</div>
            <div>• φ (Phi): Affects global S-coordinate magnitude and distribution</div>
            <div>• Rotation/Offset: Breaks bilateral symmetry for varied patterns</div>
        </div>

        <div class="camera-status" id="cameraStatus">
            <span class="status-connecting">📹 Camera system ready - click Start Camera</span>
        </div>

        <div id="errorPanel" class="error-message" style="display: none;">
            <div style="font-weight: bold;">❌ Camera Error:</div>
            <div id="errorMessage">Unknown error occurred</div>
        </div>

        <!-- Debug video element -->
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="font-size: 11px; color: #ffff00; margin-bottom: 5px;">🔍 DEBUG: Raw Camera Feed</div>
            <video id="debugVideo" autoplay playsinline muted class="raw-video" style="display: none;"></video>
        </div>

        <div class="camera-container">
            <!-- Stereo frames -->
            <div class="stereo-view">
                <div class="camera-feed stereo-frame">
                    <div class="camera-label left-label">Left Eye - Asymmetric S-Disparity</div>
                    <canvas id="leftCanvas" width="640" height="480" class="left-eye"></canvas>
                    <div class="fps-counter" id="leftFps">0 FPS</div>
                </div>
                <div class="camera-feed stereo-frame">
                    <div class="camera-label right-label">Right Eye - Asymmetric S-Disparity</div>
                    <canvas id="rightCanvas" width="640" height="480" class="right-eye"></canvas>
                    <div class="fps-counter" id="rightFps">0 FPS</div>
                </div>
            </div>
            
            <!-- Pure S-coordinate map -->
            <div class="depth-view">
                <div class="camera-feed depth-frame">
                    <div class="camera-label depth-label">Asymmetric S-Coordinate Map</div>
                    <canvas id="depthCanvas" width="320" height="240" class="depth-map"></canvas>
                    <div class="fps-counter" id="depthFps">0 FPS</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>📹 Camera Control</label>
                <button id="startCamera" class="camera-control">▶️ Start Camera</button>
                <button id="switchCamera" class="camera-control" style="display: none;">🔄 Switch Camera</button>
                <button id="stopCamera" class="camera-control" style="display: none;">⏹️ Stop Camera</button>
                <button id="requestPermissions" class="camera-control">🔑 Request Permissions</button>
                <button id="toggleDebugVideo" class="camera-control">👁️ Toggle Debug Video</button>
            </div>

            <div class="control-group">
                <label>🌪️ Asymmetry Mode</label>
                <select id="asymmetryMode" class="asymmetry-control">
                    <option value="rotation" selected>🔄 Coordinate Rotation</option>
                    <option value="offset">📍 Spatial Offset</option>
                    <option value="perturbation">🌀 Perturbation</option>
                    <option value="spiral">🌪️ Spiral Mapping</option>
                    <option value="wave">〜 Wave Distortion</option>
                    <option value="none">❌ None (Symmetric)</option>
                </select>
            </div>

            <div class="control-group">
                <label>🔄 Rotation Angle: <span id="rotationAngleValue">30.0°</span></label>
                <input type="range" id="rotationAngle" min="0" max="360" step="1" value="30" class="asymmetry-control">
            </div>

            <div class="control-group">
                <label>📍 Spatial Offset: <span id="spatialOffsetValue">0.2</span></label>
                <input type="range" id="spatialOffset" min="0" max="1" step="0.05" value="0.2" class="asymmetry-control">
            </div>

            <div class="control-group">
                <label>🌀 Perturbation: <span id="perturbationValue">0.1</span></label>
                <input type="range" id="perturbation" min="0" max="0.5" step="0.01" value="0.1" class="asymmetry-control">
            </div>

            <div class="control-group">
                <label>🗺️ Coordinate Mapping</label>
                <select id="coordinateMapping" class="projection-control">
                    <option value="normalized_cartesian" selected>📏 Normalized Cartesian</option>
                    <option value="spherical_equirect">🌍 Spherical Equirectangular</option>
                    <option value="spherical_mercator">🗺️ Spherical Mercator</option>
                    <option value="direct_pixel">📐 Direct Pixel Mapping</option>
                </select>
            </div>

            <div class="control-group">
                <label>🌐 Projection Mode</label>
                <select id="projectionMode" class="projection-control">
                    <option value="stereographic">📐 Stereographic</option>
                    <option value="linear" selected>📏 Linear</option>
                    <option value="equirectangular">🌍 Equirectangular</option>
                    <option value="hybrid">🔄 Hybrid</option>
                </select>
            </div>

            <div class="control-group">
                <label>🎛️ Flatten Factor: <span id="flattenFactorValue">0.8</span></label>
                <input type="range" id="flattenFactor" min="0" max="1" step="0.05" value="0.8" class="projection-control">
            </div>

            <div class="control-group">
                <label>📏 S-Coordinate Bounds: <span id="sBoundsValue">20.0</span></label>
                <input type="range" id="sBounds" min="1" max="50" step="0.5" value="20.0" class="projection-control">
            </div>

            <div class="control-group">
                <label>🔧 Depth Source</label>
                <select id="depthSource" class="depth-control">
                    <option value="pure_s_coords" selected>📐 Pure S-Coordinates</option>
                    <option value="brightness_leveled">💡 Brightness + S-Coords</option>
                    <option value="radial_distance">📍 Radial Distance</option>
                    <option value="linear_gradient">📏 Linear Gradient</option>
                </select>
            </div>

            <div class="control-group">
                <label>📏 S-Coordinate Disparity: <span id="sDisparityValue">30.0px</span></label>
                <input type="range" id="sDisparity" min="0" max="100" step="1" value="30" class="stereo-control">
            </div>

            <div class="control-group">
                <label>🎯 S-Coordinate Scale: <span id="sScaleValue">2.5x</span></label>
                <input type="range" id="sScale" min="0.1" max="10.0" step="0.1" value="2.5" class="stereo-control">
            </div>

            <div class="control-group">
                <label>🌈 Color Leveling: <span id="colorLevelingValue">0.3x</span></label>
                <input type="range" id="colorLeveling" min="0" max="1" step="0.05" value="0.3" class="color-control">
            </div>
            
            <div class="control-group">
                <label>⚡ Hadit θ (Theta): <span id="haditThetaValue">45.0°</span></label>
                <div class="dual-input">
                    <input type="range" id="haditTheta" min="0" max="360" value="45.0" step="0.1" class="hadit-control">
                    <input type="number" id="haditThetaNumber" min="0" max="360" step="0.1" value="45.0" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>⚡ Hadit φ (Phi): <span id="haditPhiValue">90.0°</span></label>
                <div class="dual-input">
                    <input type="range" id="haditPhi" min="0.1" max="179.9" value="90.0" step="0.1" class="hadit-control">
                    <input type="number" id="haditPhiNumber" min="0.1" max="179.9" step="0.1" value="90.0" class="hadit-control">
                </div>
            </div>
            
            <div class="control-group">
                <label>🌊 Hadit Influence: <span id="haditInfluenceValue">2.0</span></label>
                <input type="range" id="haditInfluence" min="0" max="5" value="2.0" step="0.1" class="hadit-control">
            </div>
            
            <div class="control-group">
                <label>👁️ Base Separation: <span id="separationValue">10px</span></label>
                <input type="range" id="separation" min="0" max="20" value="10" step="1" class="stereo-control">
            </div>
            
            <div class="control-group">
                <label>📐 Camera Settings</label>
                <select id="resolutionSelect" class="camera-control">
                    <option value="320x240">320x240 (Low)</option>
                    <option value="640x480" selected>640x480 (VGA)</option>
                    <option value="1280x720">1280x720 (HD)</option>
                    <option value="1920x1080">1920x1080 (FHD)</option>
                </select>
                <select id="facingMode" class="camera-control">
                    <option value="environment" selected>Back Camera</option>
                    <option value="user">Front Camera</option>
                </select>
            </div>

            <div class="control-group">
                <label>⚙️ Processing Quality</label>
                <select id="qualitySelect" class="depth-control">
                    <option value="1.0">Full Quality</option>
                    <option value="0.75" selected>High Quality</option>
                    <option value="0.5">Medium Quality</option>
                    <option value="0.25">Low Quality</option>
                </select>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <div>Status: Asymmetric S-Coordinate system ready with bilateral symmetry breaking... Angledcrystals | 2025-06-08 11:50:07 UTC</div>
        </div>

        <div class="analysis-grid">
            <div>
                <div class="control-group">
                    <label>Asymmetry Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setAsymRotation" class="asymmetry-control">🔄 Rotation Mode</button>
                        <button id="setAsymOffset" class="asymmetry-control">📍 Offset Mode</button>
                        <button id="setAsymSpiral" class="asymmetry-control">🌪️ Spiral Mode</button>
                        <button id="setAsymWave" class="asymmetry-control">〜 Wave Mode</button>
                        <button id="setAsymNone" class="asymmetry-control">❌ Symmetric</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Coordinate Mapping Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setMappingUniform" class="projection-control">📏 Uniform</button>
                        <button id="setMappingEquirect" class="projection-control">🌍 Equirectangular</button>
                        <button id="setMappingMercator" class="projection-control">🗺️ Mercator</button>
                        <button id="setMappingDirect" class="projection-control">📐 Direct Pixel</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Quick Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setHaditPole" class="hadit-control">φ=0.1° (Pole)</button>
                        <button id="setHaditEquator" class="hadit-control">φ=90° (Equator)</button>
                        <button id="setHaditNear180" class="hadit-control">φ=179.9° (Anti-pole)</button>
                        <button id="animateTheta" class="hadit-control">🌀 Animate θ</button>
                        <button id="animatePhi" class="hadit-control">🌊 Animate φ</button>
                        <button id="stopAnimation" class="hadit-control">⏹️ Stop All</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>S-Coordinate Presets</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button id="setExtremeS" class="stereo-control">💥 Extreme S-Disparity</button>
                        <button id="setDeepS" class="stereo-control">🏔️ Deep S-Disparity</button>
                        <button id="setSubtleS" class="stereo-control">🌫️ Subtle S-Disparity</button>
                        <button id="setNoS" class="stereo-control">⭕ No S-Disparity</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Options & Debug</label>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <label><input type="checkbox" id="enableStereo" checked> Enable Stereo</label>
                        <label><input type="checkbox" id="showSCoordMap" checked> Show S-Coord Map</label>
                        <label><input type="checkbox" id="showVisualIndicators" checked> Show Indicators</label>
                        <label><input type="checkbox" id="mirrorCamera"> Mirror Camera</label>
                        <label><input type="checkbox" id="showFPS" checked> Show FPS</label>
                        <label><input type="checkbox" id="debugMode" checked> Debug Mode</label>
                        <label><input type="checkbox" id="showRawFeed"> Show Raw Feed</label>
                        <label><input type="checkbox" id="invertParallax"> Invert Parallax</label>
                    </div>
                </div>
            </div>
            
            <div class="analysis-panel" id="analysisPanel">
                <div style="color: #88ff00; font-weight: bold;">📐 Asymmetric S-Coordinate Analysis</div>
                <div>Ready for asymmetric S-coordinate generation...</div>
                <div>Camera permissions status: checking...</div>
                <div>Asymmetry mode: rotation</div>
                <div>Coordinate mapping: normalized_cartesian</div>
                <div>Projection mode: linear</div>
                <div>Bilateral symmetry: BROKEN</div>
                <div>System ready for full-image transformations...</div>
            </div>
        </div>
    </div>

    <script>
        // Current Date and Time (UTC - YYYY-MM-DD HH:MM:SS formatted): 2025-06-08 11:50:07
        // Current User's Login: Angledcrystals

        // ==================== ASYMMETRIC S-COORDINATE MATHEMATICS ====================
        
        const vectorOps = {
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z,
            subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
            scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
            normalize: (v) => {
                const mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
                return mag > 1e-10 ? vectorOps.scale(v, 1 / mag) : { x: 0, y: 0, z: 1 };
            }
        };

        // ASYMMETRY BREAKING: Apply transformations before coordinate mapping
        function applyAsymmetricTransform(px, py, width, height, asymmetryMode, config) {
            const rotationAngle = parseFloat(document.getElementById('rotationAngle').value);
            const spatialOffset = parseFloat(document.getElementById('spatialOffset').value);
            const perturbation = parseFloat(document.getElementById('perturbation').value);
            
            // Normalize coordinates to [-1, 1] range
            let x = (px / width) * 2 - 1;
            let y = (py / height) * 2 - 1;
            
            switch (asymmetryMode) {
                case 'rotation':
                    // Apply coordinate rotation to break bilateral symmetry
                    const angle = rotationAngle * Math.PI / 180;
                    const cosA = Math.cos(angle);
                    const sinA = Math.sin(angle);
                    const rotX = x * cosA - y * sinA;
                    const rotY = x * sinA + y * cosA;
                    x = rotX;
                    y = rotY;
                    break;
                
                case 'offset':
                    // Apply spatial offset to shift coordinate origin
                    x += spatialOffset * Math.sin(y * Math.PI);
                    y += spatialOffset * Math.cos(x * Math.PI);
                    break;
                
                case 'perturbation':
                    // Add controlled noise to break perfect symmetry
                    const noise1 = (Math.sin(x * 17.0 + y * 13.0) + Math.sin(x * 23.0 + y * 19.0)) * 0.5;
                    const noise2 = (Math.cos(x * 11.0 + y * 29.0) + Math.cos(x * 31.0 + y * 7.0)) * 0.5;
                    x += noise1 * perturbation;
                    y += noise2 * perturbation;
                    break;
                
                case 'spiral':
                    // Create spiral coordinate mapping
                    const radius = Math.sqrt(x * x + y * y);
                    const theta = Math.atan2(y, x);
                    const spiralAngle = theta + radius * 2.0 * spatialOffset;
                    x = radius * Math.cos(spiralAngle);
                    y = radius * Math.sin(spiralAngle);
                    break;
                
                case 'wave':
                    // Apply sinusoidal wave distortion
                    const waveFreq = 3.0;
                    const waveAmp = spatialOffset * 0.5;
                    x += Math.sin(y * Math.PI * waveFreq) * waveAmp;
                    y += Math.cos(x * Math.PI * waveFreq) * waveAmp;
                    break;
                
                case 'none':
                default:
                    // No transformation - maintains bilateral symmetry
                    break;
            }
            
            // Convert back to pixel coordinates
            const transformedPx = (x + 1) * width * 0.5;
            const transformedPy = (y + 1) * height * 0.5;
            
            return { px: transformedPx, py: transformedPy };
        }

        // Coordinate mapping with asymmetric preprocessing
        function pixelToCoordinates(px, py, width, height, mappingMode = 'normalized_cartesian', asymmetryMode = 'none', config = {}) {
            // FIRST: Apply asymmetric transformation to break bilateral symmetry
            const transformed = applyAsymmetricTransform(px, py, width, height, asymmetryMode, config);
            const tPx = transformed.px;
            const tPy = transformed.py;
            
            // THEN: Apply coordinate mapping to transformed coordinates
            switch (mappingMode) {
                case 'normalized_cartesian':
                    return {
                        theta: ((tPx / width) - 0.5) * 360,
                        phi: ((tPy / height) - 0.5) * 180 + 90
                    };
                
                case 'spherical_equirect':
                    return {
                        theta: (tPx / width) * 360,
                        phi: (tPy / height) * 180
                    };
                
                case 'spherical_mercator':
                    const lat = ((tPy / height) - 0.5) * Math.PI;
                    const mercatorPhi = (Math.atan(Math.sinh(lat)) * 180 / Math.PI) + 90;
                    return {
                        theta: (tPx / width) * 360,
                        phi: Math.max(0.1, Math.min(179.9, mercatorPhi))
                    };
                
                case 'direct_pixel':
                    return {
                        theta: (tPx / width) * 180,
                        phi: (tPy / height) * 90 + 45
                    };
                
                default:
                    return { theta: 0, phi: 90 };
            }
        }

        function sphericalToCartesian(theta, phi) {
            const clampedPhi = Math.max(0.1, Math.min(179.9, phi));
            const thetaRad = theta * Math.PI / 180;
            const phiRad = clampedPhi * Math.PI / 180;
            
            return {
                x: Math.sin(phiRad) * Math.cos(thetaRad),
                y: Math.sin(phiRad) * Math.sin(thetaRad),
                z: Math.cos(phiRad)
            };
        }

        function householderReflection(G_3d, hadit_3d) {
            const haditUnit = vectorOps.normalize(hadit_3d);
            const dotProduct = vectorOps.dot(haditUnit, G_3d);
            return vectorOps.subtract(G_3d, vectorOps.scale(haditUnit, 2 * dotProduct));
        }

        // ==================== MULTIPLE PROJECTION METHODS ====================

        function stereographicProjection(G_reflected) {
            if (Math.abs(1 - G_reflected.z) < 1e-10) {
                return { x: 0, y: 0 };
            }
            return {
                x: G_reflected.x / (1 - G_reflected.z),
                y: G_reflected.y / (1 - G_reflected.z)
            };
        }

        function linearProjection(G_reflected, bounds = 20.0) {
            return {
                x: G_reflected.x * bounds,
                y: G_reflected.y * bounds
            };
        }

        function equirectangularProjection(G_reflected, bounds = 20.0) {
            const theta = Math.atan2(G_reflected.y, G_reflected.x);
            const phi = Math.acos(Math.max(-1, Math.min(1, G_reflected.z)));
            
            return {
                x: (theta / Math.PI) * bounds,
                y: ((phi - Math.PI/2) / (Math.PI/2)) * bounds
            };
        }

        function hybridProjection(G_reflected, flattenFactor = 0.5, bounds = 20.0) {
            const stereo = stereographicProjection(G_reflected);
            const linear = linearProjection(G_reflected, bounds);
            
            const stereoNormalized = {
                x: Math.tanh(stereo.x / bounds) * bounds,
                y: Math.tanh(stereo.y / bounds) * bounds
            };
            
            return {
                x: stereoNormalized.x * (1 - flattenFactor) + linear.x * flattenFactor,
                y: stereoNormalized.y * (1 - flattenFactor) + linear.y * flattenFactor
            };
        }

        // ENHANCED S-COORDINATE CALCULATION WITH ASYMMETRY BREAKING
        function calculateAsymmetricSCoordinate(px, py, width, height, config) {
            // Get asymmetry and coordinate mapping methods
            const asymmetryMode = document.getElementById('asymmetryMode').value;
            const mappingMode = document.getElementById('coordinateMapping').value;
            
            // Apply asymmetric coordinate mapping to break bilateral symmetry
            const coords = pixelToCoordinates(px, py, width, height, mappingMode, asymmetryMode, config);
            const G_3d = sphericalToCartesian(coords.theta, coords.phi);
            
            // Apply Hadit reflection - pure mathematical transformation
            const hadit_3d = sphericalToCartesian(config.haditTheta, config.haditPhi);
            const G_reflected = householderReflection(G_3d, hadit_3d);
            
            // Get S-coordinates using selected projection method
            let S_hadit;
            const projectionMode = document.getElementById('projectionMode').value;
            const flattenFactor = parseFloat(document.getElementById('flattenFactor').value);
            const sBounds = parseFloat(document.getElementById('sBounds').value);
            
            switch (projectionMode) {
                case 'linear':
                    S_hadit = linearProjection(G_reflected, sBounds);
                    break;
                case 'equirectangular':
                    S_hadit = equirectangularProjection(G_reflected, sBounds);
                    break;
                case 'hybrid':
                    S_hadit = hybridProjection(G_reflected, flattenFactor, sBounds);
                    break;
                case 'stereographic':
                default:
                    S_hadit = stereographicProjection(G_reflected);
                    S_hadit.x = Math.tanh(S_hadit.x / sBounds) * sBounds;
                    S_hadit.y = Math.tanh(S_hadit.y / sBounds) * sBounds;
                    break;
            }
            
            // Apply scaling factors
            return {
                x: S_hadit.x * config.haditInfluence * config.sScale,
                y: S_hadit.y * config.haditInfluence * config.sScale
            };
        }

        // SEPARATE COLOR LEVELING FUNCTION (uses H-band only for brightness leveling)
        function calculateColorLeveling(px, py, width, height, imageData, config) {
            const depthSource = document.getElementById('depthSource').value;
            const colorLeveling = parseFloat(document.getElementById('colorLeveling').value);
            
            // Get pixel color
            const pixelIndex = (py * width + px) * 4;
            const r = imageData.data[pixelIndex] / 255;
            const g = imageData.data[pixelIndex + 1] / 255;
            const b = imageData.data[pixelIndex + 2] / 255;
            
            // Calculate base luminosity
            const lum = 0.299 * r + 0.587 * g + 0.114 * b;
            let levelingFactor = 1.0;
            
            switch (depthSource) {
                case 'pure_s_coords':
                    levelingFactor = 1.0;
                    break;
                case 'brightness_leveled':
                    levelingFactor = 1.0 + (lum - 0.5) * colorLeveling;
                    break;
                case 'radial_distance':
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const distX = (px - centerX) / centerX;
                    const distY = (py - centerY) / centerY;
                    const radialDistance = Math.sqrt(distX * distX + distY * distY);
                    levelingFactor = 1.0 + radialDistance * colorLeveling;
                    break;
                case 'linear_gradient':
                    const gradientFactor = py / height;
                    levelingFactor = 1.0 + gradientFactor * colorLeveling;
                    break;
                default:
                    levelingFactor = 1.0;
            }
            
            return levelingFactor;
        }

        // ==================== BILINEAR SAMPLING ====================

        function sampleBilinear(imageData, x, y, width, height) {
            x = Math.max(0, Math.min(width - 1, x));
            y = Math.max(0, Math.min(height - 1, y));
            
            const x1 = Math.floor(x);
            const y1 = Math.floor(y);
            const x2 = Math.min(x1 + 1, width - 1);
            const y2 = Math.min(y1 + 1, height - 1);
            
            const fx = x - x1;
            const fy = y - y1;
            
            const getPixel = (px, py) => {
                const index = (py * width + px) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            };
            
            const p1 = getPixel(x1, y1);
            const p2 = getPixel(x2, y1);
            const p3 = getPixel(x1, y2);
            const p4 = getPixel(x2, y2);
            
            const r = (1-fx)*(1-fy)*p1.r + fx*(1-fy)*p2.r + (1-fx)*fy*p3.r + fx*fy*p4.r;
            const g = (1-fx)*(1-fy)*p1.g + fx*(1-fy)*p2.g + (1-fx)*fy*p3.g + fx*fy*p4.g;
            const b = (1-fx)*(1-fy)*p1.b + fx*(1-fy)*p2.b + (1-fx)*fy*p3.b + fx*fy*p4.b;
            const a = (1-fx)*(1-fy)*p1.a + fx*(1-fy)*p2.a + (1-fx)*fy*p3.a + fx*fy*p4.a;
            
            return { r: Math.round(r), g: Math.round(g), b: Math.round(b), a: Math.round(a) };
        }

        // ==================== ENHANCED STEREO GENERATION WITH ASYMMETRY ====================

        function renderAsymmetricSCoordinateStereogram(imageData, config) {
            const { width, height } = imageData;
            
            // Get canvas contexts
            const leftCtx = document.getElementById('leftCanvas').getContext('2d');
            const rightCtx = document.getElementById('rightCanvas').getContext('2d');
            
            // Create output image data for left and right views
            const leftImageData = new ImageData(width, height);
            const rightImageData = new ImageData(width, height);
            
            // Get control values
            const baseSeparation = parseInt(document.getElementById('separation').value);
            const sDisparity = parseFloat(document.getElementById('sDisparity').value);
            const invertParallax = document.getElementById('invertParallax').checked;
            
            // Track statistics for debugging
            let maxDisparity = 0;
            let minDisparity = Infinity;
            let totalDisparity = 0;
            let pixelCount = 0;
            let transformedPixels = 0;
            let asymmetricPixels = 0;
            
            // REVERSE MAPPING with ASYMMETRIC S-COORDINATE DISPARITY
            for (let destY = 0; destY < height; destY++) {
                for (let destX = 0; destX < width; destX++) {
                    const destIndex = (destY * width + destX) * 4;
                    
                    // Calculate ASYMMETRIC S-coordinates (breaks bilateral symmetry)
                    const sCoord = calculateAsymmetricSCoordinate(destX, destY, width, height, config);
                    
                    // Calculate color leveling factor
                    const colorFactor = calculateColorLeveling(destX, destY, width, height, imageData, config);
                    
                    // Calculate S-coordinate magnitude for disparity
                    const sMagnitude = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                    
                    // Apply color leveling to S-coordinate disparity
                    let disparity = sMagnitude * sDisparity * colorFactor;
                    
                    // Track statistics
                    if (disparity > 0.1) {
                        transformedPixels++;
                    }
                    
                    // Check for asymmetric transformation (non-zero disparity variation across image)
                    const centerX = width / 2;
                    const mirrorX = centerX + (centerX - destX);
                    if (mirrorX >= 0 && mirrorX < width) {
                        const mirrorSCoord = calculateAsymmetricSCoordinate(mirrorX, destY, width, height, config);
                        const mirrorMagnitude = Math.sqrt(mirrorSCoord.x * mirrorSCoord.x + mirrorSCoord.y * mirrorSCoord.y);
                        if (Math.abs(sMagnitude - mirrorMagnitude) > 0.1) {
                            asymmetricPixels++;
                        }
                    }
                    
                    maxDisparity = Math.max(maxDisparity, disparity);
                    minDisparity = Math.min(minDisparity, disparity);
                    totalDisparity += disparity;
                    pixelCount++;
                    
                    // Invert parallax if requested
                    if (invertParallax) {
                        disparity = -disparity;
                    }
                    
                    // Use the S-coordinate X component to determine direction
                    const disparityDirection = Math.sign(sCoord.x) || 1;
                    disparity *= disparityDirection;
                    
                    // Calculate horizontal offsets for stereogram
                    const leftSourceX = destX - (baseSeparation + disparity);
                    const leftSourceY = destY;
                    
                    const rightSourceX = destX + (baseSeparation + disparity);
                    const rightSourceY = destY;
                    
                    // Sample pixels with bilinear interpolation
                    const leftPixel = sampleBilinear(imageData, leftSourceX, leftSourceY, width, height);
                    const rightPixel = sampleBilinear(imageData, rightSourceX, rightSourceY, width, height);
                    
                    // Set left eye pixel
                    leftImageData.data[destIndex] = leftPixel.r;
                    leftImageData.data[destIndex + 1] = leftPixel.g;
                    leftImageData.data[destIndex + 2] = leftPixel.b;
                    leftImageData.data[destIndex + 3] = leftPixel.a;
                    
                    // Set right eye pixel
                    rightImageData.data[destIndex] = rightPixel.r;
                    rightImageData.data[destIndex + 1] = rightPixel.g;
                    rightImageData.data[destIndex + 2] = rightPixel.b;
                    rightImageData.data[destIndex + 3] = rightPixel.a;
                }
            }
            
            // Calculate statistics
            const avgDisparity = totalDisparity / pixelCount;
            const transformationCoverage = (transformedPixels / pixelCount * 100).toFixed(1);
            const asymmetryPercentage = (asymmetricPixels / pixelCount * 100).toFixed(1);
            
            // Output statistics for debugging
            console.log(`Asymmetric Distribution Stats:`);
            console.log(`- Transformation Coverage: ${transformationCoverage}% of pixels`);
            console.log(`- Asymmetry Coverage: ${asymmetryPercentage}% of pixels`);
            console.log(`- Disparity Range: ${minDisparity.toFixed(2)} - ${maxDisparity.toFixed(2)}`);
            console.log(`- Average Disparity: ${avgDisparity.toFixed(2)}`);
            
            // Add visual indicators if enabled
            if (document.getElementById('showVisualIndicators').checked) {
                addVisualIndicators(leftImageData, rightImageData, width, height);
            }
            
            // Render the final stereogram images
            leftCtx.putImageData(leftImageData, 0, 0);
            rightCtx.putImageData(rightImageData, 0, 0);
            
            // Update analysis panel
            updateAsymmetricDisparityInfo(maxDisparity, minDisparity, avgDisparity, transformationCoverage, asymmetryPercentage);
        }
        
        // Add visual indicators to verify left/right differences
        function addVisualIndicators(leftImageData, rightImageData, width, height) {
            // Add red tint to bottom-left corner of LEFT image
            for (let y = height - 20; y < height; y++) {
                for (let x = 0; x < 20; x++) {
                    const idx = (y * width + x) * 4;
                    leftImageData.data[idx] = Math.min(255, leftImageData.data[idx] + 50);
                }
            }
            
            // Add blue tint to bottom-right corner of RIGHT image
            for (let y = height - 20; y < height; y++) {
                for (let x = width - 20; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    rightImageData.data[idx + 2] = Math.min(255, rightImageData.data[idx + 2] + 50);
                }
            }
        }
        
        // Update analysis panel with enhanced asymmetric disparity info
        function updateAsymmetricDisparityInfo(maxDisparity, minDisparity, avgDisparity, coverage, asymmetry) {
            const analysisPanel = document.getElementById('analysisPanel');
            if (analysisPanel && document.getElementById('debugMode').checked) {
                const asymmetryMode = document.getElementById('asymmetryMode').value;
                const coordinateMapping = document.getElementById('coordinateMapping').value;
                const projectionMode = document.getElementById('projectionMode').value;
                
                // Clear previous disparity info
                const lines = analysisPanel.innerHTML.split('\n');
                const filteredLines = lines.filter(line => 
                    !line.includes('ASYMMETRIC') && 
                    !line.includes('Coverage') && 
                    !line.includes('Status') &&
                    !line.includes('Disparity Range') &&
                    !line.includes('Average Disparity') &&
                    !line.includes('Bilateral symmetry')
                );
                
                const disparityInfo = `
                    <div style="margin-top: 10px; color: #ffa500; font-weight: bold;">
                        🌪️ ASYMMETRIC DISTRIBUTION ACTIVE
                    </div>
                    <div>Asymmetry Mode: ${asymmetryMode.toUpperCase()}</div>
                    <div>Coordinate Mapping: ${coordinateMapping.replace('_', ' ').toUpperCase()}</div>
                    <div>Projection: ${projectionMode.toUpperCase()}</div>
                    <div>Transformation Coverage: ${coverage}% of pixels</div>
                    <div>Asymmetry Coverage: ${asymmetry}% of pixels</div>
                    <div>Disparity Range: ${minDisparity.toFixed(1)} - ${maxDisparity.toFixed(1)}px</div>
                    <div>Average Disparity: ${avgDisparity.toFixed(2)}px</div>
                    <div>Bilateral symmetry: BROKEN (${asymmetry}% asymmetric)</div>
                `;
                analysisPanel.innerHTML = filteredLines.join('\n') + disparityInfo;
            }
        }

        function createAsymmetricSCoordinateMap(imageData, config) {
            const { width, height } = imageData;
            const sMapData = new Uint8Array(width * height);
            
            // Calculate ASYMMETRIC S-coordinates for every pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const sCoord = calculateAsymmetricSCoordinate(x, y, width, height, config);
                    const sMagnitude = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                    
                    // Normalize and convert to 0-255 range
                    const sBounds = parseFloat(document.getElementById('sBounds').value);
                    const normalizedS = Math.min(sMagnitude / sBounds, 1.0);
                    sMapData[y * width + x] = Math.round(normalizedS * 255);
                }
            }
            
            return sMapData;
        }

        // ==================== APPLICATION STATE ====================

        let currentStream = null;
        let isProcessing = false;
        let animationFrameId = null;
        let fpsCounters = {
            left: { frames: 0, lastTime: 0, fps: 0 },
            right: { frames: 0, lastTime: 0, fps: 0 },
            depth: { frames: 0, lastTime: 0, fps: 0 }
        };

        let animationStates = {
            theta: false,
            phi: false,
            thetaDirection: 1,
            phiDirection: 1,
            thetaSpeed: 2.0,
            phiSpeed: 0.5,
            animationRunning: false
        };

        const processingConfig = {
            haditTheta: 45.0,
            haditPhi: 90.0,
            haditInfluence: 2.0,
            sDisparity: 30.0,
            sScale: 2.5,
            separation: 10,
            colorLeveling: 0.3,
            projectionMode: 'linear',
            flattenFactor: 0.8,
            sBounds: 20.0,
            coordinateMapping: 'normalized_cartesian',
            asymmetryMode: 'rotation',
            rotationAngle: 30.0,
            spatialOffset: 0.2,
            perturbation: 0.1
        };

        // ==================== CONTROL SYNCHRONIZATION ====================

        function synchronizeControls() {
            // Theta control
            const haditTheta = document.getElementById('haditTheta');
            const haditThetaNumber = document.getElementById('haditThetaNumber');
            const haditThetaValue = document.getElementById('haditThetaValue');
            
            function updateTheta(value) {
                const val = parseFloat(value);
                haditTheta.value = val;
                haditThetaNumber.value = val;
                haditThetaValue.textContent = val.toFixed(1) + '°';
                processingConfig.haditTheta = val;
            }
            
            haditTheta.addEventListener('input', (e) => updateTheta(e.target.value));
            haditThetaNumber.addEventListener('input', (e) => updateTheta(e.target.value));
            
            // Phi control
            const haditPhi = document.getElementById('haditPhi');
            const haditPhiNumber = document.getElementById('haditPhiNumber');
            const haditPhiValue = document.getElementById('haditPhiValue');
            
            function updatePhi(value) {
                const val = Math.max(0.1, Math.min(179.9, parseFloat(value)));
                haditPhi.value = val;
                haditPhiNumber.value = val;
                haditPhiValue.textContent = val.toFixed(1) + '°';
                processingConfig.haditPhi = val;
            }
            
            haditPhi.addEventListener('input', (e) => updatePhi(e.target.value));
            haditPhiNumber.addEventListener('input', (e) => updatePhi(e.target.value));
            
            // Other controls
            const controls = [
                { id: 'haditInfluence', config: 'haditInfluence', format: (v) => v.toFixed(1) },
                { id: 'separation', config: 'separation', format: (v) => v + 'px' },
                { id: 'sDisparity', config: 'sDisparity', format: (v) => v.toFixed(1) + 'px' },
                { id: 'sScale', config: 'sScale', format: (v) => v.toFixed(1) + 'x' },
                { id: 'colorLeveling', config: 'colorLeveling', format: (v) => v.toFixed(2) + 'x' },
                { id: 'flattenFactor', config: 'flattenFactor', format: (v) => v.toFixed(2) },
                { id: 'sBounds', config: 'sBounds', format: (v) => v.toFixed(1) },
                { id: 'rotationAngle', config: 'rotationAngle', format: (v) => v.toFixed(1) + '°' },
                { id: 'spatialOffset', config: 'spatialOffset', format: (v) => v.toFixed(2) },
                { id: 'perturbation', config: 'perturbation', format: (v) => v.toFixed(2) }
            ];
            
            controls.forEach(control => {
                const element = document.getElementById(control.id);
                const valueElement = document.getElementById(control.id + 'Value');
                
                element.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    processingConfig[control.config] = value;
                    if (valueElement) {
                        valueElement.textContent = control.format(value);
                    }
                });
                
                const initialValue = parseFloat(element.value);
                processingConfig[control.config] = initialValue;
                if (valueElement) {
                    valueElement.textContent = control.format(initialValue);
                }
            });

            // Projection mode control
            const projectionMode = document.getElementById('projectionMode');
            projectionMode.addEventListener('change', (e) => {
                processingConfig.projectionMode = e.target.value;
                updateProjectionInfo();
            });

            // Coordinate mapping control
            const coordinateMapping = document.getElementById('coordinateMapping');
            coordinateMapping.addEventListener('change', (e) => {
                processingConfig.coordinateMapping = e.target.value;
                updateProjectionInfo();
            });

            // Asymmetry mode control
            const asymmetryMode = document.getElementById('asymmetryMode');
            asymmetryMode.addEventListener('change', (e) => {
                processingConfig.asymmetryMode = e.target.value;
                updateProjectionInfo();
            });
        }

        function updateProjectionInfo() {
            const analysisPanel = document.getElementById('analysisPanel');
            const asymmetryMode = document.getElementById('asymmetryMode').value;
            const coordinateMapping = document.getElementById('coordinateMapping').value;
            const projectionMode = document.getElementById('projectionMode').value;
            const flattenFactor = document.getElementById('flattenFactor').value;
            
            if (analysisPanel) {
                // Update the projection info in the analysis panel
                const lines = analysisPanel.innerHTML.split('<div>');
                lines[3] = `Asymmetry mode: ${asymmetryMode}</div>`;
                lines[4] = `Coordinate mapping: ${coordinateMapping}</div>`;
                lines[5] = `Projection mode: ${projectionMode}</div>`;
                lines[6] = `Bilateral symmetry: ${asymmetryMode === 'none' ? 'SYMMETRIC' : 'BROKEN'}</div>`;
                analysisPanel.innerHTML = lines.join('<div>');
            }
        }

        // ==================== PRESET FUNCTIONS ====================

        function setupPresetButtons() {
            // Asymmetry mode presets
            document.getElementById('setAsymRotation').addEventListener('click', () => {
                document.getElementById('asymmetryMode').value = 'rotation';
                document.getElementById('rotationAngle').value = 45;
                document.getElementById('rotationAngleValue').textContent = '45.0°';
                processingConfig.asymmetryMode = 'rotation';
                processingConfig.rotationAngle = 45;
                updateProjectionInfo();
            });

            document.getElementById('setAsymOffset').addEventListener('click', () => {
                document.getElementById('asymmetryMode').value = 'offset';
                document.getElementById('spatialOffset').value = 0.3;
                document.getElementById('spatialOffsetValue').textContent = '0.30';
                processingConfig.asymmetryMode = 'offset';
                processingConfig.spatialOffset = 0.3;
                updateProjectionInfo();
            });

            document.getElementById('setAsymSpiral').addEventListener('click', () => {
                document.getElementById('asymmetryMode').value = 'spiral';
                document.getElementById('spatialOffset').value = 0.5;
                document.getElementById('spatialOffsetValue').textContent = '0.50';
                processingConfig.asymmetryMode = 'spiral';
                processingConfig.spatialOffset = 0.5;
                updateProjectionInfo();
            });

            document.getElementById('setAsymWave').addEventListener('click', () => {
                document.getElementById('asymmetryMode').value = 'wave';
                document.getElementById('spatialOffset').value = 0.4;
                document.getElementById('spatialOffsetValue').textContent = '0.40';
                processingConfig.asymmetryMode = 'wave';
                processingConfig.spatialOffset = 0.4;
                updateProjectionInfo();
            });

            document.getElementById('setAsymNone').addEventListener('click', () => {
                document.getElementById('asymmetryMode').value = 'none';
                processingConfig.asymmetryMode = 'none';
                updateProjectionInfo();
            });

            // Coordinate mapping presets
            document.getElementById('setMappingUniform').addEventListener('click', () => {
                document.getElementById('coordinateMapping').value = 'normalized_cartesian';
                processingConfig.coordinateMapping = 'normalized_cartesian';
                updateProjectionInfo();
            });

            document.getElementById('setMappingEquirect').addEventListener('click', () => {
                document.getElementById('coordinateMapping').value = 'spherical_equirect';
                processingConfig.coordinateMapping = 'spherical_equirect';
                updateProjectionInfo();
            });

            document.getElementById('setMappingMercator').addEventListener('click', () => {
                document.getElementById('coordinateMapping').value = 'spherical_mercator';
                processingConfig.coordinateMapping = 'spherical_mercator';
                updateProjectionInfo();
            });

            document.getElementById('setMappingDirect').addEventListener('click', () => {
                document.getElementById('coordinateMapping').value = 'direct_pixel';
                processingConfig.coordinateMapping = 'direct_pixel';
                updateProjectionInfo();
            });

            // Hadit presets
            document.getElementById('setHaditPole').addEventListener('click', () => {
                updatePhi(0.1);
                document.getElementById('haditPhi').value = 0.1;
                document.getElementById('haditPhiNumber').value = 0.1;
            });

            document.getElementById('setHaditEquator').addEventListener('click', () => {
                updatePhi(90.0);
                document.getElementById('haditPhi').value = 90.0;
                document.getElementById('haditPhiNumber').value = 90.0;
            });

            document.getElementById('setHaditNear180').addEventListener('click', () => {
                updatePhi(179.9);
                document.getElementById('haditPhi').value = 179.9;
                document.getElementById('haditPhiNumber').value = 179.9;
            });

            // S-Coordinate presets
            document.getElementById('setExtremeS').addEventListener('click', () => {
                document.getElementById('sDisparity').value = 80;
                document.getElementById('sScale').value = 8.0;
                document.getElementById('sDisparityValue').textContent = '80.0px';
                document.getElementById('sScaleValue').textContent = '8.0x';
                processingConfig.sDisparity = 80;
                processingConfig.sScale = 8.0;
            });

            document.getElementById('setDeepS').addEventListener('click', () => {
                document.getElementById('sDisparity').value = 50;
                document.getElementById('sScale').value = 5.0;
                document.getElementById('sDisparityValue').textContent = '50.0px';
                document.getElementById('sScaleValue').textContent = '5.0x';
                processingConfig.sDisparity = 50;
                processingConfig.sScale = 5.0;
            });

            document.getElementById('setSubtleS').addEventListener('click', () => {
                document.getElementById('sDisparity').value = 15;
                document.getElementById('sScale').value = 1.5;
                document.getElementById('sDisparityValue').textContent = '15.0px';
                document.getElementById('sScaleValue').textContent = '1.5x';
                processingConfig.sDisparity = 15;
                processingConfig.sScale = 1.5;
            });

            document.getElementById('setNoS').addEventListener('click', () => {
                document.getElementById('sDisparity').value = 0;
                document.getElementById('sScale').value = 0.1;
                document.getElementById('sDisparityValue').textContent = '0.0px';
                document.getElementById('sScaleValue').textContent = '0.1x';
                processingConfig.sDisparity = 0;
                processingConfig.sScale = 0.1;
            });

            // Animation controls
            document.getElementById('animateTheta').addEventListener('click', () => {
                animationStates.theta = !animationStates.theta;
                if (animationStates.theta && !animationStates.animationRunning) {
                    startAnimation();
                }
            });

            document.getElementById('animatePhi').addEventListener('click', () => {
                animationStates.phi = !animationStates.phi;
                if (animationStates.phi && !animationStates.animationRunning) {
                    startAnimation();
                }
            });

            document.getElementById('stopAnimation').addEventListener('click', () => {
                animationStates.theta = false;
                animationStates.phi = false;
                animationStates.animationRunning = false;
            });
        }

        // ==================== ANIMATION SYSTEM ====================

        function startAnimation() {
            if (animationStates.animationRunning) return;
            animationStates.animationRunning = true;

            function animateFrame() {
                if (!animationStates.theta && !animationStates.phi) {
                    animationStates.animationRunning = false;
                    return;
                }

                if (animationStates.theta) {
                    let currentTheta = parseFloat(document.getElementById('haditTheta').value);
                    currentTheta += animationStates.thetaSpeed * animationStates.thetaDirection;
                    
                    if (currentTheta >= 360) {
                        currentTheta = 0;
                    } else if (currentTheta < 0) {
                        currentTheta = 359.9;
                    }
                    
                    updateTheta(currentTheta);
                }

                if (animationStates.phi) {
                    let currentPhi = parseFloat(document.getElementById('haditPhi').value);
                    currentPhi += animationStates.phiSpeed * animationStates.phiDirection;
                    
                    if (currentPhi >= 179.9) {
                        animationStates.phiDirection = -1;
                        currentPhi = 179.9;
                    } else if (currentPhi <= 0.1) {
                        animationStates.phiDirection = 1;
                        currentPhi = 0.1;
                    }
                    
                    updatePhi(currentPhi);
                }

                if (animationStates.animationRunning) {
                    setTimeout(animateFrame, 50); // 20 FPS for smooth animation
                }
            }

            animateFrame();
        }

        // ==================== CAMERA MANAGEMENT ====================

        async function startCamera() {
            try {
                document.getElementById('cameraStatus').innerHTML = 
                    '<span class="status-connecting">📹 Connecting to camera...</span>';
                
                const resolution = document.getElementById('resolutionSelect').value;
                const facingMode = document.getElementById('facingMode').value;
                const [width, height] = resolution.split('x').map(Number);
                
                const constraints = {
                    video: {
                        width: { ideal: width },
                        height: { ideal: height },
                        facingMode: { ideal: facingMode },
                        frameRate: { ideal: 30 }
                    }
                };
                
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                const videoElement = document.getElementById('debugVideo');
                videoElement.srcObject = currentStream;
                
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });
                
                document.getElementById('cameraStatus').innerHTML = 
                    '<span class="status-active">📹 Camera active - generating asymmetric S-coordinate stereograms with NO BILATERAL DIVISION</span>';
                document.getElementById('startCamera').style.display = 'none';
                document.getElementById('switchCamera').style.display = 'inline-block';
                document.getElementById('stopCamera').style.display = 'inline-block';
                document.getElementById('errorPanel').style.display = 'none';
                
                startProcessing();
                
            } catch (error) {
                console.error('Camera error:', error);
                showError(error.message);
            }
        }

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorPanel').style.display = 'block';
            document.getElementById('cameraStatus').innerHTML = 
                '<span class="status-error">❌ Camera connection failed</span>';
        }

        function stopCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            isProcessing = false;
            
            document.getElementById('startCamera').style.display = 'inline-block';
            document.getElementById('switchCamera').style.display = 'none';
            document.getElementById('stopCamera').style.display = 'none';
            document.getElementById('cameraStatus').innerHTML = 
                '<span class="status-connecting">📹 Camera system ready - click Start Camera</span>';
        }

        async function switchCamera() {
            const currentFacingMode = document.getElementById('facingMode').value;
            const newFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
            
            document.getElementById('facingMode').value = newFacingMode;
            
            // Stop current camera
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Start new camera
            await startCamera();
        }

        // ==================== PROCESSING LOOP ====================

        function startProcessing() {
            if (isProcessing) return;
            isProcessing = true;
            
            const videoElement = document.getElementById('debugVideo');
            const processingCanvas = document.createElement('canvas');
            const processingCtx = processingCanvas.getContext('2d');
            const qualityFactor = parseFloat(document.getElementById('qualitySelect').value);
            
            function processFrame() {
                if (!isProcessing || !currentStream) return;
                
                const videoWidth = videoElement.videoWidth;
                const videoHeight = videoElement.videoHeight;
                
                if (videoWidth && videoHeight) {
                    // Set processing canvas size based on quality
                    const processWidth = Math.floor(videoWidth * qualityFactor);
                    const processHeight = Math.floor(videoHeight * qualityFactor);
                    
                    processingCanvas.width = processWidth;
                    processingCanvas.height = processHeight;
                    
                    // Set output canvas sizes
                    const leftCanvas = document.getElementById('leftCanvas');
                    const rightCanvas = document.getElementById('rightCanvas');
                    const depthCanvas = document.getElementById('depthCanvas');
                    
                    leftCanvas.width = processWidth;
                    leftCanvas.height = processHeight;
                    rightCanvas.width = processWidth;
                    rightCanvas.height = processHeight;
                    depthCanvas.width = Math.floor(processWidth / 2);
                    depthCanvas.height = Math.floor(processHeight / 2);
                    
                    // Draw video frame to processing canvas
                    processingCtx.drawImage(videoElement, 0, 0, processWidth, processHeight);
                    const imageData = processingCtx.getImageData(0, 0, processWidth, processHeight);
                    
                    // Generate stereogram if enabled
                    if (document.getElementById('enableStereo').checked) {
                        renderAsymmetricSCoordinateStereogram(imageData, processingConfig);
                        updateFPS('left');
                        updateFPS('right');
                    }
                    
                    // Generate S-coordinate map if enabled
                    if (document.getElementById('showSCoordMap').checked) {
                        const sMapData = createAsymmetricSCoordinateMap(imageData, processingConfig);
                        renderSCoordinateMap(sMapData, Math.floor(processWidth / 2), Math.floor(processHeight / 2));
                        updateFPS('depth');
                    }
                }
                
                animationFrameId = requestAnimationFrame(processFrame);
            }
            
            processFrame();
        }

        function renderSCoordinateMap(sMapData, width, height) {
            const depthCanvas = document.getElementById('depthCanvas');
            const depthCtx = depthCanvas.getContext('2d');
            
            const depthImageData = new ImageData(width, height);
            
            for (let i = 0; i < sMapData.length; i++) {
                const value = sMapData[i];
                const baseIndex = i * 4;
                
                // Create heat map visualization
                depthImageData.data[baseIndex] = value; // Red
                depthImageData.data[baseIndex + 1] = Math.floor(value * 0.5); // Green
                depthImageData.data[baseIndex + 2] = Math.floor(255 - value); // Blue
                depthImageData.data[baseIndex + 3] = 255; // Alpha
            }
            
            depthCtx.putImageData(depthImageData, 0, 0);
        }

        function updateFPS(type) {
            const now = Date.now();
            const counter = fpsCounters[type];
            
            counter.frames++;
            
            if (now - counter.lastTime >= 1000) {
                counter.fps = Math.round(counter.frames * 1000 / (now - counter.lastTime));
                counter.frames = 0;
                counter.lastTime = now;
                
                if (document.getElementById('showFPS').checked) {
                    const fpsElement = document.getElementById(type + 'Fps');
                    if (fpsElement) {
                        fpsElement.textContent = counter.fps + ' FPS';
                    }
                }
            }
        }

        // ==================== UTILITY FUNCTIONS ====================

        function requestPermissions() {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(() => {
                    document.getElementById('cameraStatus').innerHTML = 
                        '<span class="status-active">✅ Camera permissions granted</span>';
                })
                .catch((error) => {
                    showError('Permission denied: ' + error.message);
                });
        }

        function toggleDebugVideo() {
            const debugVideo = document.getElementById('debugVideo');
            if (debugVideo.style.display === 'none') {
                debugVideo.style.display = 'block';
                document.getElementById('showRawFeed').checked = true;
            } else {
                debugVideo.style.display = 'none';
                document.getElementById('showRawFeed').checked = false;
            }
        }

        // Helper functions for updating control values
        function updateTheta(value) {
            const val = parseFloat(value);
            document.getElementById('haditTheta').value = val;
            document.getElementById('haditThetaNumber').value = val;
            document.getElementById('haditThetaValue').textContent = val.toFixed(1) + '°';
            processingConfig.haditTheta = val;
        }

        function updatePhi(value) {
            const val = Math.max(0.1, Math.min(179.9, parseFloat(value)));
            document.getElementById('haditPhi').value = val;
            document.getElementById('haditPhiNumber').value = val;
            document.getElementById('haditPhiValue').textContent = val.toFixed(1) + '°';
            processingConfig.haditPhi = val;
        }

        // ==================== EVENT LISTENERS ====================

        function setupEventListeners() {
            // Camera controls
            document.getElementById('startCamera').addEventListener('click', startCamera);
            document.getElementById('stopCamera').addEventListener('click', stopCamera);
            document.getElementById('switchCamera').addEventListener('click', switchCamera);
            document.getElementById('requestPermissions').addEventListener('click', requestPermissions);
            document.getElementById('toggleDebugVideo').addEventListener('click', toggleDebugVideo);

            // Checkbox controls
            document.getElementById('showRawFeed').addEventListener('change', (e) => {
                const debugVideo = document.getElementById('debugVideo');
                debugVideo.style.display = e.target.checked ? 'block' : 'none';
            });

            document.getElementById('showFPS').addEventListener('change', (e) => {
                const fpsElements = document.querySelectorAll('.fps-counter');
                fpsElements.forEach(element => {
                    element.style.display = e.target.checked ? 'block' : 'none';
                });
            });

            // Quality change handler
            document.getElementById('qualitySelect').addEventListener('change', () => {
                if (isProcessing) {
                    // Restart processing with new quality
                    isProcessing = false;
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                    }
                    setTimeout(() => {
                        if (currentStream) {
                            startProcessing();
                        }
                    }, 100);
                }
            });
        }

        // ==================== INITIALIZATION ====================

        function initialize() {
            console.log('Initializing Asymmetric S-Coordinate Stereogram System...');
            console.log('Current Date and Time (UTC): 2025-06-08 11:54:19');
            console.log('Current User Login: Angledcrystals');
            console.log('FIXED: Bilateral symmetry issue resolved with asymmetric transformation controls');
            console.log('NEW: Rotation, offset, perturbation, spiral, and wave asymmetry modes');
            console.log('SOLUTION: Breaks Householder reflection symmetry for full-image transformations');
            
            // Set up all controls and event listeners
            synchronizeControls();
            setupPresetButtons();
            setupEventListeners();
            updateProjectionInfo();
            
            // Initialize analysis panel
            const analysisPanel = document.getElementById('analysisPanel');
            if (analysisPanel) {
                analysisPanel.innerHTML = `
                    <div style="color: #88ff00; font-weight: bold;">📐 Asymmetric S-Coordinate Analysis</div>
                    <div>Ready for asymmetric S-coordinate generation...</div>
                    <div>Camera permissions status: checking...</div>
                    <div>Asymmetry mode: ${processingConfig.asymmetryMode}</div>
                    <div>Coordinate mapping: ${processingConfig.coordinateMapping}</div>
                    <div>Projection mode: ${processingConfig.projectionMode}</div>
                    <div>Bilateral symmetry: BROKEN</div>
                    <div>System ready for full-image transformations...</div>
                `;
            }
            
            // Check camera permissions on load
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.enumerateDevices()
                    .then(devices => {
                        const videoDevices = devices.filter(device => device.kind === 'videoinput');
                        console.log(`Found ${videoDevices.length} video devices`);
                        
                        if (videoDevices.length > 1) {
                            document.getElementById('switchCamera').style.display = 'inline-block';
                        }
                        
                        document.getElementById('cameraStatus').innerHTML = 
                            '<span class="status-connecting">📹 Camera system ready - click Start Camera</span>';
                    })
                    .catch(error => {
                        console.error('Error enumerating devices:', error);
                        showError('Camera enumeration failed: ' + error.message);
                    });
            } else {
                showError('Camera API not supported in this browser');
            }
            
            console.log('Asymmetric S-Coordinate system initialized successfully!');
            console.log('Asymmetry modes available: Rotation, Offset, Perturbation, Spiral, Wave, None');
            console.log('Coordinate mapping modes available: Normalized Cartesian, Spherical Equirectangular, Spherical Mercator, Direct Pixel');
            console.log('Projection modes available: Stereographic, Linear, Equirectangular, Hybrid');
            console.log('Default settings: Rotation asymmetry + Normalized Cartesian + Linear projection');
            console.log('Bilateral symmetry ELIMINATED with asymmetric coordinate transformations!');
        }

        // ==================== WINDOW LOAD ====================

        window.addEventListener('load', initialize);
        window.addEventListener('beforeunload', () => {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
        });

        // ==================== ERROR HANDLING ====================

        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            showError(`Application error: ${event.error.message}`);
        });

        // ==================== RESPONSIVE HANDLING ====================

        window.addEventListener('resize', () => {
            // Debounce resize events
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                if (isProcessing) {
                    // Restart processing to adjust canvas sizes
                    isProcessing = false;
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                    }
                    setTimeout(() => {
                        if (currentStream) {
                            startProcessing();
                        }
                    }, 200);
                }
            }, 250);
        });

        // ==================== DEBUG FUNCTIONS ====================

        function debugAsymmetricMapping() {
            const width = 640;
            const height = 480;
            
            console.log('=== Asymmetric Coordinate Mapping Debug ===');
            
            // Test center and mirror points across different asymmetry modes
            const testPoints = [
                { x: width/4, y: height/2, name: 'Left-Center' },
                { x: width/2, y: height/2, name: 'Center' },
                { x: 3*width/4, y: height/2, name: 'Right-Center' },
                { x: width/2, y: height/4, name: 'Top-Center' },
                { x: width/2, y: 3*height/4, name: 'Bottom-Center' }
            ];
            
            const asymmetryModes = ['none', 'rotation', 'offset', 'perturbation', 'spiral', 'wave'];
            const config = processingConfig;
            
            asymmetryModes.forEach(mode => {
                console.log(`\n--- ASYMMETRY MODE: ${mode.toUpperCase()} ---`);
                testPoints.forEach(point => {
                    const coords1 = pixelToCoordinates(point.x, point.y, width, height, 'normalized_cartesian', mode, config);
                    const coords2 = pixelToCoordinates(width - point.x, point.y, width, height, 'normalized_cartesian', mode, config);
                    const symmetryDiff = Math.abs(coords1.theta - coords2.theta) + Math.abs(coords1.phi - coords2.phi);
                    console.log(`${point.name}: (${point.x}, ${point.y}) -> θ=${coords1.theta.toFixed(1)}°, φ=${coords1.phi.toFixed(1)}°`);
                    console.log(`  Mirror: (${width - point.x}, ${point.y}) -> θ=${coords2.theta.toFixed(1)}°, φ=${coords2.phi.toFixed(1)}° | Asymmetry: ${symmetryDiff.toFixed(2)}`);
                });
            });
        }

        function testSymmetryBreaking() {
            const width = 640;
            const height = 480;
            const config = processingConfig;
            
            console.log('=== Symmetry Breaking Test ===');
            
            let symmetricPixels = 0;
            let asymmetricPixels = 0;
            let totalPixels = 0;
            
            // Sample every 10th pixel for performance
            for (let y = 0; y < height; y += 10) {
                for (let x = 0; x < width; x += 10) {
                    const mirrorX = width - x;
                    if (mirrorX >= 0 && mirrorX < width) {
                        const sCoord1 = calculateAsymmetricSCoordinate(x, y, width, height, config);
                        const sCoord2 = calculateAsymmetricSCoordinate(mirrorX, y, width, height, config);
                        
                        const magnitude1 = Math.sqrt(sCoord1.x * sCoord1.x + sCoord1.y * sCoord1.y);
                        const magnitude2 = Math.sqrt(sCoord2.x * sCoord2.x + sCoord2.y * sCoord2.y);
                        
                        const difference = Math.abs(magnitude1 - magnitude2);
                        
                        if (difference < 0.1) {
                            symmetricPixels++;
                        } else {
                            asymmetricPixels++;
                        }
                        totalPixels++;
                    }
                }
            }
            
            const asymmetryPercentage = (asymmetricPixels / totalPixels * 100).toFixed(1);
            console.log(`Symmetry Breaking Results:`);
            console.log(`- Total pixels tested: ${totalPixels}`);
            console.log(`- Symmetric pixels: ${symmetricPixels} (${(symmetricPixels/totalPixels*100).toFixed(1)}%)`);
            console.log(`- Asymmetric pixels: ${asymmetricPixels} (${asymmetryPercentage}%)`);
            console.log(`- Asymmetry mode: ${processingConfig.asymmetryMode}`);
            console.log(`- Bilateral symmetry ${asymmetryPercentage > 50 ? 'SUCCESSFULLY BROKEN' : 'STILL PRESENT'}`);
        }

        // Make debug functions available globally
        window.debugAsymmetricMapping = debugAsymmetricMapping;
        window.testSymmetryBreaking = testSymmetryBreaking;

    </script>
</body>
</html>
