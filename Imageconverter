<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S-Coordinate Stereogram Creator - Angledcrystals</title>
    <style>
        body {
            font-family: 'Segoe UI', Taurus, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .header .subtitle {
            font-size: 1.1em;
            opacity: 0.8;
            margin-top: 10px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            align-items: start;
        }

        .controls-panel {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .image-section {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .slider {
            width: 100%;
            margin: 10px 0;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            outline: none;
            height: 6px;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .value-display {
            background: rgba(0,0,0,0.3);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8em;
            display: inline-block;
            margin-left: 10px;
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            border: none;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 1em;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            margin-bottom: 15px;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .file-input-button {
            display: block;
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .image-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .image-container {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            /* Allow container to expand with content */
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .image-container h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .image-container canvas {
            max-width: 100%;
            max-height: 400px; /* Maximum height to prevent excessive size */
            height: auto;
            width: auto;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.3);
            object-fit: contain; /* Maintain aspect ratio */
        }

        .depth-map-section {
            margin-top: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
        }

        .depth-map-section h3 {
            margin: 0 0 15px 0;
            text-align: center;
        }

        .depth-map-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .processing-indicator {
            text-align: center;
            padding: 20px;
            font-style: italic;
            opacity: 0.7;
        }

        .aspect-ratio-info {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.85em;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
            }
            
            .controls-panel {
                order: 2;
            }
            
            .image-section {
                order: 1;
            }

            .image-display {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>S-Coordinate Stereogram Creator</h1>
            <div class="subtitle">Advanced Mathematical Depth Mapping Framework</div>
            <div class="subtitle">Session: Angledcrystals - 2025-06-05 15:35:07 UTC</div>
        </div>

        <div class="main-content">
            <div class="controls-panel">
                <div class="control-group">
                    <div class="file-input-wrapper">
                        <input type="file" id="imageInput" class="file-input" accept="image/*">
                        <label for="imageInput" class="file-input-button">
                            üìÅ Load Image
                        </label>
                    </div>
                </div>

                <div id="aspectRatioInfo" class="aspect-ratio-info" style="display: none;">
                    <strong>Aspect Ratio Preserved:</strong><br>
                    Original: <span id="originalDimensions">-</span><br>
                    Display: <span id="displayDimensions">-</span><br>
                    Ratio: <span id="aspectRatio">-</span>
                </div>

                <div class="control-group">
                    <label for="depthMethod">Depth Calculation Method:</label>
                    <select id="depthMethod">
                        <option value="sum_xy">Sum XY S-Coordinates</option>
                        <option value="radial">Radial Zones</option>
                        <option value="nuit">Nuit Distance</option>
                        <option value="hybrid">Hybrid</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="sBounds">S-Bounds: <span class="value-display" id="sBoundsValue">¬±5.0</span></label>
                    <input type="range" id="sBounds" class="slider" min="1" max="10" step="0.1" value="5">
                </div>

                <div class="control-group">
                    <label for="nuitRadius">Nuit Radius: <span class="value-display" id="nuitRadiusValue">7.0</span></label>
                    <input type="range" id="nuitRadius" class="slider" min="0.5" max="15" step="0.1" value="7">
                </div>

                <div class="control-group">
                    <label for="lumWeight">Luminosity Weight: <span class="value-display" id="lumWeightValue">0.70</span></label>
                    <input type="range" id="lumWeight" class="slider" min="0" max="1" step="0.01" value="0.7">
                </div>

                <div class="control-group">
                    <label for="satWeight">Saturation Weight: <span class="value-display" id="satWeightValue">0.30</span></label>
                    <input type="range" id="satWeight" class="slider" min="0" max="1" step="0.01" value="0.3">
                </div>

                <div class="control-group">
                    <label for="depthIntensity">Depth Intensity: <span class="value-display" id="depthIntensityValue">5</span></label>
                    <input type="range" id="depthIntensity" class="slider" min="1" max="50" step="1" value="5">
                </div>

                <div class="control-group">
                    <label for="eyeSeparation">Eye Separation %: <span class="value-display" id="eyeSeparationValue">3.0%</span></label>
                    <input type="range" id="eyeSeparation" class="slider" min="0.5" max="8" step="0.1" value="3">
                </div>

                <div class="stats-panel">
                    <h4>Processing Statistics</h4>
                    <div class="stats-row">
                        <span>Processing Time:</span>
                        <span id="processingTime">-</span>
                    </div>
                    <div class="stats-row">
                        <span>Image Dimensions:</span>
                        <span id="imageDimensions">-</span>
                    </div>
                    <div class="stats-row">
                        <span>Depth Range:</span>
                        <span id="depthRange">-</span>
                    </div>
                    <div class="stats-row">
                        <span>S-Coordinate Range:</span>
                        <span id="sCoordRange">-</span>
                    </div>
                </div>
            </div>

            <div class="image-section">
                <div class="image-display">
                    <div class="image-container">
                        <h3>Left Eye View</h3>
                        <canvas id="leftCanvas"></canvas>
                    </div>
                    <div class="image-container">
                        <h3>Right Eye View</h3>
                        <canvas id="rightCanvas"></canvas>
                    </div>
                </div>

                <div class="depth-map-section">
                    <h3>Generated Depth Map</h3>
                    <div class="depth-map-container">
                        <canvas id="depthCanvas"></canvas>
                    </div>
                </div>

                <div id="processingIndicator" class="processing-indicator">
                    Load an image to begin S-coordinate depth processing...
                </div>
            </div>
        </div>
    </div>

    <script>
        class SCoordinateStereogramCreator {
            constructor() {
                this.currentImage = null;
                this.imageData = null;
                this.depthMap = null;
                this.originalWidth = 0;
                this.originalHeight = 0;
                this.canvasWidth = 0;
                this.canvasHeight = 0;
                this.aspectRatio = 1;
                this.maxDisplayWidth = 500;  // Maximum width for display
                this.maxDisplayHeight = 400; // Maximum height for display
                
                // S-Coordinate parameters
                this.sBounds = 5.0;
                this.nuitRadius = 7.0;
                this.lumWeight = 0.7;
                this.satWeight = 0.3;
                this.depthIntensity = 5;
                this.eyeSeparation = 3.0;
                this.depthMethod = 'sum_xy';
                
                this.initializeElements();
                this.setupEventListeners();
                this.updateDisplayValues();
            }

            initializeElements() {
                this.leftCanvas = document.getElementById('leftCanvas');
                this.rightCanvas = document.getElementById('rightCanvas');
                this.depthCanvas = document.getElementById('depthCanvas');
                this.leftCtx = this.leftCanvas.getContext('2d');
                this.rightCtx = this.rightCanvas.getContext('2d');
                this.depthCtx = this.depthCanvas.getContext('2d');
                
                this.processingIndicator = document.getElementById('processingIndicator');
                this.aspectRatioInfo = document.getElementById('aspectRatioInfo');
            }

            setupEventListeners() {
                // File input
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0]);
                });

                // Parameter controls
                const controls = [
                    'sBounds', 'nuitRadius', 'lumWeight', 'satWeight', 
                    'depthIntensity', 'eyeSeparation', 'depthMethod'
                ];

                controls.forEach(control => {
                    const element = document.getElementById(control);
                    if (element) {
                        element.addEventListener('input', () => {
                            this.updateParameter(control, element.value);
                        });
                    }
                });
            }

            updateParameter(param, value) {
                switch(param) {
                    case 'sBounds':
                        this.sBounds = parseFloat(value);
                        break;
                    case 'nuitRadius':
                        this.nuitRadius = parseFloat(value);
                        break;
                    case 'lumWeight':
                        this.lumWeight = parseFloat(value);
                        break;
                    case 'satWeight':
                        this.satWeight = parseFloat(value);
                        break;
                    case 'depthIntensity':
                        this.depthIntensity = parseInt(value);
                        break;
                    case 'eyeSeparation':
                        this.eyeSeparation = parseFloat(value);
                        break;
                    case 'depthMethod':
                        this.depthMethod = value;
                        break;
                }

                this.updateDisplayValues();
                
                if (this.currentImage) {
                    this.processImage();
                }
            }

            updateDisplayValues() {
                document.getElementById('sBoundsValue').textContent = `¬±${this.sBounds.toFixed(1)}`;
                document.getElementById('nuitRadiusValue').textContent = this.nuitRadius.toFixed(1);
                document.getElementById('lumWeightValue').textContent = this.lumWeight.toFixed(2);
                document.getElementById('satWeightValue').textContent = this.satWeight.toFixed(2);
                document.getElementById('depthIntensityValue').textContent = this.depthIntensity;
                document.getElementById('eyeSeparationValue').textContent = `${this.eyeSeparation.toFixed(1)}%`;
            }

            calculateOptimalDimensions(originalWidth, originalHeight) {
                const aspectRatio = originalWidth / originalHeight;
                
                let displayWidth, displayHeight;
                
                // Fit within maximum dimensions while preserving aspect ratio
                if (aspectRatio > 1) { // Landscape
                    displayWidth = Math.min(originalWidth, this.maxDisplayWidth);
                    displayHeight = displayWidth / aspectRatio;
                    
                    if (displayHeight > this.maxDisplayHeight) {
                        displayHeight = this.maxDisplayHeight;
                        displayWidth = displayHeight * aspectRatio;
                    }
                } else { // Portrait or square
                    displayHeight = Math.min(originalHeight, this.maxDisplayHeight);
                    displayWidth = displayHeight * aspectRatio;
                    
                    if (displayWidth > this.maxDisplayWidth) {
                        displayWidth = this.maxDisplayWidth;
                        displayHeight = displayWidth / aspectRatio;
                    }
                }
                
                return {
                    width: Math.round(displayWidth),
                    height: Math.round(displayHeight),
                    aspectRatio: aspectRatio
                };
            }

            updateAspectRatioInfo() {
                document.getElementById('originalDimensions').textContent = 
                    `${this.originalWidth}√ó${this.originalHeight}`;
                document.getElementById('displayDimensions').textContent = 
                    `${this.canvasWidth}√ó${this.canvasHeight}`;
                document.getElementById('aspectRatio').textContent = 
                    `${this.aspectRatio.toFixed(3)}:1`;
                
                this.aspectRatioInfo.style.display = 'block';
            }

            loadImage(file) {
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.currentImage = img;
                        this.originalWidth = img.naturalWidth;
                        this.originalHeight = img.naturalHeight;
                        
                        // Calculate optimal display dimensions
                        const dimensions = this.calculateOptimalDimensions(
                            this.originalWidth, this.originalHeight
                        );
                        
                        this.canvasWidth = dimensions.width;
                        this.canvasHeight = dimensions.height;
                        this.aspectRatio = dimensions.aspectRatio;
                        
                        // Update canvas dimensions
                        this.updateCanvasSizes();
                        this.updateAspectRatioInfo();
                        
                        this.processImage();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            updateCanvasSizes() {
                // Set canvas actual dimensions
                this.leftCanvas.width = this.canvasWidth;
                this.leftCanvas.height = this.canvasHeight;
                this.rightCanvas.width = this.canvasWidth;
                this.rightCanvas.height = this.canvasHeight;
                this.depthCanvas.width = this.canvasWidth;
                this.depthCanvas.height = this.canvasHeight;
                
                // Set CSS display size to match (ensures sharp rendering)
                const canvases = [this.leftCanvas, this.rightCanvas, this.depthCanvas];
                canvases.forEach(canvas => {
                    canvas.style.width = `${this.canvasWidth}px`;
                    canvas.style.height = `${this.canvasHeight}px`;
                });
            }

            processImage() {
                if (!this.currentImage) return;

                this.processingIndicator.textContent = 'Processing S-coordinates and generating depth map...';
                
                const startTime = performance.now();

                // Create processing canvas with correct dimensions
                const processCanvas = document.createElement('canvas');
                const processCtx = processCanvas.getContext('2d');
                
                processCanvas.width = this.canvasWidth;
                processCanvas.height = this.canvasHeight;
                
                // Draw image scaled to fit canvas while maintaining aspect ratio
                processCtx.drawImage(this.currentImage, 0, 0, this.canvasWidth, this.canvasHeight);
                this.imageData = processCtx.getImageData(0, 0, this.canvasWidth, this.canvasHeight);

                // Generate S-coordinate depth map
                this.generateSCoordinateDepthMap();

                // Generate stereoscopic pair
                this.generateStereoscopicPair();

                // Update statistics
                const processingTime = performance.now() - startTime;
                this.updateStatistics(processingTime);

                this.processingIndicator.textContent = 'Processing complete. Adjust parameters for real-time updates.';
            }

            generateSCoordinateDepthMap() {
                const width = this.canvasWidth;
                const height = this.canvasHeight;
                const data = this.imageData.data;
                
                this.depthMap = new Float32Array(width * height);
                let minDepth = Infinity;
                let maxDepth = -Infinity;
                let minSCoord = Infinity;
                let maxSCoord = -Infinity;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const pixelIndex = (y * width + x) * 4;
                        
                        // Extract RGB values
                        const r = data[pixelIndex];
                        const g = data[pixelIndex + 1];
                        const b = data[pixelIndex + 2];

                        // Calculate luminosity and saturation
                        const luminosity = (r + g + b) / (3 * 255);
                        const max = Math.max(r, g, b) / 255;
                        const min = Math.min(r, g, b) / 255;
                        const saturation = max > 0 ? (max - min) / max : 0;

                        // Convert to S-coordinates
                        const sCoord = this.pixelToSCoordinate(x, y, width, height, luminosity, saturation);
                        
                        // Track S-coordinate range
                        const sCoordMagnitude = Math.abs(sCoord.x) + Math.abs(sCoord.y);
                        minSCoord = Math.min(minSCoord, sCoordMagnitude);
                        maxSCoord = Math.max(maxSCoord, sCoordMagnitude);

                        // Calculate depth using selected method
                        const depth = this.calculateDepthFromSCoordinate(sCoord);
                        
                        this.depthMap[y * width + x] = depth;
                        minDepth = Math.min(minDepth, depth);
                        maxDepth = Math.max(maxDepth, depth);
                    }
                }

                // Store statistics
                this.depthStats = { minDepth, maxDepth, minSCoord, maxSCoord };

                // Render depth map visualization
                this.renderDepthMap();
            }

            pixelToSCoordinate(px, py, width, height, luminosity, saturation) {
                // Step 1: Normalize pixel coordinates to [-1, +1]
                const normX = (px / (width - 1)) * 2 - 1;
                const normY = (py / (height - 1)) * 2 - 1;

                // Step 2: Calculate color influence on effective bounds
                const colorScale = 1 + (luminosity * this.lumWeight + saturation * this.satWeight);
                const effectiveBounds = this.sBounds * colorScale;

                // Step 3: Map to S-coordinate space
                const sX = normX * effectiveBounds;
                const sY = normY * effectiveBounds;

                return { x: sX, y: sY };
            }

            calculateDepthFromSCoordinate(sCoord) {
                switch (this.depthMethod) {
                    case 'sum_xy':
                        return this.calculateSumXYDepth(sCoord);
                    case 'radial':
                        return this.calculateRadialDepth(sCoord);
                    case 'nuit':
                        return this.calculateNuitDepth(sCoord);
                    case 'hybrid':
                        return this.calculateHybridDepth(sCoord);
                    default:
                        return this.calculateSumXYDepth(sCoord);
                }
            }

            calculateSumXYDepth(sCoord) {
                const manhattanDistance = Math.abs(sCoord.x) + Math.abs(sCoord.y);
                const maxPossibleSum = this.sBounds * 2;
                const normalizedSum = Math.min(manhattanDistance / maxPossibleSum, 1.0);
                return 0.2 + (normalizedSum * 0.8);
            }

            calculateRadialDepth(sCoord) {
                const euclideanDistance = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                const maxRadius = Math.sqrt(2) * this.sBounds;
                const normalizedRadius = Math.min(euclideanDistance / maxRadius, 1.0);
                return 1.0 - (normalizedRadius * 0.8);
            }

            calculateNuitDepth(sCoord) {
                const distanceFromOrigin = Math.sqrt(sCoord.x * sCoord.x + sCoord.y * sCoord.y);
                const distanceFromNuitBoundary = Math.abs(distanceFromOrigin - this.nuitRadius);
                const falloffDistance = distanceFromNuitBoundary * 0.1;
                return 1.0 / (1.0 + falloffDistance);
            }

            calculateHybridDepth(sCoord) {
                const radialDepth = this.calculateRadialDepth(sCoord);
                const nuitDepth = this.calculateNuitDepth(sCoord);
                return (radialDepth * 0.6) + (nuitDepth * 0.4);
            }

            renderDepthMap() {
                const width = this.canvasWidth;
                const height = this.canvasHeight;
                const imageData = this.depthCtx.createImageData(width, height);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const depth = this.depthMap[y * width + x];
                        const grayValue = Math.floor(depth * 255);
                        
                        const pixelIndex = (y * width + x) * 4;
                        imageData.data[pixelIndex] = grayValue;     // R
                        imageData.data[pixelIndex + 1] = grayValue; // G
                        imageData.data[pixelIndex + 2] = grayValue; // B
                        imageData.data[pixelIndex + 3] = 255;       // A
                    }
                }

                this.depthCtx.putImageData(imageData, 0, 0);
            }

            generateStereoscopicPair() {
                const width = this.canvasWidth;
                const height = this.canvasHeight;
                const originalData = this.imageData.data;
                
                const leftImageData = this.leftCtx.createImageData(width, height);
                const rightImageData = this.rightCtx.createImageData(width, height);
                
                const eyeSepPixels = (this.eyeSeparation / 100) * width;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const depth = this.depthMap[y * width + x];
                        const parallaxShift = depth * this.depthIntensity * eyeSepPixels / 50;

                        // Left eye: shift right (positive parallax)
                        const leftSourceX = Math.round(x + parallaxShift);
                        this.copyPixel(originalData, leftImageData.data, x, y, leftSourceX, y, width, height);

                        // Right eye: shift left (negative parallax)
                        const rightSourceX = Math.round(x - parallaxShift);
                        this.copyPixel(originalData, rightImageData.data, x, y, rightSourceX, y, width, height);
                    }
                }

                this.leftCtx.putImageData(leftImageData, 0, 0);
                this.rightCtx.putImageData(rightImageData, 0, 0);
            }

            copyPixel(sourceData, targetData, targetX, targetY, sourceX, sourceY, width, height) {
                // Boundary check
                if (sourceX < 0 || sourceX >= width || sourceY < 0 || sourceY >= height) {
                    // Fill with black for out-of-bounds
                    const targetIndex = (targetY * width + targetX) * 4;
                    targetData[targetIndex] = 0;
                    targetData[targetIndex + 1] = 0;
                    targetData[targetIndex + 2] = 0;
                    targetData[targetIndex + 3] = 255;
                    return;
                }

                const sourceIndex = (sourceY * width + sourceX) * 4;
                const targetIndex = (targetY * width + targetX) * 4;

                targetData[targetIndex] = sourceData[sourceIndex];         // R
                targetData[targetIndex + 1] = sourceData[sourceIndex + 1]; // G
                targetData[targetIndex + 2] = sourceData[sourceIndex + 2]; // B
                targetData[targetIndex + 3] = sourceData[sourceIndex + 3]; // A
            }

            updateStatistics(processingTime) {
                document.getElementById('processingTime').textContent = `${processingTime.toFixed(1)}ms`;
                document.getElementById('imageDimensions').textContent = 
                    `${this.canvasWidth}√ó${this.canvasHeight} (${this.originalWidth}√ó${this.originalHeight})`;
                
                if (this.depthStats) {
                    document.getElementById('depthRange').textContent = 
                        `${this.depthStats.minDepth.toFixed(3)} - ${this.depthStats.maxDepth.toFixed(3)}`;
                    document.getElementById('sCoordRange').textContent = 
                        `${this.depthStats.minSCoord.toFixed(2)} - ${this.depthStats.maxSCoord.toFixed(2)}`;
                }
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new SCoordinateStereogramCreator();
        });
    </script>
</body>
</html>
